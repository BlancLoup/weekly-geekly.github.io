<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compact C ++ library for programming finite-difference methods in operator style. Part 1. Semantics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The semantics of the developed pde ++ library for programming finite-difference methods in operator style is presented. The main objects of the librar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compact C ++ library for programming finite-difference methods in operator style. Part 1. Semantics</h1><div class="post__text post__text-html js-mediator-article">  The semantics of the developed pde ++ library for programming finite-difference methods in operator style is presented.  The main objects of the library are the grid function, the grid cell and the grid operators, the arithmetic relations between which the program code is as close as possible to its mathematical notation.  The pde ++ library is represented by just a few header files, has no external dependencies, and uses the concept of lazy evaluation. <br><a name="habracut"></a><br>  A large number of problems of mathematical modeling is reduced to the numerical solution of partial differential equations (ACE) by grid methods.  In the theory of difference schemes (Samara AA), the corresponding grid operators form a linear space over grid functions for which there is no direct representation in general-purpose programming languages ‚Äã‚Äãsuch as C ++.  As a result, the software implementation widely uses the practice of recording the result of applying grid operators to grid functions using multidimensional arrays or matrices. <br><br>  Practice shows that the approach noted above is very useful in questions of mastering the skills of implementing numerical methods, primarily due to its clarity when working with pre-written approximations of the DUPE in index form.  Significant problems do not arise also when this technique is distributed to generalized PAs, if it is intended to once implement a difference scheme with parameters and reuse the corresponding program code without further modifications. <br><br>  In the general case, the computing program can be modified in different directions, so the technique described above will require writing a significant amount of program code, and this, in turn, will increase the likelihood of typos and inconsistent recording of the same grid operators in different program modules.  It is also worth noting the problem of duplication of software code with the variability of spatial dimensions (1D, 2D, 3D) and methods of approximation of the DPCD. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Thus, the alternative is the development and use of specialized software libraries with high-level abstractions of the subject area, bringing the program code to its mathematical notation.  In the Blitz ++ library, such an abstraction is tensor calculations on difference templates, implemented on the basis of using the template metaprogramming technique.  The <a href="http://www.nongnu.org/freepooma/">freePOOMA</a> library extends the concept of Blitz ++ difference analogues of differential divergence and gradient operators and the ability to work on multiprocessor computing systems.  Unfortunately, these libraries have not been supported for a long time, while possessing a number of limitations (to be discussed in the next section) when used for fairly classical finite-difference approximations of the PAEs considered in this paper. <br><br>  The open source pde ++ library developed by the author is ideally inspired by the <a href="http://www.nongnu.org/freepooma/">freePOOMA</a> library and is designed to record in an operator form finite difference schemes for scalar and vector grid functions defined in 2D formulation (1D and 3D in operation) on uniform rectangular grids. <br><br>  <b>Attention: the</b> code was checked only under Windows. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pdepp.h"</span></span></span><span class="hljs-meta"> double sln_u(double x, double y) { return x * x + y * y; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// - void test_pdepp_1() { //2d- [a, b] x [a, b] double a = 0; double b = 1; //     int n = 10; double h = (b - a) / (n + 1); //   (     ) ScalarMeshFunc&lt;double&gt; u(a, b, n, n); ScalarMeshFunc&lt;double&gt; r(a, b, n, n); //    for (int i = 0; i &lt;= n + 1; i++) { for (int j = 0; j &lt;= n + 1; j++) { ScalarCell&lt;double&gt; &amp;c = u(i, j); c.val() = sln_u(cx(), cy()); } } //  for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { ASSERT_DBL_EQ(dx_left(u(i, j)), (u(i, j) - u(i - 1, j)) / h); ASSERT_DBL_EQ(dx_right(u(i, j)), (u(i + 1, j) - u(i, j)) / h); ASSERT_DBL_EQ(dy_left(u(i, j)), (u(i, j) - u(i, j - 1)) / h); ASSERT_DBL_EQ(dy_right(u(i, j)), (u(i, j + 1) - u(i, j)) / h); ASSERT_DBL_EQ(laplacian(u(i, j)), dx_left(dx_right(u(i, j))) + dy_left(dy_right(u(i, j)))); ASSERT_DBL_EQ(laplacian(u(i, j)), u(i, j).dx_left().dx_right() + u(i, j).dy_left().dy_right()); ASSERT_DBL_EQ(laplacian(u(i, j)), dx_right(dx_left(u(i, j))) + dy_right(dy_left(u(i, j)))); ASSERT_DBL_EQ(laplacian(u(i, j)), u(i, j).dx_right().dx_left() + u(i, j).dy_right().dy_left()); r(i, j) = laplacian(u(i, j)); ASSERT_DBL_EQ(r(i, j), 4.); } } // //   ScalarMeshFunc&lt;double&gt; f(a, b, n, n); f.all() = 0; //       Interval2d I(1, n, 1, n); f(I) = 4; r(I) = laplacian(u(I)) - f(I); for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { ASSERT_DBL_EQ(r(i, j), 0.); } } }</span></span></span></span></code> </pre> <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pdepp.h"</span></span></span><span class="hljs-meta"> double sln_u(double x, double y) { return x * x + y * y; } double sln_v(double x, double y) { return x * x * x + y * y * y; } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// - void test_pdepp_2() { //2d- [a, b] x [a, b] double a = 0; double b = 1; //     int n = 10; double h = (b - a) / (n + 1); //   VectorMeshFunc&lt;double&gt; U(a, b, n, n); //    for (int i = 0; i &lt;= n + 1; i++) { for (int j = 0; j &lt;= n + 1; j++) { VectorCell&lt;double&gt; &amp;c = U(i, j); c.comp(0).val() = sln_u(cx(), cy()); c.comp(1).val() = sln_v(cx(), cy()); } } //   for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { ASSERT_DBL_EQ(div_left(U(i, j)), (U(i, j).comp(0) - U(i - 1, j).comp(0)) / h + (U(i, j).comp(1) - U(i, j - 1).comp(1)) / h); ASSERT_DBL_EQ(div_left(U(i, j)), U(i, j).comp(0).dx_left() + U(i, j).comp(1).dy_left()); ASSERT_DBL_EQ(div_left(U(i, j)), dx_left(U(i, j).comp(0)) + dy_left(U(i, j).comp(1))); ASSERT_DBL_EQ(div_right(U(i, j)), (U(i + 1, j).comp(0) - U(i, j).comp(0)) / h + (U(i, j + 1).comp(1) - U(i, j).comp(1)) / h); ASSERT_DBL_EQ(div_right(U(i, j)), U(i, j).comp(0).dx_right() + U(i, j).comp(1).dy_right()); ASSERT_DBL_EQ(div_right(U(i, j)), dx_right(U(i, j).comp(0)) + dy_right(U(i, j).comp(1))); } } //        ScalarMeshFunc&lt;double&gt; u(a, b, n, n); Interval2d I(1, n, 1, n); u(I) = div_left(U(I)); u(I) = div_right(U(I)); //   for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { VectorCell&lt;double&gt; &amp;c = grad_left(u(i, j)); ASSERT_DBL_EQ(c.comp(0), (u(i, j) - u(i - 1, j)) / h); ASSERT_DBL_EQ(c.comp(0), u(i, j).dx_left()); ASSERT_DBL_EQ(c.comp(0), dx_left(u(i, j))); ASSERT_DBL_EQ(c.comp(1), (u(i, j) - u(i, j - 1)) / h); ASSERT_DBL_EQ(c.comp(1), u(i, j).dy_left()); ASSERT_DBL_EQ(c.comp(1), dy_left(u(i, j))); c = grad_right(u(i, j)); ASSERT_DBL_EQ(c.comp(0), (u(i + 1, j) - u(i, j)) / h); ASSERT_DBL_EQ(c.comp(0), u(i, j).dx_right()); ASSERT_DBL_EQ(c.comp(0), dx_right(u(i, j))); ASSERT_DBL_EQ(c.comp(1), (u(i, j + 1) - u(i, j)) / h); ASSERT_DBL_EQ(c.comp(1), u(i, j).dy_right()); ASSERT_DBL_EQ(c.comp(1), dy_right(u(i, j))); } } //        U(I) = grad_left(u(I)); U(I) = grad_right(u(I)); ScalarMeshFunc&lt;double&gt; f(a, b, n, n); f(I) = div_left(grad_right(u(I))); f(I) = div_right(grad_left(u(I))); VectorMeshFunc&lt;double&gt; F(a, b, n, n); F(I) = grad_left(div_right(U(I))); F(I) = grad_right(div_left(U(I))); }</span></span></span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Pdepp.h file</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//() 2016-2019  , SharipovTR@gmail.com // As Is #pragma once #include &lt;memory&gt; #include &lt;list&gt; #include "NumericAssert.h" #include "Arrays.h" //#define USE_STD_MOVE template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; class MeshCell { public: int dim_; MeshCell() : dim_(0), x_(0), y_(0), left_(0), right_(0), up_(0), down_(0), op_(OpEqual) { } MeshCell(const DerivCell &amp;rhs) : dim_(rhs.dim_), x_(rhs.x_), y_(rhs.y_), left_(rhs.left_), right_(rhs.right_), up_(rhs.up_), down_(rhs.down_), op_(rhs.op_) {}//todo:op? #if defined(USE_STD_MOVE) &amp;&amp; (_MSC_VER &gt; 1500) MeshCell(DerivCell &amp;&amp;rhs) : dim_(std::move(rhs.dim_)), x_(std::move(rhs.x_)), y_(std::move(rhs.y_)), left_(std::move(rhs.left_)), right_(std::move(rhs.right_)), up_(std::move(rhs.up_)), down_(std::move(rhs.down_)), op_(std::move(rhs.op_)) {}//todo:op? #endif virtual ~MeshCell() {} virtual ScalarCell &amp;comp(int i) = 0; virtual const ScalarCell &amp;comp(int i) const = 0; virtual DerivCell *This() = 0; void set_x(double x) { x_ = x; if (dim_ &gt; 1) for(int i = 0; i &lt; dim_; i++) { comp(i).set_x(x); } } double x() const { return x_; } void set_y(double y) { y_ = y; if (dim_ &gt; 1) for(int i = 0; i &lt; dim_; i++) { comp(i).set_y(y); } } double y() const { return y_; } void set_left(DerivCell *left) { left_ = left; if (!left) return; left-&gt;right_ = This(); if (dim_ &gt; 1) for(int i = 0; i &lt; dim_; i++) { comp(i).set_left(&amp;left-&gt;comp(i)); } } DerivCell *left() { return left_; } void set_right(DerivCell *right) { right_ = right; if (!right) return; right-&gt;left_ = This(); if (dim_ &gt; 1) for(int i = 0; i &lt; dim_; i++) { comp(i).set_right(&amp;right-&gt;comp(i)); } } DerivCell *right() { return right_; } void set_up(DerivCell *up) { up_ = up; if (!up) return; up-&gt;down_ = This(); if (dim_ &gt; 1) for(int i = 0; i &lt; dim_; i++) { comp(i).set_up(&amp;up-&gt;comp(i)); } } DerivCell *up() { return up_; } void set_down(DerivCell *down) { down_ = down; if (!down) return; down-&gt;up_ = This(); if (dim_ &gt; 1) for(int i = 0; i &lt; dim_; i++) { comp(i).set_down(&amp;down-&gt;comp(i)); } } DerivCell *down() { return down_; } DerivCell operator - () { return DerivCell(*This(), -1); } virtual DerivCell &amp;Instance(int i) = 0; virtual ScalarCell &amp;InstanceAsScalar(int i) = 0; virtual VectorCell &amp;InstanceAsVector(int i) = 0; DerivCell &amp;dx_left(bool recur = true); DerivCell &amp;dx_right(bool recur = true); DerivCell &amp;dy_right(bool recur = true); DerivCell &amp;dy_left(bool recur = true); DerivCell &amp;laplacian(bool recur = true); VectorCell &amp;grad_left(bool recur = true); VectorCell &amp;grad_right(bool recur = true); ScalarCell &amp;div_left(bool recur = true); ScalarCell &amp;div_right(bool recur = true); DerivCell &amp;operator = (const DerivCell &amp;rhs) { if (!me().left_ &amp;&amp; !me().right_ &amp;&amp; !me().up_ &amp;&amp; !me().down_) { me().dim_ = rhs.dim_; me().x_ = rhs.x_; me().y_ = rhs.y_; me().left_ = rhs.left_; me().right_ = rhs.right_; me().up_ = rhs.up_; me().down_ = rhs.down_; me().op_ = rhs.op_; } else { for (int i = 0; i &lt; dim_; i++) { me().comp(i).val() = rhs.comp(i).val(); } } return *This(); } #if defined(USE_STD_MOVE) &amp;&amp; (_MSC_VER &gt; 1500) DerivCell &amp;operator = (DerivCell &amp;&amp;rhs) { if (me().left_ || me().right_ || me().up_ || me().down_) return *This(); dim_ = std::move(rhs.dim_); x_ = std::move(rhs.x_); y_ = std::move(rhs.y_); left_ = std::move(rhs.left_); right_ = std::move(rhs.right_); up_ = std::move(rhs.up_); down_ = std::move(rhs.down_); op_ = std::move(rhs.op_); return *This(); } #endif DerivCell &amp;operator = (const T &amp;val) { for(int i = 0; i &lt; dim_; i++) { me().comp(i).val() = val; } return *This(); } #define DECLARE_CELL_OP(OPERAND)\ DerivCell &amp;operator OPERAND (const DerivCell &amp;rhs) {\ for(int i = 0; i &lt; dim_; i++) {\ me().comp(i).val() OPERAND rhs.comp(i).val();\ }\ return *This();\ }\ DerivCell &amp;operator OPERAND (const T &amp;val) {\ for(int i = 0; i &lt; dim_; i++) {\ me().comp(i).val() OPERAND val;\ }\ return *This();\ } DECLARE_CELL_OP( += ) DECLARE_CELL_OP( -= ) DECLARE_CELL_OP( *= ) DECLARE_CELL_OP( /= ) #undef DECLARE_CELL_OP DerivCell &amp; PlusEq() { return SetOp(OpPlus, 0); } DerivCell &amp;MinusEq() { return SetOp(OpMinus, 0); } DerivCell &amp;MultEq() { return SetOp(OpMult, 1); } DerivCell &amp;DivideEq() { return SetOp(OpDivide, 1); } DerivCell &amp;Eval() { if (OpEqual == op_) { return *This(); } switch(op_) { case OpPlus: op_ = OpEqual; *This() += ft(); break; case OpMinus: op_ = OpEqual; *This() -= ft(); break; case OpMult: op_ = OpEqual; *This() *= ft(); break; case OpDivide: op_ = OpEqual; *This() /= ft(); break; default: DASSERT(0 &amp;&amp; "Unknown arithmetic operation"); } return *This(); } protected: enum Operation { OpEqual, OpPlus, OpMinus, OpMult, OpDivide } op_; double x_; double y_; DerivCell *left_; DerivCell *right_; DerivCell *up_; DerivCell *down_; std::auto_ptr&lt;ScalarCell&gt; scal_[7];//todo:  shared_ptr std::auto_ptr&lt;VectorCell&gt; vec_[7];//todo:  shared_ptr DerivCell &amp;me() { return (OpEqual == op_) ? *This() : ft(); } DerivCell &amp;ft() { static DerivCell res(*This());//todo return res; //return Instance(6); } DerivCell &amp;SetOp(Operation op, int ft_val) { Eval(); op_ = op; ft() = ft_val; return *This(); } }; template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; DerivCell &amp; MeshCell&lt;T, DerivCell, ScalarCell, VectorCell&gt;::dx_left(bool recur) { DerivCell &amp;res = Instance(0); for(int i = 0; i &lt; dim_; i++) { DASSERT(left_ != 0); DASSERT(left_-&gt;x_ != x_); res.comp(i).val() = (comp(i).val() - left_-&gt;comp(i).val()) / (x_ - left_-&gt;x_); } if (recur) { if (left_ &amp;&amp; left_-&gt;left_) res.set_left(&amp;left_-&gt;dx_left(false)); if (right_ &amp;&amp; right_-&gt;left_) res.set_right(&amp;right_-&gt;dx_left(false)); if (up_ &amp;&amp; up_-&gt;left_) res.set_up(&amp;up_-&gt;dx_left(false)); if (down_ &amp;&amp; down_-&gt;left_) res.set_down(&amp;down_-&gt;dx_left(false)); } return res; } template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; DerivCell &amp; MeshCell&lt;T, DerivCell, ScalarCell, VectorCell&gt;::dx_right(bool recur) { DerivCell &amp;res = Instance(1); for(int i = 0; i &lt; dim_; i++) { DASSERT(right_ != 0); DASSERT(right_-&gt;x_ != x_); res.comp(i).val() = (right_-&gt;comp(i).val() - comp(i).val()) / (right_-&gt;x_ - x_); } if (recur) { if (left_ &amp;&amp; left_-&gt;right_) res.set_left(&amp;left_-&gt;dx_right(false)); if (right_ &amp;&amp; right_-&gt;right_) res.set_right(&amp;right_-&gt;dx_right(false)); if (up_ &amp;&amp; up_-&gt;right_) res.set_up(&amp;up_-&gt;dx_right(false)); if (down_ &amp;&amp; down_-&gt;right_) res.set_down(&amp;down_-&gt;dx_right(false)); } return res; } template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; DerivCell &amp; MeshCell&lt;T, DerivCell, ScalarCell, VectorCell&gt;::dy_left(bool recur) { DerivCell &amp;res = Instance(2); for(int i = 0; i &lt; dim_; i++) { DASSERT(down_ != 0); DASSERT(down_-&gt;y_ != y_); res.comp(i).val() = (comp(i).val() - down_-&gt;comp(i).val()) / (y_ - down_-&gt;y_); } if (recur) { if (left_ &amp;&amp; left_-&gt;down_) res.set_left(&amp;left_-&gt;dy_left(false)); if (right_ &amp;&amp; right_-&gt;down_) res.set_right(&amp;right_-&gt;dy_left(false)); if (up_ &amp;&amp; up_-&gt;down_) res.set_up(&amp;up_-&gt;dy_left(false)); if (down_ &amp;&amp; down_-&gt;down_) res.set_down(&amp;down_-&gt;dy_left(false)); } return res; } template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; DerivCell &amp; MeshCell&lt;T, DerivCell, ScalarCell, VectorCell&gt;::dy_right(bool recur) { DerivCell &amp;res = Instance(3); for(int i = 0; i &lt; dim_; i++) { DASSERT(up_ != 0); DASSERT(up_-&gt;y_ != y_); res.comp(i).val() = (up_-&gt;comp(i).val() - comp(i).val()) / (up_-&gt;y_ - y_); } if (recur) { if (left_ &amp;&amp; left_-&gt;up_) res.set_left(&amp;left_-&gt;dy_right(false)); if (right_ &amp;&amp; right_-&gt;up_) res.set_right(&amp;right_-&gt;dy_right(false)); if (up_ &amp;&amp; up_-&gt;up_) res.set_up(&amp;up_-&gt;dy_right(false)); if (down_ &amp;&amp; down_-&gt;up_) res.set_down(&amp;down_-&gt;dy_right(false)); } return res; } template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; DerivCell &amp; MeshCell&lt;T, DerivCell, ScalarCell, VectorCell&gt;::laplacian(bool recur) { DerivCell &amp;res = Instance(4); res = dx_left(recur).dx_right(false) + dy_left(recur).dy_right(false);//todo return res; } template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; ScalarCell &amp; MeshCell&lt;T, DerivCell, ScalarCell, VectorCell&gt;::div_left(bool recur) { ScalarCell &amp;res = InstanceAsScalar(5); if (dim_ &gt;= 1) res = comp(0).dx_left(recur); if (dim_ &gt;= 2) res += comp(1).dy_left(recur); if (recur) { if (left_ &amp;&amp; left_-&gt;left_ &amp;&amp; left_-&gt;down_) res.set_left(&amp;left_-&gt;div_left(false)); if (right_ &amp;&amp; right_-&gt;left_ &amp;&amp; right_-&gt;down_) res.set_right(&amp;right_-&gt;div_left(false)); if (up_ &amp;&amp; up_-&gt;left_ &amp;&amp; up_-&gt;down_) res.set_up(&amp;up_-&gt;div_left(false)); if (down_ &amp;&amp; down_-&gt;left_ &amp;&amp; down_-&gt;down_) res.set_down(&amp;down_-&gt;div_left(false)); } return res; } template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; ScalarCell &amp; MeshCell&lt;T, DerivCell, ScalarCell, VectorCell&gt;::div_right(bool recur) { ScalarCell &amp;res = InstanceAsScalar(6); if (dim_ &gt;= 1) res = comp(0).dx_right(recur); if (dim_ &gt;= 2) res += comp(1).dy_right(recur); return res; } template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; VectorCell &amp; MeshCell&lt;T, DerivCell, ScalarCell, VectorCell&gt;::grad_left(bool recur) { VectorCell &amp;res = InstanceAsVector(0); res.comp(0) = dx_left(recur); res.comp(1) = dy_left(recur); return res; } template&lt;class T, class DerivCell, class ScalarCell, class VectorCell&gt; VectorCell &amp; MeshCell&lt;T, DerivCell, ScalarCell, VectorCell&gt;::grad_right(bool recur) { VectorCell &amp;res = InstanceAsVector(1); res.comp(0) = dx_right(recur); res.comp(1) = dy_right(recur); return res; } template&lt;class T&gt; class VectorCell; template&lt;class T&gt; class ScalarCell : public MeshCell&lt;T, ScalarCell&lt;T&gt;, ScalarCell&lt;T&gt;, VectorCell&lt;T&gt; &gt; { public: explicit ScalarCell(T v = 0) { dim_ = 1; val() = v; } ScalarCell(const ScalarCell &amp;rhs, double mult = 1) : MeshCell(rhs), val_(mult * rhs.val()) { dim_ = 1; } #if defined(USE_STD_MOVE) &amp;&amp; (_MSC_VER &gt; 1500) ScalarCell(ScalarCell &amp;&amp;rhs) : MeshCell(std::move(rhs)), val_(std::move(rhs.val_)) {} #endif virtual ~ScalarCell() {} ScalarCell *This() { return this; } ScalarCell&lt;T&gt; &amp;comp(int i) { DASSERT_LE(i, 1); return *this; } const ScalarCell&lt;T&gt; &amp;comp(int i) const { DASSERT_LE(i, 1); return *this; } const T &amp;val() const { return val_; } T &amp;val() { return val_; } const T &amp;val(int i) const { return comp(i).val(); } T &amp;val(int i) { return comp(i).val(); } operator const T &amp;() const { return val(); } operator T &amp;() { return val(); } ScalarCell &amp;Instance(int i) { std::auto_ptr&lt;ScalarCell&gt; &amp;res = scal_[i]; if (!res.get()) res.reset(new ScalarCell(*this)); return *res; } ScalarCell &amp;InstanceAsScalar(int i) { return Instance(i); } VectorCell&lt;T&gt; &amp;InstanceAsVector(int i) { std::auto_ptr&lt;VectorCell&lt;T&gt; &gt; &amp;res = vec_[i]; if (!res.get()) res.reset(new VectorCell&lt;T&gt;); res-&gt;set_x(x_); res-&gt;set_y(y_); return *res; } ScalarCell &amp;operator = (const T &amp;val) { return MeshCell::operator=(val); } ScalarCell &amp;operator = (const ScalarCell &amp;rhs) { me().val_ = rhs.val_; return MeshCell::operator=(rhs); } #if defined(USE_STD_MOVE) &amp;&amp; (_MSC_VER &gt; 1500) ScalarCell &amp;operator = (ScalarCell &amp;&amp;rhs) { val_ = std::move(rhs.val_); return MeshCell::operator=(std::move(rhs)); } #endif public: T val_; }; //================================================================================== template&lt;class T&gt; class VectorCell : public MeshCell&lt;T, VectorCell&lt;T&gt;, ScalarCell&lt;T&gt;, VectorCell&lt;T&gt; &gt; { public: std::vector&lt;ScalarCell&lt;T&gt; *&gt; comp_;//todo-&gt;auto_ptr VectorCell() { Resize(2); for(int i = 0; i &lt; dim_; i++) { comp_[i] = new ScalarCell&lt;T&gt;; } } explicit VectorCell(const T &amp;val) { Resize(2); for(int i = 0; i &lt; dim_; i++) { comp_[i] = new ScalarCell&lt;T&gt;(val); } } VectorCell(const VectorCell &amp;rhs, double mult = 1) : MeshCell(rhs) { DASSERT_EQ(dim_, 2); Resize(dim_); for(int i = 0; i &lt; dim_; i++) { comp_[i] = new ScalarCell&lt;T&gt;(rhs.comp(i), mult); } } #if defined(USE_STD_MOVE) &amp;&amp; (_MSC_VER &gt; 1500) VectorCell(VectorCell &amp;&amp;rhs) : MeshCell(std::move(rhs)), comp_(std::move(rhs.comp_)) {} #endif virtual ~VectorCell() { Resize(0); } void Resize(int dim) { for(int i = 0, n = comp_.size(); i &lt; n; i++) { delete comp_[i]; } dim_ = dim; if (dim &gt; 0) { comp_.resize(dim_); } } VectorCell *This() { return this; } ScalarCell&lt;T&gt; &amp;comp(int i) { return *comp_[i]; } const ScalarCell&lt;T&gt; &amp;comp(int i) const { return *comp_[i]; } VectorCell &amp;Instance(int i) { std::auto_ptr&lt;VectorCell&gt; &amp;res = vec_[i]; if (!res.get()) res.reset(new VectorCell(*this)); return *res; } ScalarCell&lt;T&gt; &amp;InstanceAsScalar(int i) { std::auto_ptr&lt;ScalarCell&lt;T&gt; &gt; &amp;res = scal_[i]; if (!res.get()) res.reset(new ScalarCell&lt;T&gt;); res-&gt;set_x(x_); res-&gt;set_y(y_); return *res; } VectorCell &amp;InstanceAsVector(int i) { return Instance(i); } ScalarCell&lt;T&gt; &amp;operator()(int at) { return comp(at); } const ScalarCell&lt;T&gt; &amp;operator()(int at) const { return comp(at); } VectorCell &amp;operator = (const T &amp;val) { return MeshCell::operator=(val); } VectorCell &amp;operator = (const VectorCell &amp;rhs) { for (int i = 0; i &lt; dim_; i++) { me().comp(i) = rhs.comp(i); } return MeshCell::operator=(rhs); } #if defined(USE_STD_MOVE) &amp;&amp; (_MSC_VER &gt; 1500) VectorCell &amp;operator = (VectorCell &amp;&amp;rhs) { me().comp_ = std::move(rhs.comp_); return MeshCell::operator=(std::move(rhs)); } #endif const T &amp;max() const { T ret = comp(0).val(); int i_max = 0; for(int i = 1; i &lt; dim_; i++) { if (ret &lt; comp(i).val()) { ret = comp(i).val(); i_max = i; } } return comp(i_max).val(); } const T &amp;min() const { T ret = comp(0).val(); int i_min = 0; for(int i = 1; i &lt; dim_; i++) { if (comp(i).val() &lt; ret) { ret = comp(i).val(); i_min = i; } } return comp(i_min).val(); } }; #define DECLARE_CELL_OP(OPERAND)\ template&lt;class T&gt;\ ScalarCell&lt;T&gt; operator OPERAND (const ScalarCell&lt;T&gt; &amp;c1, const ScalarCell&lt;T&gt; &amp;c2)\ {\ ScalarCell&lt;T&gt; res(c1);\ res OPERAND= c2;\ return res;\ }\ template&lt;class T&gt;\ VectorCell&lt;T&gt; operator OPERAND (const VectorCell&lt;T&gt; &amp;c1, const VectorCell&lt;T&gt; &amp;c2)\ {\ VectorCell&lt;T&gt; res(c1);\ res OPERAND= c2;\ return res;\ }\ template&lt;class T&gt;\ VectorCell&lt;T&gt; operator OPERAND (const VectorCell&lt;T&gt; &amp;c, double val)\ {\ VectorCell&lt;T&gt; res(c);\ res OPERAND= val;\ return res;\ }\ template&lt;class T&gt;\ VectorCell&lt;T&gt; operator OPERAND (double val, const VectorCell&lt;T&gt; &amp;c)\ {\ VectorCell&lt;T&gt; res(c);\ res OPERAND= val;\ return res;\ } DECLARE_CELL_OP(+) DECLARE_CELL_OP(-) DECLARE_CELL_OP(*) DECLARE_CELL_OP( / ) #undef DECLARE_CELL_OP //---------------------------------------------------------------------------------- template&lt;class T&gt; bool operator &lt; (const VectorCell&lt;T&gt; &amp;lhs, const VectorCell&lt;T&gt; &amp;rhs) { for (int i = 0; i &lt; lhs.dim_; i++) if (lhs(i) &gt;= rhs(i)) return 0; return 1; } //---------------------------------------------------------------------------------- template&lt;class T&gt; bool operator &lt;= (const VectorCell&lt;T&gt; &amp;lhs, const VectorCell&lt;T&gt; &amp;rhs) { for (int i = 0; i &lt; lhs.dim_; i++) if (lhs(i) &gt; rhs(i)) return 0; return 1; } //================================================================================== struct Interval2d { public: int lb_x, ub_x; int lb_y, ub_y; Interval2d() : lb_x(0), ub_x(0), lb_y(0), ub_y(0) {} Interval2d(int _lb_x, int _ub_x, int _lb_y, int _ub_y) { Init(_lb_x, _ub_x, _lb_y, _ub_y); } void Init(int _lb_x, int _ub_x, int _lb_y, int _ub_y) { lb_x = _lb_x; ub_x = _ub_x; lb_y = _lb_y; ub_y = _ub_y; } int nx() const { return ub_x - lb_x + 1; } int ny() const { return ub_y - lb_y + 1; } }; //================================================================================== #define FOREACH_INTERVAL(I,i,j)\ for(int i = I.lb_x, j; i &lt;= I.ub_x; i++)\ for(j = I.lb_y; j &lt;= I.ub_y; j++) template&lt;class MeshCell&gt; class MeshCellStack { public: static MeshCellStack &amp;Instance() { static MeshCellStack instance; return instance; } std::list&lt;MeshCell&gt; cells; }; template&lt;class MeshCell&gt; class MeshOperator { public: Interval2d I; MeshOperator(double val = 0) : val_(val) {} virtual bool IsStencil() const { return false; } virtual int CountOfDependentVars() const { return 1; } virtual MeshCell *GetRef(int i, int j) const { return 0; } virtual MeshCell &amp;Eval(int i, int j) const { MeshCell *r = GetRef(i, j); if (r) { return *r; } static MeshCell res;//todo:    OpenMP Eval(&amp;res, i, j); return res; } virtual void Eval(MeshCell *res, int i, int j) const { *res = val_; } MeshCell &amp;max() const { int i_max = I.lb_x; int j_max = I.lb_y; //todo:  val:    MeshCell ret = Eval(i_max, j_max); FOREACH_INTERVAL(I, i, j) { MeshCell &amp;it = Eval(i, j); if (ret &lt; it) { i_max = i; j_max = j; ret = it; } } return Eval(i_max, j_max); } MeshCell &amp;min() const { int i_min = I.lb_x; int j_min = I.lb_y; //todo:  val:    MeshCell ret = Eval(i_min, j_min); FOREACH_INTERVAL(I, i, j) { MeshCell &amp;it = Eval(i, j); if (it &lt; ret) { i_min = i; j_min = j; ret = it; } } return Eval(i_min, j_min); } private: double val_; }; template&lt;class MeshCellIn, class MeshCellOut&gt; class MeshOperatorBind : public MeshOperator&lt;MeshCellOut&gt; { public: typedef MeshCellOut &amp;(*GlobalCellFunc_ref)(MeshCellIn &amp;, bool recur); typedef MeshCellOut (*GlobalCellFunc_copy)(MeshCellIn &amp;, bool recur); MeshOperatorBind(const MeshOperator&lt;MeshCellIn&gt; &amp;rhs, GlobalCellFunc_copy func) : rhs_(rhs), func_copy_(func), func_ref_(0), mult_(1) { I = rhs.I; } MeshOperatorBind(const MeshOperator&lt;MeshCellIn&gt; &amp;rhs, GlobalCellFunc_ref func) : rhs_(rhs), func_copy_(0), func_ref_(func), mult_(1) { I = rhs.I; } bool IsStencil() const { return true; } MeshCellOut *GetRef(int i, int j) const { if (mult_ != 1.) return 0; MeshCellIn *arg = rhs_.GetRef(i, j); return (arg &amp;&amp; func_ref_) ? &amp;func_ref_(*arg, !rhs_.IsStencil()) : 0; } virtual void Eval(MeshCellOut *res, int i, int j) const { MeshCellIn *arg = rhs_.GetRef(i, j); if (arg) { *res = func_copy_ ? func_copy_(*arg, !rhs_.IsStencil()) : func_ref_(*arg, !rhs_.IsStencil()); } else { MeshCellIn &amp;arg = rhs_.Eval(i, j); *res = func_copy_ ? func_copy_(arg, !rhs_.IsStencil()) : func_ref_(arg, !rhs_.IsStencil()); } *res *= mult_; } MeshOperatorBind &amp;operator - () { mult_ = -1; return *this; } private: //MeshProxy     Eval const MeshOperator&lt;MeshCellIn&gt; &amp;rhs_; GlobalCellFunc_copy func_copy_; GlobalCellFunc_ref func_ref_; double mult_; }; //================================================================================== template&lt;class MeshDeriv, class MeshFunc, class MeshFuncProxy, class MeshCellIn, class MeshCellOut&gt; class MeshProxy : public MeshOperator&lt;MeshCellOut&gt; { public: MeshFunc &amp;mesh; MeshProxy(MeshFunc &amp;_mesh, const Interval2d &amp;_I, double mult = 1) : mesh(_mesh), mult_(mult) { I = _I; } virtual ~MeshProxy() {} virtual MeshDeriv *This() = 0; int CountOfDependentVars() const { return 1; } MeshCellOut *GetRef(int i, int j) const { return (1. == mult_) ? &amp;mesh(i, j) : 0; } virtual void Eval(MeshCellOut *res, int i, int j) const { *res = mesh(i, j); if (mult_ != 1.) *res *= mult_; } bool IsEqual(const MeshProxy &amp;rhs) const { if (I.lb_x != rhs.I.lb_x) return 0; if (I.lb_y != rhs.I.lb_y) return 0; FOREACH_INTERVAL(I, i, j) { if (mesh_(i, j) != rhs.mesh_(i, j) || mult_ != rhs.mult_) return 0; } return 1; } MeshDeriv &amp;operator - () { mult_ = -1; return *This(); } MeshDeriv &amp;operator =(const MeshOperator&lt;MeshCellOut&gt; &amp;rhs) { FOREACH_INTERVAL(I, i, j) { MeshCellOut &amp;c = mesh(i, j); if (rhs.CountOfDependentVars() &lt;= 1) rhs.Eval(&amp;c, i, j); else c = rhs.Eval(i, j); } MeshCellStack&lt;MeshCellOut&gt;::Instance().cells.clear(); return *This(); } MeshDeriv &amp;operator +=(const MeshOperator&lt;MeshCellOut&gt; &amp;rhs) { FOREACH_INTERVAL(I, i, j) { MeshCellOut &amp;c = mesh(i, j); c += rhs.Eval(i, j); } return *This(); } MeshDeriv &amp;operator -=(const MeshOperator&lt;MeshCellOut&gt; &amp;rhs) { FOREACH_INTERVAL(I, i, j) { MeshCellOut &amp;c = mesh(i, j); c -= rhs.Eval(i, j); } return *This(); } MeshDeriv &amp;operator *=(const MeshOperator&lt;MeshCellOut&gt; &amp;rhs) { FOREACH_INTERVAL(I, i, j) { MeshCellOut &amp;c = mesh(i, j); c *= rhs.Eval(i, j); } return *This(); } MeshDeriv &amp;operator /=(const MeshOperator&lt;MeshCellOut&gt; &amp;rhs) { FOREACH_INTERVAL(I, i, j) { MeshCellOut &amp;c = mesh(i, j); c /= rhs.Eval(i, j); } return *This(); } #define DECLARE_MESH_OP(OPERAND)\ MeshDeriv &amp;operator OPERAND(double val) {\ FOREACH_INTERVAL(I, i, j) {\ mesh(i, j) OPERAND val;\ }\ return *This();\ } DECLARE_MESH_OP( = ) DECLARE_MESH_OP( += ) DECLARE_MESH_OP( -= ) DECLARE_MESH_OP( *= ) DECLARE_MESH_OP( /= ) #undef DECLARE_MESH_OP void ToVector(dblArray1d *v, int lb = 0) {//todo: template T const int nx = I.nx(); const int n = lb + nx * I.ny(); if (v-&gt;size() != n) v-&gt;resize(n); int at = lb; FOREACH_INTERVAL(I, i, j) { (*v)[at++] = mesh(i, j); } } void FromVector(const dblArray1d &amp;v, int lb = 0) {//todo: template T if (I.nx() * I.ny() != v.size() - lb) ;//THROW("Size of mesh must and (v.size() - lb) must be equals")//todo int at = lb; FOREACH_INTERVAL(I, i, j) { mesh(i, j) = v[at++]; } } private: double mult_; }; //================================================================================== template&lt;class MeshDeriv, class MeshCell, class MeshProxy, class MeshScalarOperator, class MeshVectorOperator&gt; class MeshFunc : public array2d&lt;MeshCell&gt; { public: double a_; double b_; double hx_; double hy_; MeshFunc(double a = 0, double b = 0, int nx = 0, int ny = 0) { if (nx &gt; 0 &amp;&amp; ny &gt; 0) Resize(a, b, nx, ny); } virtual ~MeshFunc() {} void Resize(double a, double b, int nx, int ny); double a() const { return a_; } double b() const { return b_; } int nx() const { return nx_ - 2; } int ny() const { return ny_ - 2; } double hx() const { return hx_; } double hy() const { return hy_; } double x(int i, int j) { return at(i, j).x(); } double y(int i, int j) { return at(i, j).y(); } Interval2d I_all() const { return Interval2d(0, nx_ - 1, 0, ny_ - 1); } Interval2d I_int() const { return Interval2d(1, nx_ - 2, 1, ny_ - 2); } virtual MeshDeriv *This() = 0; operator MeshProxy() { return without_bnd(); } MeshProxy without_bnd() { return MeshProxy(*This(), I_int()); } MeshProxy all() { return MeshProxy(*This(), I_all()); } MeshDeriv &amp;operator =(MeshDeriv &amp;rhs) { all() = rhs.all(); return *This(); } MeshDeriv &amp;operator +=(MeshDeriv &amp;rhs) { all() += rhs.all(); return *This(); } MeshDeriv &amp;operator -=(MeshDeriv &amp;rhs) { all() -= rhs.all(); return *This(); } MeshDeriv &amp;operator *=(MeshDeriv &amp;rhs) { all() *= rhs.all(); return *This(); } MeshDeriv &amp;operator /=(MeshDeriv &amp;rhs) { all() /= rhs.all(); return *This(); } MeshProxy dx_left(const Interval2d &amp;I) { return ::dx_left(MeshProxy(*this, I)); } MeshProxy dx_right(const Interval2d &amp;I) { return ::dx_right(MeshProxy(*this, I)); } MeshProxy laplacian(const Interval2d &amp;I) { return ::laplacian(MeshProxy(*this, I)); } MeshScalarOperator &amp;div_left(const Interval2d &amp;I) { return ::div_left(MeshProxy(*this, I)); } MeshScalarOperator &amp;div_right(const Interval2d &amp;I) { return ::div_right(MeshProxy(*this, I)); } MeshVectorOperator &amp;grad_left(const Interval2d &amp;I) { return ::grad_left(MeshProxy(*this, I)); } MeshVectorOperator &amp;grad_right(const Interval2d &amp;I) { return ::grad_right(MeshProxy(*this, I)); } }; template&lt;class MeshDeriv, class MeshCell, class MeshProxy, class MeshScalarOperator, class MeshVectorOperator&gt; void MeshFunc&lt;MeshDeriv, MeshCell, MeshProxy, MeshScalarOperator, MeshVectorOperator&gt;::Resize(double a, double b, int nx, int ny) { a_ = a; b_ = b; array2d&lt;MeshCell&gt;::Resize(nx + 2, ny + 2); hx_ = (b_ - a_) / (nx + 1); hy_ = (b_ - a_) / (ny + 1); for(int i = 0, j; i &lt;= nx + 1; i++) { for(j = 0; j &lt;= ny + 1; j++) { MeshCell &amp;cell = at(i, j); cell.set_x(a_ + i * hx_); cell.set_y(a_ + j * hy_); if (i &gt; 0) cell.set_left(&amp;at(i - 1, j)); else cell.set_left(0);//,    Resize   ,   if (i &lt;= nx) cell.set_right(&amp;at(i + 1, j)); else cell.set_right(0); if (j &gt; 0) cell.set_down(&amp;at(i, j - 1)); else cell.set_down(0); if (j &lt;= ny) cell.set_up(&amp;at(i, j + 1)); else cell.set_up(0); } } } //================================================================================== template&lt;class T&gt; class ScalarMeshFunc; template&lt;class T&gt; class ScalarMeshProxy : public MeshProxy&lt;ScalarMeshProxy&lt;T&gt;, ScalarMeshFunc&lt;T&gt;, ScalarMeshProxy&lt;T&gt;, ScalarCell&lt;T&gt;, ScalarCell&lt;T&gt; &gt; { public: ScalarMeshProxy(ScalarMeshFunc&lt;T&gt; &amp;mesh, const Interval2d &amp;_I) : MeshProxy(mesh, _I) {} ScalarMeshProxy *This() { return this; } ScalarMeshProxy &amp;operator=(const ScalarMeshProxy &amp;rhs) { DASSERT_GE(I.lb_x, rhs.I.lb_x); DASSERT_GE(I.lb_y, rhs.I.lb_y); DASSERT_LE(I.ub_x, rhs.I.ub_x); DASSERT_LE(I.ub_y, rhs.I.ub_y); return MeshProxy::operator =(rhs); } ScalarMeshProxy &amp;operator=(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;rhs) { return MeshProxy::operator =(rhs); } ScalarMeshProxy &amp;operator=(const T &amp;val) { return MeshProxy::operator =(val); } }; template&lt;class T&gt; class Scalar2VectorMeshProxy : public MeshProxy&lt;Scalar2VectorMeshProxy&lt;T&gt;, ScalarMeshFunc&lt;T&gt;, ScalarMeshProxy&lt;T&gt;, ScalarCell&lt;T&gt;, VectorCell&lt;T&gt; &gt; { public: Scalar2VectorMeshProxy *This() { return this; } Scalar2VectorMeshProxy &amp;operator=(const Scalar2VectorMeshProxy &amp;rhs) { return MeshProxy::operator =(rhs); } }; //================================================================================== template&lt;class T&gt; class VectorMeshFunc; template&lt;class T&gt; class ScalarMeshFunc : public MeshFunc&lt;ScalarMeshFunc&lt;T&gt;, ScalarCell&lt;T&gt;, ScalarMeshProxy&lt;T&gt;, ScalarMeshFunc&lt;T&gt;, VectorMeshFunc&lt;T&gt; &gt; { public: ScalarMeshFunc(double a = 0, double b = 0, int nx = 0, int ny = 0) : MeshFunc(a, b, nx, ny) {} ScalarMeshFunc *This() { return this; } ScalarCell&lt;T&gt; &amp;operator()(int i, int j) { return at(i, j); } const ScalarCell&lt;T&gt; &amp;operator()(int i, int j) const { return at(i, j); } ScalarMeshProxy&lt;T&gt; operator()(const Interval2d &amp;I) { return ScalarMeshProxy&lt;T&gt;(*this, I); } }; template&lt;class T&gt; std::ostream &amp;operator &lt;&lt; (std::ostream &amp;os, const MeshOperator&lt;T&gt; &amp;mesh) { const Interval2d &amp;I = mesh.I; StreamTable st; st.SetCols(I.ub_y - I.lb_y + 1, 10); FOREACH_INTERVAL(I, i, j) { st &lt;&lt; mesh.Eval(i, j); } //os &lt;&lt; st.os(); return os; } //================================================================================== template&lt;class T&gt; class VectorMeshProxy : public MeshProxy&lt;VectorMeshProxy&lt;T&gt;, VectorMeshFunc&lt;T&gt;, VectorMeshProxy&lt;T&gt;, VectorCell&lt;T&gt;, VectorCell&lt;T&gt; &gt; { public: VectorMeshProxy(VectorMeshFunc&lt;T&gt; &amp;mesh, const Interval2d &amp;_I) : MeshProxy(mesh, _I) {} VectorMeshProxy *This() { return this; } VectorMeshProxy &amp;operator=(const VectorMeshProxy &amp;rhs) { DASSERT_GE(I.lb_x, rhs.I.lb_x); DASSERT_GE(I.lb_y, rhs.I.lb_y); DASSERT_LE(I.ub_x, rhs.I.ub_x); DASSERT_LE(I.ub_y, rhs.I.ub_y); return MeshProxy::operator =(rhs); } VectorMeshProxy &amp;operator=(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;rhs) { return MeshProxy::operator =(rhs); } VectorMeshProxy &amp;operator=(const T &amp;val) { return MeshProxy::operator =(val); } }; template&lt;class T&gt; class Vector2ScalarMeshProxy : public MeshProxy&lt;Vector2ScalarMeshProxy&lt;T&gt;, VectorMeshFunc&lt;T&gt;, VectorMeshProxy&lt;T&gt;, VectorCell&lt;T&gt;, ScalarCell&lt;T&gt; &gt; { public: Vector2ScalarMeshProxy *This() { return this; } Vector2ScalarMeshProxy &amp;operator=(const Vector2ScalarMeshProxy &amp;rhs) { return MeshProxy::operator =(rhs); } }; /*template&lt;class T&gt; class Vector2VectorMeshProxy : public MeshProxy&lt;Vector2VectorMeshProxy&lt;T&gt;, VectorMeshFunc&lt;T&gt;, VectorMeshProxy&lt;T&gt;, VectorCell&lt;T&gt;, VectorCell&lt;VectorCell&lt;T&gt; &gt; &gt; { public: Vector2VectorMeshProxy *This() { return this; } Vector2VectorMeshProxy &amp;operator=(const Vector2VectorMeshProxy &amp;rhs) { return MeshProxy::operator =(rhs); } };*/ template&lt;class T&gt; class VectorMeshFunc : public MeshFunc&lt;VectorMeshFunc&lt;T&gt;, VectorCell&lt;T&gt;, VectorMeshProxy&lt;T&gt;, ScalarMeshFunc&lt;T&gt;, VectorMeshFunc&lt;T&gt; &gt; { public: VectorMeshFunc(double a = 0, double b = 0, int nx = 0, int ny = 0) : MeshFunc(a, b, nx, ny) {} VectorMeshFunc *This() { return this; } VectorCell&lt;T&gt; &amp;operator()(int i, int j) { return at(i, j); } const VectorCell&lt;T&gt; &amp;operator()(int i, int j) const { return at(i, j); } VectorMeshProxy&lt;T&gt; operator()(const Interval2d &amp;I) { return VectorMeshProxy&lt;T&gt;(*this, I); } }; //================================================================================== #define DECLARE_MESH_OP(CLASS,OPERAND,OPFUNC)\ template&lt;class MeshCell&gt;\ class CLASS : public MeshOperator&lt;MeshCell&gt; {\ public:\ MeshCell &amp;res_;\ CLASS(const MeshOperator &amp;op1, const MeshOperator &amp;op2, MeshCell &amp;res) : op1_(op1), op2_(op2), res_(res) {\ I = op1.I;/*todo*/\ }\ \ bool IsStencil() const {\ return op1_.IsStencil() || op2_.IsStencil();\ }\ int CountOfDependentVars() const {\ return op1_.CountOfDependentVars() + op2_.CountOfDependentVars() + 1;\ }\ virtual void Eval(MeshCell *res, int i, int j) const {\ *res = op1_.Eval(i, j);\ *res OPERAND= op2_.Eval(i, j);\ }\ virtual MeshCell &amp;Eval(int i, int j) const {\ res_ = op1_.Eval(i, j);\ res_ OPERAND= op2_.Eval(i, j);\ return res_;\ }\ private:\ const MeshOperator &amp;op1_;\ const MeshOperator &amp;op2_;\ };\ inline CLASS&lt;ScalarCell&lt;double&gt; &gt; operator OPERAND (const MeshOperator&lt;ScalarCell&lt;double&gt; &gt; &amp;op1, const MeshOperator&lt;ScalarCell&lt;double&gt; &gt; &amp;op2)\ {\ std::list&lt;ScalarCell&lt;double&gt; &gt; &amp;stack = MeshCellStack&lt;ScalarCell&lt;double&gt; &gt;::Instance().cells;\ stack.push_back(ScalarCell&lt;double&gt;());\ return CLASS&lt;ScalarCell&lt;double&gt; &gt;(op1, op2, stack.back());\ }\ inline CLASS&lt;VectorCell&lt;double&gt; &gt; operator OPERAND (const MeshOperator&lt;VectorCell&lt;double&gt; &gt; &amp;op1, const MeshOperator&lt;VectorCell&lt;double&gt; &gt; &amp;op2)\ {\ std::list&lt;VectorCell&lt;double&gt; &gt; &amp;stack = MeshCellStack&lt;VectorCell&lt;double&gt; &gt;::Instance().cells;\ stack.push_back(VectorCell&lt;double&gt;());\ return CLASS&lt;VectorCell&lt;double&gt; &gt;(op1, op2, stack.back());\ } DECLARE_MESH_OP(OperatorPlus, +, PlusEq()) DECLARE_MESH_OP(OperatorMinus, -, MinusEq()) DECLARE_MESH_OP(OperatorMult, *, MultEq()) DECLARE_MESH_OP(OperatorDivide, / , DivideEq()) #undef DECLARE_MESH_OP //---------------------------------------------------------------------------------- template&lt;class T&gt; ScalarCell&lt;T&gt; fabs(ScalarCell&lt;T&gt; &amp;u, bool recur) { ScalarCell&lt;T&gt; res(u); res.val() = ::fabs(res.val()); return res; } template&lt;class T&gt; VectorCell&lt;T&gt; fabs(VectorCell&lt;T&gt; &amp;u, bool recur) { VectorCell&lt;T&gt; res(u); for(int i = 0; i &lt; res.dim_; i++) { res.comp(i).val() = fabs(res.comp(i).val()); } return res; } #define SCALAR_OPERATOR(T) MeshOperatorBind&lt;ScalarCell&lt;T&gt;, ScalarCell&lt;T&gt; &gt; #define VECTOR_OPERATOR(T) MeshOperatorBind&lt;VectorCell&lt;T&gt;, VectorCell&lt;T&gt; &gt; #define SCALAR_2_VECTOR_OPERATOR(T) MeshOperatorBind&lt;ScalarCell&lt;T&gt;, VectorCell&lt;T&gt; &gt; #define VECTOR_2_SCALAR_OPERATOR(T) MeshOperatorBind&lt;VectorCell&lt;T&gt;, ScalarCell&lt;T&gt; &gt; template&lt;class T&gt; SCALAR_OPERATOR(T) fabs(MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;f) { return SCALAR_OPERATOR(T)(f, &amp;::fabs); } template&lt;class T&gt; VECTOR_OPERATOR(T) fabs(MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;f) { return VECTOR_OPERATOR(T)(f, &amp;::fabs); } //---------------------------------------------------------------------------------- template&lt;class T&gt; ScalarCell&lt;T&gt; &amp;dx_left(ScalarCell&lt;T&gt; &amp;u, bool recur = true) { return u.dx_left(recur); } template&lt;class T&gt; VectorCell&lt;T&gt; &amp;dx_left(VectorCell&lt;T&gt; &amp;u, bool recur = true) { return u.dx_left(recur); } template&lt;class T&gt; SCALAR_OPERATOR(T) dx_left(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;f) { return SCALAR_OPERATOR(T)(f, &amp;::dx_left); } template&lt;class T&gt; VECTOR_OPERATOR(T) dx_left(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;f) { return VECTOR_OPERATOR(T)(f, &amp;::dx_left); } //---------------------------------------------------------------------------------- template&lt;class T&gt; ScalarCell&lt;T&gt; &amp;dx_right(ScalarCell&lt;T&gt; &amp;u, bool recur = true) { return u.dx_right(recur); } template&lt;class T&gt; VectorCell&lt;T&gt; &amp;dx_right(VectorCell&lt;T&gt; &amp;u, bool recur = true) { return u.dx_right(recur); } template&lt;class T&gt; SCALAR_OPERATOR(T) dx_right(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;f) { return SCALAR_OPERATOR(T)(f, &amp;::dx_right); } template&lt;class T&gt; VECTOR_OPERATOR(T) dx_right(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;f) { return VECTOR_OPERATOR(T)(f, &amp;::dx_right); } //---------------------------------------------------------------------------------- template&lt;class T&gt; ScalarCell&lt;T&gt; &amp;dy_left(ScalarCell&lt;T&gt; &amp;u, bool recur = true) { return u.dy_left(recur); } template&lt;class T&gt; VectorCell&lt;T&gt; &amp;dy_left(VectorCell&lt;T&gt; &amp;u, bool recur = true) { return u.dy_left(recur); } template&lt;class T&gt; SCALAR_OPERATOR(T) dy_left(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;f) { return SCALAR_OPERATOR(T)(f, &amp;::dy_left); } template&lt;class T&gt; VECTOR_OPERATOR(T) dy_left(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;f) { return VECTOR_OPERATOR(T)(f, &amp;::dy_left); } //---------------------------------------------------------------------------------- template&lt;class T&gt; ScalarCell&lt;T&gt; &amp;dy_right(ScalarCell&lt;T&gt; &amp;u, bool recur = true) { return u.dy_right(recur); } template&lt;class T&gt; VectorCell&lt;T&gt; &amp;dy_right(VectorCell&lt;T&gt; &amp;u, bool recur = true) { return u.dy_right(recur); } template&lt;class T&gt; SCALAR_OPERATOR(T) dy_right(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;f) { return SCALAR_OPERATOR(T)(f, &amp;::dy_right); } template&lt;class T&gt; VECTOR_OPERATOR(T) dy_right(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;f) { return VECTOR_OPERATOR(T)(f, &amp;::dy_right); } //---------------------------------------------------------------------------------- template&lt;class T&gt; ScalarCell&lt;T&gt; &amp;laplacian(ScalarCell&lt;T&gt; &amp;u, bool recur = true) { return u.laplacian(recur); } template&lt;class T&gt; VectorCell&lt;T&gt; &amp;laplacian(VectorCell&lt;T&gt; &amp;u, bool recur = true) { return u.laplacian(recur); } template&lt;class T&gt; SCALAR_OPERATOR(T) laplacian(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;f) { return SCALAR_OPERATOR(T)(f, &amp;::laplacian); } template&lt;class T&gt; VECTOR_OPERATOR(T) laplacian(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;f) { return VECTOR_OPERATOR(T)(f, &amp;::laplacian); } //---------------------------------------------------------------------------------- template&lt;class T&gt; ScalarCell&lt;T&gt; &amp;div_left(VectorCell&lt;T&gt; &amp;v, bool recur = true) { return v.div_left(recur); } template&lt;class T&gt; VECTOR_2_SCALAR_OPERATOR(T) div_left(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;f) { return VECTOR_2_SCALAR_OPERATOR(T)(f, &amp;::div_left); } //---------------------------------------------------------------------------------- template&lt;class T&gt; ScalarCell&lt;T&gt; &amp;div_right(VectorCell&lt;T&gt; &amp;v, bool recur = true) { return v.div_right(recur); } template&lt;class T&gt; VECTOR_2_SCALAR_OPERATOR(T) div_right(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;f) { return VECTOR_2_SCALAR_OPERATOR(T)(f, &amp;::div_right); } //---------------------------------------------------------------------------------- template&lt;class T&gt; VectorCell&lt;T&gt; &amp;grad_left(ScalarCell&lt;T&gt; &amp;u, bool recur = true) { return u.grad_left(recur); } template&lt;class T&gt; SCALAR_2_VECTOR_OPERATOR(T) grad_left(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;f) { return SCALAR_2_VECTOR_OPERATOR(T)(f, &amp;::grad_left); } /*template&lt;class T&gt; Vector2VectorMeshProxy&lt;T&gt; grad_left(VECTOR_OPERATOR(T) &amp;f) { return Vector2VectorMeshProxy&lt;T&gt;(f, &amp;::grad_left); }*/ //---------------------------------------------------------------------------------- template&lt;class T&gt; VectorCell&lt;T&gt; &amp;grad_right(ScalarCell&lt;T&gt; &amp;u, bool recur = true) { return u.grad_right(recur); } template&lt;class T&gt; SCALAR_2_VECTOR_OPERATOR(T) grad_right(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;f) { return SCALAR_2_VECTOR_OPERATOR(T)(f, &amp;::grad_right); } /* template&lt;class T&gt; Vector2VectorMeshProxy&lt;T&gt; grad_right(VECTOR_OPERATOR(T) &amp;f) { return Vector2VectorMeshProxy&lt;T&gt;(f, &amp;::grad_right); }*/ //================================================================================== template&lt;class T&gt; const T &amp;max(const VectorCell&lt;T&gt; &amp;c) { return c.max(); } template&lt;class T&gt; const T &amp;min(const VectorCell&lt;T&gt; &amp;c) { return c.min(); } template&lt;class T&gt; T &amp;max(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;m) { return m.max(); } template&lt;class T&gt; T &amp;min(const MeshOperator&lt;ScalarCell&lt;T&gt; &gt; &amp;m) { return m.min(); } template&lt;class T&gt; VectorCell&lt;T&gt; &amp;max(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;m) { return m.max(); } template&lt;class T&gt; VectorCell&lt;T&gt; &amp;min(const MeshOperator&lt;VectorCell&lt;T&gt; &gt; &amp;m) { return m.min(); }</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"> Arrays.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//() 2016-2019  , SharipovTR@gmail.com // As Is #ifndef __ARRAYS_H #define __ARRAYS_H #pragma once #include "NumericAssert.h" #include &lt;vector&gt; /** * Dynamic 0-based 1D array (storage is std::vector) */ template&lt;class T&gt; class array1d : public std::vector&lt;T&gt; { public: typedef std::vector&lt;T&gt; baseClass; typedef std::size_t index; array1d(index n = 0) : baseClass(n) {} const T &amp;operator()(index i) const { return baseClass::operator[](i); } T &amp;operator()(index i) { return baseClass::operator[](i); } void Resize(index /*lb*/, index ub) { baseClass::resize(ub + 1); } }; #define RS2D(i,j,ny) ((i) * (ny) + (j)) /** * Dynamic 0-based row-oriented 2D array (storage is only one std::vector) */ template&lt;class T&gt; class array2d : public std::vector&lt;T&gt; { public: typedef std::vector&lt;T&gt; baseClass; typedef std::size_t index; array2d(index nx = 0, index ny = 0) { Resize(nx, ny); } array2d(int n, const T v[]) { Resize(n, n); std::copy(v, v + n * n, baseClass::begin()); } array2d(const array2d&lt;T&gt; &amp;rhs) { Resize(rhs.nx_, rhs.ny_); std::copy(rhs.begin(), rhs.end(), begin()); } void Resize(index nx, index ny) { if (nx &gt; 0 &amp;&amp; ny &gt; 0) baseClass::resize(nx * ny); nx_ = nx; ny_ = ny; } void resize(int nx, int ny, bool reserved) { Resize(nx, ny); } index Size() const { DASSERT_EQ(nx_, ny_); return nx_; } void Clear() { baseClass::clear(); nx_ = 0; ny_ = 0; } const T &amp;at(index i, index j) const { DASSERT(CHR(i, 0, nx_)); DASSERT(CHR(j, 0, ny_)); return baseClass::operator[](RS2D(i, j, ny_)); } virtual T &amp;at(index i, index j) { return baseClass::operator[](RS2D(i, j, ny_)); } const T &amp;operator()(index i, index j) const { return at(i, j); } T &amp;operator()(index i, index j) { return at(i, j); } void FillRow(index irow, T val) { DASSERT(CHR(irow, 0, nx_)); typename baseClass::iterator beg = baseClass::begin() + RS2D(irow, 0, ny_); std::fill(beg, beg + ny_, val); } std::vector&lt;T&gt; &amp;operator =(const std::vector&lt;T&gt; &amp;rhs) { std::copy(rhs.begin(), rhs.end(), baseClass::begin()); return *this; } public: index nx_; index ny_; };</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title"> NumericAssert.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//() 2016-2019  , SharipovTR@gmail.com // As Is #pragma once #include "assert.h" #include &lt;sstream&gt; #include &lt;iostream&gt; #define TO_STR(x) #x #define ASSERT_OP(opname,op,val1,val2)\ if (!(val1 op val2)) do {\ std::stringstream ss;\ ss &lt;&lt; TO_STR(ASSERT##opname) &lt;&lt; " failed:" &lt;&lt; "\n";\ ss &lt;&lt; #val1 &lt;&lt; ": " &lt;&lt; val1 &lt;&lt; "\n";\ ss &lt;&lt; #val2 &lt;&lt; ": " &lt;&lt; val2 &lt;&lt; "\n";\ ss &lt;&lt; TO_STR(val1 - val2) &lt;&lt; ": " &lt;&lt; val1 - (val2);\ std::string s(ss.str());\ std::cout &lt;&lt; s.c_str();\ } while(0) #define ASSERT_EQ(val1, val2) ASSERT_OP(_EQ, ==, val1, val2) #define ASSERT_NE(val1, val2) ASSERT_OP(_NE, !=, val1, val2) #define ASSERT_LE(val1, val2) ASSERT_OP(_LE, &lt;=, val1, val2) #define ASSERT_LT(val1, val2) ASSERT_OP(_LT, &lt; , val1, val2) #define ASSERT_GE(val1, val2) ASSERT_OP(_GE, &gt;=, val1, val2) #define ASSERT_GT(val1, val2) ASSERT_OP(_GT, &gt; , val1, val2) #define ASSERT_NEAR(val1,val2,margin)\ do {\ ASSERT_LE((val1), (val2) + margin);\ ASSERT_GE((val1), (val2) - margin);\ } while(0) #define ASSERT_DBL_EQ(val1,val2)\ ASSERT_NEAR(val1, val2, 1.e-12); #ifdef _DEBUG #define DASSERT assert #define DASSERT_EQ(val1, val2) ASSERT_EQ(val1, val2) #define DASSERT_NE(val1, val2) ASSERT_NE(val1, val2) #define DASSERT_LE(val1, val2) ASSERT_LE(val1, val2) #define DASSERT_LT(val1, val2) ASSERT_LT(val1, val2) #define DASSERT_GE(val1, val2) ASSERT_GE(val1, val2) #define DASSERT_GT(val1, val2) ASSERT_GT(val1, val2) #define DASSERT_NEAR(val1,val2,margin) ASSERT_NEAR(val1,val2,margin) #define DASSERT_NEAR_SMALL(val1,val2) ASSERT_NEAR_SMALL(val1,val2) #define DASSERT_DBL_EQ(val1,val2) ASSERT_DBL_EQ(val1,val2) #else #define DASSERT #define DASSERT_EQ(val1, val2) #define DASSERT_NE(val1, val2) #define DASSERT_LE(val1, val2) #define DASSERT_LT(val1, val2) #define DASSERT_GE(val1, val2) #define DASSERT_GT(val1, val2) #define DASSERT_NEAR(val1,val2,margin) #define DASSERT_NEAR_SMALL(val1,val2) #define DASSERT_DBL_EQ(val1,val2) #endif</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/442316/">https://habr.com/ru/post/442316/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442298/index.html">Gatsby.js in detail</a></li>
<li><a href="../442300/index.html">I look and listen where I want. We integrate Chromecast into Android application</a></li>
<li><a href="../442302/index.html">The first launch of the spacecraft Dragon v2</a></li>
<li><a href="../442304/index.html">Folding smartphones: what about applications?</a></li>
<li><a href="../442310/index.html">Sonoff Basic firmware via Raspberry Pi</a></li>
<li><a href="../442318/index.html">How to bring about change with retrospective</a></li>
<li><a href="../442320/index.html">Laptop Compaq LTE 5000, part two - about the shortcomings and their treatment</a></li>
<li><a href="../442328/index.html">Typical programmer errors when applying for a job</a></li>
<li><a href="../442330/index.html">Some tasks of school mathematics. Part II</a></li>
<li><a href="../442332/index.html">Anticipation in developing a dialogue with a chat bot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>