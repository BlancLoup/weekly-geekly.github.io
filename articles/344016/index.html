<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Multi-threaded programming in Android using RxJava 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are new to RxJava or tried to figure it out, but didn‚Äôt get it done, you‚Äôll find something new for yourself below. 


 The original article was...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Multi-threaded programming in Android using RxJava 2</h1><div class="post__text post__text-html js-mediator-article">  If you are new to RxJava or tried to figure it out, but didn‚Äôt get it done, you‚Äôll find something new for yourself below. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c4/44d/2ac/0c444d2ac478bfde7f57a8ca91eda1cf.png" alt="image"><br>  <i>The original article was written on November 29, 2017. Translation is free.</i> <br><a name="habracut"></a><br>  At GO-JEK, we need to perform a large number of asynchronous operations in applications and we cannot afford to compromise at the expense of the speed and smoothness of the user interface. <br><br>  Writing complex multi-threaded Android applications can be quite time-consuming process, which from time to time will overwhelm you greatly due to the need to take care of a large number of things connected with each other.  This and many other reasons convinced us to use RxJava in Android-developed applications. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article we will talk about how we used real multi-threading capabilities in RxJava in order to make the application development process as simple, easy and fun as possible.  In all the code examples below, RxJava 2 will be used, but the concepts described can be applied in other <a href="http://reactivex.io/">reactive extensions</a> . <br><br><h3>  Why reactive programming? </h3><br>  Each article about reactive programming begins with such a mandatory block and we will not break this tradition.  There are several advantages of using a reactive approach to building Android applications, let's pay attention to those that you <i>really</i> need. <br><br><h4>  No more callbacks </h4><br>  If you have been developing for Android for a long time, then you must have noticed how quickly things get too complicated and out of control using nested callbacks. <br><br>  This happens when you perform several asynchronous operations sequentially and you want further actions to depend on the result of previous operations.  Almost immediately, the code becomes too overloaded and difficult to maintain. <br><br><h4>  Simple error control </h4><br>  In the imperative world, in a situation where many complex asynchronous operations are performed, errors can occur in a large number of places.  And in every place you have to handle these errors, as a result, a lot of duplicate template code appears, the methods become cumbersome. <br><br><h4>  Very simple use of multithreading. </h4><br>  We all know (and secretly recognize) how difficult it can sometimes be to work with multithreading in Java.  For example, executing part of the code in a background thread and returning the result back to the main thread.  It only sounds simple, but in practice there are many pitfalls that need to be circumvented. <br><br>  <b>RxJava makes it incredibly easy to perform several complex operations in any thread of</b> your choice, taking care of correct synchronization and allowing you to easily switch between threads. <br><br>  The benefits of RxJava are endless.  We can talk about it with hours and hellishly tire you, but instead let's dig deeper and start exploring the real work with multithreading in RxJava. <br><br><h3>  RxJava is NOT multi-threaded by default. </h3><br>  <i><b>Yes, you read it right.</b></i>  RxJava is not multi-threaded by default anyway.  The definition given for RxJava on the official website looks something like this: <br>  <i>"A library for creating asynchronous and event-based programs using sequences <i>(observable sequences)</i> for a Java virtual machine."</i> <br><br>  After seeing the word "asynchronous", many people mistakenly believe that RxJava is multi-threaded by default.  Yes, RxJava supports multithreading, offers many powerful features for easy work with asynchronous operations, but this does not mean that the default behavior of RxJava is multi-threaded. <br><br>  If you have already worked a little with RxJava, then you know its basic constructs: <br><br><ul><li>  Observed source <b>(source Observable)</b> , further </li><li>  several operators <b>(Operators)</b> , then </li><li>  target subscriber <b>(Subscriber)</b> </li></ul><br><pre><code class="java hljs">Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>) .doOnNext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Consumer&lt;Integer&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer integer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ println(<span class="hljs-string"><span class="hljs-string">"Emitting item on: "</span></span> + currentThread().getName()); } }) .map(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Function&lt;Integer, Integer&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Integer integer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ println(<span class="hljs-string"><span class="hljs-string">"Processing item on: "</span></span> + currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> integer * <span class="hljs-number"><span class="hljs-number">2</span></span>; } }) .subscribeWith(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DisposableObserver&lt;Integer&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Integer integer)</span></span></span><span class="hljs-function"> </span></span>{ println(<span class="hljs-string"><span class="hljs-string">"Consuming item on: "</span></span> + currentThread().getName()); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Throwable e)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } });</code> </pre> <br>  If you run this sample code, you will clearly see that all actions are performed in the main application thread (follow the names of the streams in the log in the console).  This example shows that <b>the default behavior of RxJava is blocking.</b>  Everything is executed in the same thread in which the code is called. <br><br>  <b>Bonus:</b> I wonder what does <code>doOnNext()</code> do?  This is nothing more than a <i>side-effect</i> operator.  It helps <i>infuse</i> objects into a chain of <code>observable</code> objects and perform <i>impure</i> operations.  For example, implement additional code in the call chain for debugging.  Read more <a href="https://www.grokkingandroid.com/rxjavas-side-effect-methods/">here</a> . <br><br><h3>  Simple example </h3><br>  In order to start working with multithreading using RxJava, you need to become familiar with base classes and methods, such as <b>Schedulers</b> , <b>observeOn / subscribeOn</b> . <br><br>  Let's look at one of the simplest examples.  Suppose we want to get a list of <code>Book</code> objects by a network request and show it in the main application flow.  A pretty general and clear example to begin with. <br><br><pre> <code class="java hljs">getBooks().subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribeWith(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DisposableObserver&lt;Book&gt;() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull Book book)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       Book  } @Override public void onError(@NonNull Throwable e) { //    } @Override public void onComplete() { //   Book . ! } });</span></span></code> </pre><br><br>  Here we see the <code>getBooks()</code> method, which makes a network call and compiles a list of books for us.  The network call takes time (a few milliseconds or seconds), so we use <code>subscribeOn()</code> and specify the <code>Schedulers.io()</code> scheduler to perform the operation in the I / O stream. <br><br>  We also use the <code>observeOn()</code> operator together with the <code>AndroidSchedulers.mainThread()</code> scheduler to process the result in the main thread and show the list of books in the application's user interface. <br><br>  Do not worry, soon we will move on to more advanced things.  This example was intended only to recall basic concepts, before diving deeper. <br><br><h3>  Make friends with schedulers <i>(Schedulers)</i> </h3><br>  RxJava provides a powerful set of schedulers.  You cannot directly access or control streams.  If you need to work with threads, you need to use the built-in schedulers. <br><br>  You can think of schedulers as <b>threads or thread pools (a collection of threads) for performing various kinds of tasks</b> . <br><br>  Simply put, if you need to perform a task in a separate thread, you need to use the correct scheduler, which will take the stream from its pool of available threads and perform the task in it. <br><br>  There are several types of schedulers available in RxJava.  The hardest part is choosing the right planner for your task.  A task will never be executed optimally unless you select the correct scheduler.  Let's break down every scheduler. <br><br><h4>  Schedulers.io () </h4><br>  This scheduler is <b>based on an unrestricted pool of threads and is used for intensive work with I / O without using CPU</b> , for example, access to the file system, making network calls, access to the database, and so on.  The number of threads in this scheduler is unlimited and can grow as needed. <br><br><h4>  Schedulers.computation () </h4><br>  This scheduler is <b>used to do work that loads the CPU heavily</b> , such as processing large amounts of data, images, and so on.  The scheduler is <b>based on a limited pool of threads with a size of the number of available processors.</b> <br>  Since this scheduler is only suitable for intensive work with the CPU - the number of threads is limited.  This is done so that the threads do not compete for CPU time and do not stand idle. <br><br><h4>  Schedulers.newThread () </h4><br>  This scheduler <b>creates a completely new thread with each call.</b>  In this case, the use of a pool of threads will not bring any benefits.  Threads are very expensive to create and destroy.  You must be careful not to abuse the excessive creation of threads, as this can lead to system slowdown and memory overflow.  <b>A new stream will be created to process each item received from the observable source</b> . <br>  Ideally, you should use this scheduler quite rarely, mainly to bring the long-running parts of the program to a separate stream. <br><br><h4>  Schedulers.single () </h4><br>  This scheduler is <b>based on a single thread that is used to execute tasks consistently.</b>  It can be very useful when you have a set of background tasks in different places in your application, but you cannot allow more than one of these tasks to be executed simultaneously. <br><br><h4>  Schedulers.from (Executor executor) </h4><br>  This scheduler will be based on your own <code>Executor</code> .  There may be a situation in which it will be necessary to perform certain tasks in the scheduler based on its own flow distribution logic. <br><br>  Suppose you want to limit the number of concurrent network calls your application makes.  You can create your own scheduler that will work on the basis of a limited thread pool ( <code>Scheduler.from(Executors.newFixedThreadPool(n))</code> ) and use it in all places related to network calls. <br><br><h4>  AndroidSchedulers.mainThread () </h4><br>  This is a special scheduler that is not available in the RxJava library.  You must use the <a href="https://github.com/ReactiveX/RxAndroid">extensible RxAndroid</a> library to access this scheduler.  This scheduler <b>is useful in Android applications for performing actions in the UI thread</b> . <br>  By default, this scheduler queues jobs in the <code>Looper</code> associated with the main thread, but there is a possibility of overriding: <code>AndroidSchedulers.from(Looper looper)</code> . <br><br>  <b>Note:</b> Be careful about using schedulers based on unrestricted thread pools, such as <code>Schedulers.io()</code> .  There is always the risk of an endless increase in the number of threads. <br><br><h3>  Understanding subscribeOn () and observeOn () </h3><br>  Now that you have an idea of ‚Äã‚Äãthe types of schedulers, <b>let</b> 's sort out <b>subscribeOn ()</b> and <b>observeOn ()</b> in detail. <br><br>  You need to have a deep understanding of how these two operators work separately and together in order to work professionally with multithreading in RxJava. <br><br><h4>  subscribeOn () </h4><br>  In simple words, <b>this operator tells which stream the <i>source observable</i> will transmit elements to</b> .  You must understand the importance of the word <i>"source</i> . <i>"</i>  When you have a chain of observable elements <i>(observables)</i> , the source <i>(source observable)</i> is always the root element or the upper part of the chain from which the events are created. <br><br>  As you have already seen, if you do not use <code>subscribeOn()</code> , then all events occur in the stream in which the code call occurred (in our case, the <code>main</code> stream). <br><br>  Let's redirect events to the compute thread with <code>subscribeOn()</code> and the <code>Schedulers.computation()</code> scheduler.  When you run the following code example, you will see that events occur in one of the compute threads available in the pool, <code>RxComputThreadPool-1</code> . <br><br>  In order to shorten the code, we will not completely override all the methods of <code>DisposableSubscriber</code> , since we do not need to override <code>onError()</code> and <code>onComplete()</code> .  We use <code>doOnNext()</code> and lambdas. <br><br><pre> <code class="java hljs">Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) .subscribeOn(Schedulers.computation()) .doOnNext(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Emitting item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName())) .subscribe(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Consuming item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName()));</code> </pre><br>  It doesn't matter where in the call chain you use <code>subscribeOn()</code> .  It works only with the observable source <i>(source observable)</i> , and controls to which stream the observable source transmits events. <br><br>  In the following example, after the observable source, other observable objects are created (using <code>map()</code> and <code>filter()</code> methods, and the <code>subscribeOn()</code> operator is placed at the end of the call chain.  But as soon as you run this code, you will notice that all events will occur in the stream specified in <code>subscribeOn()</code> .  This will become clearer when adding <code>observeOn()</code> to the call chain.  And even if we place the <code>subscribeOn()</code> below <code>observeOn()</code> , the operation logic will not change.  <code>subscribeOn()</code> works only with <i>source observable.</i> <br><br><pre> <code class="java hljs">Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) .doOnNext(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Emitting item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName())) .map(integer -&gt; integer * <span class="hljs-number"><span class="hljs-number">3</span></span>) .filter(integer -&gt; integer % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) .subscribeOn(Schedulers.computation()) .subscribe(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Consuming item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName()));</code> </pre><br>  It is also important to understand that you cannot use <code>subscribeOn()</code> several times in the same call chain.  You can, of course, write again, but this will not entail any changes.  In the example below, we consistently call three different schedulers, can you guess which scheduler will work on startup? <br><br><pre> <code class="java hljs">Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>) .subscribeOn(Schedulers.io()) .subscribeOn(Schedulers.computation()) .subscribeOn(Schedulers.newThread()) .doOnNext(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Emitting item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName())) .subscribe(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Consuming item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName()));</code> </pre><br>  If you answered <code>Schedulers.io()</code> , then you are right!  Even if you make the call multiple times - <b>only the first <code>subscribeOn()</code> , called after the observable source, will work</b> . <br><br><h4>  Under the hood </h4><br>  It is worth spending a little more time for a more detailed study of the considered example.  Why does <code>Schedulers.io()</code> only work?  Usually, everyone thinks that <code>Schedulers.newThread()</code> will work, since this call is at the end of the chain. <br><br>  It is necessary to understand that in RxJava a subscription is created after the callback of all <code>Observable</code> instances.  The code below will help us understand this.  This is a previously reviewed example, but described in more detail. <br><br><pre> <code class="java hljs">Observable&lt;Integer&gt; o1 = Observable.just(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>); Observable&lt;Integer&gt; o2 = o1.filter(integer -&gt; integer % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>); Observable&lt;Integer&gt; o3 = o2.map(integer -&gt; integer * <span class="hljs-number"><span class="hljs-number">10</span></span>); o3.subscribe(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Consuming item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName()));</code> </pre><br>  In order to understand how everything works, let's begin to sort everything out from the last line of the example.  In it, the target subscriber calls the <code>subscribe()</code> method on the observable object <code>o3</code> , which then makes an implicit call <code>subscribe()</code> on its parent observable object <code>o2</code> .  The implementation of the observer <i>(observer)</i> provided by the <code>o3</code> object multiplies the transmitted numbers by 10. <br><br>  The process repeats and <code>o2</code> implicitly calls the <code>subscribe()</code> object <code>o1</code> , passing the observer implementation, which allows only even numbers to be processed.  Now we have reached the root element ( <code>o1</code> ), which has no parent for the subsequent call to <code>subscribe()</code> .  At this stage, the chain of <i>observable</i> elements is completed, after which the observable source begins to transmit <i>(emit)</i> elements. <br><br>  Now you need to understand the concept of how subscriptions work in RxJava.  By now you should have an understanding of how chains of <i>observable</i> objects are formed and how events spread from the observable source. <br><br><h3>  observeOn () </h3><br>  As we have already seen, <code>subscribeOn()</code> instructs the observable source to transfer elements to a specific stream, and this stream will be responsible for promoting elements up to the subscriber <i>(Subscriber)</i> .  Therefore, by default, the subscriber receives processed items in the same thread. <br><br>  But this may not be the behavior you expect.  Suppose you want to get some data from the network and display it in the user interface. <br><br>  Two things need to be done: <br><br><ul><li>  Make a network call in a non-blocking I / O stream </li><li>  Get the result in the main application thread. </li></ul><br>  You will have an <code>Observable</code> that makes a network call in the I / O stream and sends the result to the subscriber.  If you use only <code>subscribeOn(Schedulers.io())</code> , then the target subscriber will process the result in the same I / O stream.  And we are not lucky, because you can work with the user interface in Android only in the main thread. <br><br>  Now it is extremely necessary for us to switch flows and we use <code>observeOn()</code> for this.  When <code>observeOn()</code> is encountered in a call chain, elements transmitted by the observable source are immediately transferred to the stream specified in <code>observeOn()</code> . <br><br><pre> <code class="java hljs">getIntegersFromRemoteSource() .doOnNext(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Emitting item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName())) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Consuming item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName()));</code> </pre><br>  In this invented example, we observe the receipt of integers from the network and their further transmission from the observable source.  In actual examples, this could be any other asynchronous operation, for example, reading a large file, fetching data from a database, etc.  You can run this example and look at the results, just follow the logs in the console. <br><br>  Now consider a more complex example in which <code>observeOn()</code> will be called several times to switch threads in the course of data processing. <br><br><pre> <code class="java hljs">getIntegersFromRemoteSource() .doOnNext(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Emitting item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName())) .subscribeOn(Schedulers.io()) .observeOn(Schedulers.computation()) .map(integer -&gt; { println(<span class="hljs-string"><span class="hljs-string">"Mapping item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> integer * integer; }) .observeOn(Schedulers.newThread()) .filter(integer -&gt; { println(<span class="hljs-string"><span class="hljs-string">"Filtering item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> integer % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>; }) .observeOn(AndroidSchedulers.mainThread()) .subscribe(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Consuming item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName()));</code> </pre><br>  In the example above, the observable source passes elements to the chain of handlers in the input / output stream, since we used <code>subscribeOn()</code> along with <code>Schedulers.io()</code> .  Next, we want to convert each element using the <code>map()</code> operator, but this needs to be done in the computational flow.  To do this, use <code>observeOn()</code> along with <code>Schedulers.computation()</code> before calling <code>map()</code> to switch the stream and transfer the elements to the target computational stream. <br><br>  The next step is to filter some elements and for some reason we want to perform this operation in a new stream for each of the elements.  We use again <code>observeOn()</code> , but already paired with <code>Schedulers.newThread()</code> before calling the <code>filter()</code> operator to transfer each element to a new stream. <br><br>  As a result, we want the subscriber to get the result of processing in the UI thread.  For this we use <code>observeOn()</code> together with the <code>AndroidSchedulers.mainThread()</code> scheduler. <br><br>  But what happens if we use <code>observeOn()</code> several times sequentially?  In the example below, in which thread does the subscriber get the result? <br><br><pre> <code class="java hljs">getIntegersFromRemoteSource() .doOnNext(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Emitting item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName())) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .observeOn(Schedulers.single()) .observeOn(Schedulers.computation()) .subscribe(integer -&gt; println(<span class="hljs-string"><span class="hljs-string">"Consuming item "</span></span> + integer + <span class="hljs-string"><span class="hljs-string">" on: "</span></span> + currentThread().getName()));</code> </pre><br>  If you run the example, you will see that the subscriber will receive the elements in the <code>RxComputationThreadPool-1</code> computational flow.  This means that the last one called <code>observeOn()</code> worked.  I wonder why? <br><br><h4>  Under the hood </h4><br>  Perhaps you guessed it.  As we know, a subscription <i>(subscription)</i> is called after a reverse roundabout of all <code>Obsevable</code> , but with the transfer of events <i>(emissions)</i> everything happens the other way round, that is, in the usual order as the code is written.  The call comes from the observable source and further down the call chain up to the subscriber. <br><br>  The <code>observeOn()</code> operator always works in a straightforward order, therefore sequential switching of flows occurs and the latter switches to the computational flow ( <code>observeOn(Schedulers.computation())</code> ).  So, when you need to switch a stream to process data in a new stream, just call <code>observeOn()</code> , and then process the elements.  Synchronization, exclusion of the race condition, all this and many other multi-threading difficulties RxJava handles for you. <br><br><h3>  Summary </h3><br>  Now you should have a fairly good idea of ‚Äã‚Äãhow to properly use RxJava to write multi-threaded applications that provide fast and smooth user interface. <br><br>  If the understanding did not come right away, do not worry.  Read the article again, experiment with code examples.  There are a lot of nuances to understand, do not rush. </div><p>Source: <a href="https://habr.com/ru/post/344016/">https://habr.com/ru/post/344016/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344006/index.html">8 educational projects</a></li>
<li><a href="../344008/index.html">Convolution network in python. Part 1. Determination of the basic parameters of the model</a></li>
<li><a href="../344010/index.html">The beginning of a new era of cryptocurrency? CME Group exchanges issue bitcoin futures</a></li>
<li><a href="../344012/index.html">Hacking a site using another site. Trust but check</a></li>
<li><a href="../344014/index.html">How we launched the router on Indiegogo or what opportunities are there in the communications market</a></li>
<li><a href="../344018/index.html">Break open interviews: on algorithms, on architecture, behavioral, etc.</a></li>
<li><a href="../344020/index.html">Service Desk - quick start. 4 part. Asset accounting</a></li>
<li><a href="../344026/index.html">Pygest # 19. Releases, articles, interesting projects, packages and libraries from the world of Python [November 20, 2017 - December 5, 2017]</a></li>
<li><a href="../344028/index.html">Real life stories from a single hosting, or dinosaur memories FirstVDS</a></li>
<li><a href="../344030/index.html">Selenium Manager: the story of a single interface</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>