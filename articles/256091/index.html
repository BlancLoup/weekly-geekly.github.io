<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: Generate and reproduce sound. Part two: generate a sinusoidal signal. Mastering DMA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the last article we managed to get the sound, but it was very expensive for us. First, we overclocked the controller to maximum speed. And secondly...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are switching from STM32 to the Russian K1986BE92QI microcontroller. Practical application: Generate and reproduce sound. Part two: generate a sinusoidal signal. Mastering DMA</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/post/255513/">In the last article</a> we managed to get the sound, but it was very expensive for us.  First, we overclocked the controller to maximum speed.  And secondly, apart from sound generation, the controller cannot do anything, since most of the CPU time is occupied by constantly updating the DAC value.  Not good at it.  Right now there is an urgent need to use DMA. <br><blockquote>  DMA, or Direct Memory Access is a direct memory access technology, bypassing the central processor. </blockquote>  - (c) <a href="http://habrahabr.ru/post/37455/">from here</a> . <br><a name="habracut"></a><br><br><h4>  A small digression. </h4><br>  A week of hard work passed from the idea of ‚Äã‚Äãusing DMA to getting the first results.  The first 3 days I tried to master it myself, but I could not get at least some result.  Everything turned out only after the official forum gave me an example of DMA configuration for about the same task.  After 4 days of his detailed study and detailed analysis of the documentation, a clear picture of the structure of the work of DMA appeared in my head. <br><br><h4>  First impression. </h4><br><blockquote>  The controller direct memory access MDR_DMA ............................................ ................................ 410 </blockquote><br>  Having opened the documentation I got into a stupor ... The main task at the initial stage of DMA mastering is to transfer some value to the DAC.  And we will solve it.  In DMA there are so-called "channels".  They are a link between the receiver and the transmitter.  In our case, between the memory and the periphery (DAC).  What can be bundles - shown in the table. <br><div class="spoiler">  <b class="spoiler_title">What can be bundles - shown in the table.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/5a3/8ad/e6e/5a38ade6ea2e476ea1697398b6988f2d.png"><br><img src="https://habrastorage.org/files/d98/4c2/3f1/d984c23f1d0e46a88a777cf0b63e78f0.PNG"></div></div><br>  As we see from the table - some channels are reserved for a certain periphery.  There is no DAC in this periphery.  The rest of the channels can be used for their intended purpose.  The very first free channel is channel 8. We‚Äôll be setting it up.  But how?  The documentation has a section <b>Rules for data exchange</b> . <br><div class="spoiler">  <b class="spoiler_title">It contains the following.</b> <div class="spoiler_text"><blockquote>  Data exchange rules <br>  The controller uses the data exchange rules listed below in Table 376, subject to the following conditions: <br>  - the DMA channel is enabled, which is performed by setting the state of the logical unit of control bits chnl_enable_set [C] and master_enable; <br>  - the request flags dma_req [C] and dma_sreq [C] are not masked, which is done by setting the control to the zero state of the control discharge chnl_req_mask_set [C]; <br>  - the controller is not in the test mode, which is done by setting the logic zero state of the control to int_test_en bit [C]. </blockquote></div></div><br>  Immediately find the registers to which these bits belong.  But first you need to send a <a href="http://habrahabr.ru/post/255479/">clocking</a> signal to the DMA. <div class="spoiler">  <b class="spoiler_title">We do this in the DMA setup function.</b> <div class="spoiler_text"><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define PCLK_EN_DMA (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;5) //   DMA. void DMA_Init_DAC (void) // DMA  DAC. { RST_CLK-&gt;</span></span></span><span class="hljs-meta">PER_CLOCK|=PCLK_EN_DMA; //  DMA. }</span></span></code> </pre> </div></div><br>  After submitting clocks, we need to enable DMA. <br><div class="spoiler">  <b class="spoiler_title">The DMA-&gt; CFG register is responsible for this.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b01/c4b/b9c/b01c4bb9cd8b44bc9c2cbf2f0734e12a.png"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define CFG_master_enable (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;0) //   . DMA-&gt;</span></span></span><span class="hljs-meta">CFG = CFG_master_enable; //  DMA.</span></span></code> </pre> </div></div><br>  The next <b>step is</b> to enable the <b>chnl_enable_set [C]</b> bit.  Here C denotes the channel number from zero. <br><div class="spoiler">  <b class="spoiler_title">It is in the register DMA-&gt; CHNL_ENABLE_SET.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/fff/e07/912/fffe079125a44f40a5ad3462d2a9bef2.png"><pre> <code class="objectivec hljs"> DMA-&gt;CHNL_ENABLE_SET = <span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   DMA 8.</span></span></code> </pre> </div></div><br>  After it is necessary to set to "0" <b>chnl_req_mask_set [0]</b> . <div class="spoiler">  <b class="spoiler_title">This bit is in the DMA-&gt; CHNL_REQ_MASK_SET register.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b81/4a7/ef2/b814a7ef24dd4bfea981383132ba9b17.png"></div></div><br>  Everything would be fine, would write 0 and everything, but ... <br><blockquote>  The discharge [C] = 0 has no effect.  Nessesary to use <br>  chnl_req_mask_clr register for permission <br>  installation requests; </blockquote><br>  Okay. <div class="spoiler">  <b class="spoiler_title">We look the register DMA-&gt; CHNL_REQ_MASK_CLR.</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/55d/e72/d27/55de72d278f14153bda4a93ff0ed9ce6.png"></div></div><br>  Here we need to install the unit on the channel we need. <pre> <code class="objectivec hljs">DMA-&gt;CHNL_REQ_MASK_CLR = <span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      DMA,  dma_sreq[]  dma_req[].</span></span></code> </pre> <br>  Well, the last step for us should be writing a zero to the <b>int_test_en bit [8]</b> .  But the existence of this bit is not written anywhere.  So - skip it. <br>  In addition, we assign our channel a high priority. <div class="spoiler">  <b class="spoiler_title">For this there is a register DMA-&gt; CHNL_PRIORITY_SET.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/daa/d7b/1cc/daad7b1ccb1d4df5a1286f2f7d1ac9d8.PNG"><br><pre> <code class="objectivec hljs">DMA-&gt;CHNL_PRIORITY_SET = <span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-comment"><span class="hljs-comment">// .</span></span></code> </pre> </div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After turning on the channel, you need to decide on the mode of operation of the DMA. <br><div class="spoiler">  <b class="spoiler_title">There are 6 of them.</b> <div class="spoiler_text"><blockquote>  - not valid; <br>  - the main; <br>  - auto-request; <br>  - "Ping pong"; <br>  - work with memory in the ‚Äúexecution with configuration change‚Äù mode; <br>  - work with the periphery in the ‚Äúexecution with changing configuration‚Äù mode. </blockquote></div></div>  After analyzing everything, I decided that at the initial stage I would have enough of the ‚Äúbasic‚Äù mode. <div class="spoiler">  <b class="spoiler_title">Here is a description of it.</b> <div class="spoiler_text"><blockquote>  Main <br>  In this mode, the controller only works with the main or alternative channel control data.  After the channel is enabled and the controller has received a request for processing, the DMA cycle is as follows: <br>  1. The controller performs 2 ^ R transmissions.  If the number of remaining gears is 0, the controller proceeds to step 3. <br>  2. Arbitration: <br>  - if the high-priority channel issues a processing request, the controller starts servicing this channel; <br>  - if the peripheral unit or software issues a processing request (repeated processing request over the channel), then the controller proceeds to step 1. <br>  3. The controller sets dma_done [C] to state 1 per clock cycle hclk.  This tells the central processor to end the DMA cycle. </blockquote></div></div>  We will deal with it in more detail when we fill in the structure of the DMA channel settings. <br><br><h4>  The structure of the DMA. </h4><br>  As it turned out, in addition to registers, DMA also has settings structures.  Honestly, for a very long time I delved into the principle of working with these structures.  Earlier, at the time of STM32, I used a ready-made library, because the knowledge of the language was not enough to read the documentation.  Now, albeit with some difficulty, but I can realize the whole principle of DMA work at a low level. <div class="spoiler">  <b class="spoiler_title">For each channel of the channel should be set its own structure.</b>  <b class="spoiler_title">It consists of four 32-bit cells.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/dac/d32/cb3/dacd32cb302f45219314ce6913956bd2.PNG"><br></div></div><br>  According to the documentation, the structure should be framed in this sequence. <br><blockquote>  - pointer to the end of the source data; <br>  - pointer end data receiver; <br>  - control bits; <br>  - calculation of the address. </blockquote><br><br><h4>  Filling the DMA channel structure </h4><br>  I propose to begin by filling in the register setting cell. <br><div class="spoiler">  <b class="spoiler_title">Select the offset address of the receiver (DAC).</b> <div class="spoiler_text"><img src="//habrastorage.org/files/7cd/de3/3a5/7cdde33a52724cd1999d82c78634d73c.PNG">  With us it does not change.  The source and receiver have a half word length (16 bits).  Our case: <br><blockquote>  Source data width = half word: <br>  b11 = no increment.  The address remains equal to the value of the dst_data_end_ptr memory area. </blockquote></div></div><br><div class="spoiler">  <b class="spoiler_title">Select the dimension of the source and receiver data.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/7a5/5c2/d1d/7a55c2d1d8134b8ba38c8917be487e98.PNG">  Here we choose the half-word.  Since our array is uint16_t (16 bit). <img src="//habrastorage.org/files/412/b2b/14d/412b2b14d10d4a40817fc61cefc01b8c.PNG">  Here we choose the same half-word. </div></div><br><div class="spoiler">  <b class="spoiler_title">We allow arbitration procedure.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/a6e/aa3/791/a6eaa3791231447bacff8da845468b80.PNG"><br><img src="//habrastorage.org/files/7b7/5a0/d7f/7b75a0d7f24c4aa09eba03817365f15a.PNG"><br>  Here is the item for a long time kept me in ignorance.  The fact is that DMA can not transfer the entire package at once, but in parts.  For example, we have an array of 1024 elements.  But we want to transmit 128 elements per second.  To do this, we can set b0111 and after the transfer of 128 elements, the transfer will be interrupted before being restarted by the processor or peripherals.  This will be useful when we associate a DMA with a timer.  In our case, we leave zeros.  As we need to transfer each element at a strictly specific moment.  Simple transfer of the entire array does not suit us. </div></div><br><div class="spoiler">  <b class="spoiler_title">Set the length of the package.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/bb2/d76/b1e/bb2d76b1e9c9473abe2b1a9b9277adc3.PNG"><br>  In the previous article, we passed an array of 100 elements in length.  Therefore, here we will select 100-1 elements (Since 0 = one element). </div></div><br><div class="spoiler">  <b class="spoiler_title">Unfortunately, I did not understand why this is necessary.</b>  <b class="spoiler_title">Leave unchanged.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/739/585/5f8/7395855f847d4603b8b99a24f2c8acb0.PNG"><img src="//habrastorage.org/files/04b/980/32a/04b98032acca4776958053c1c2a2d4ca.PNG">  We leave it unchanged so far. </div></div><br><div class="spoiler">  <b class="spoiler_title">It remains only to select the mode.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/bb6/903/78f/bb690378fcf54c5a88bdef9ba60c5896.PNG"><br><img src="//habrastorage.org/files/038/714/4dd/0387144dd7cf473386861b5ec7e0ff93.PNG"><br>  Select the "main" mode. </div></div><br>  We configured the channel configuration cell. <br><div class="spoiler">  <b class="spoiler_title">We got the following.</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//   . #define dst_src (3&lt;&lt;30) // - 16  (). #define src_inc (1&lt;&lt;26) //   16    . #define src_size (1&lt;&lt;24) //  16 . #define dst_size (1&lt;&lt;28) //  16 . (      ). #define dst_prot_ctrl //     (,  , ) #define R_power (0&lt;&lt;14) // (    ,   )   . #define n_minus_1 (99&lt;&lt;4) //100  DMA. #define next_useburst (0&lt;&lt;3) //    ,  ... #define cycle_ctrl (1&lt;&lt;0) // . // . #define ST_DMA_DAC_STRYKT dst_src|src_inc|src_size|dst_size|R_power|n_minus_1|next_useburst|cycle_ctrl</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Now we need to create an array of structures and write our settings there.</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DAC_ST { uint32_t Destination_end_pointer; <span class="hljs-comment"><span class="hljs-comment">//   . uint32_t Source_end_pointer; //    uint32_t channel_cfg; // . uint32_t NULL; // . }</span></span></code> </pre> </div></div><br>  But the next step took me almost 4 days.  The fact is that the address of each structure is strictly fixed and can only change with an offset of kilobytes. <div class="spoiler">  <b class="spoiler_title">Take a look at the array of structures.</b> <div class="spoiler_text"><img src="//habrastorage.org/files/b94/5c1/95f/b945c195f5fb4ee3aa03f9cd6346faff.PNG"></div></div>  Each channel can have two structures.  Primary and alternative.  The alternative does not concern us yet (It is needed for other modes of operation).  We are only interested in the primary (right column).  In order for the controller to see our structure of the eighth channel configuration - it must be located at 0x20000080 or 0x20000280, or 0x20000480, etc. With this entry I wanted to show that the structure must be in RAM and must be aligned on the 1024 border bytes  We describe this structure. <br><pre> <code class="objectivec hljs">__align(<span class="hljs-number"><span class="hljs-number">1024</span></span>) DAC_ST; <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> DAC_ST DAC_ST_ADC[<span class="hljs-number"><span class="hljs-number">8</span></span>] ;</code> </pre> <br>  Still a little explanation.  The main thing is to have the necessary structure at the specified address.  Data structures of the 7th channel or the 9th DMA do not care.  They may not be.  Technically, four 32-bit cells can be written to RAM at the indicated addresses and used.  But there is a risk that the controller will change them during the execution of the program.  Fill it in the program. <br><pre> <code class="objectivec hljs"> DAC_ST_ADC[<span class="hljs-number"><span class="hljs-number">7</span></span>].Destination_end_pointer = (uint32_t)C_4 + <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(C_4) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     (C_4 -      100 ). DAC_ST_ADC[7].Source_end_pointer = (uint32_t)&amp;(DAC-&gt;DAC2_DATA); //   ( )   (  DAC) DAC_ST_ADC[7].channel_cfg = (uint32_t)(ST_DMA_DAC_STRYKT); //  . DAC_ST_ADC[7].NULL = (uint32_t)0; // .</span></span></code> </pre><br>  It remains only to specify the starting address of the array of structures in the <b>DMA</b> register <b>-&gt; CTRL_BASE_PTR</b> . <br><pre> <code class="objectivec hljs">DMA -&gt; <span class="hljs-built_in"><span class="hljs-built_in">CTRL_BASE_PTR</span></span> = (uint32_t)&amp;DAC_ST_ADC;</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">The result of our setup has become.</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#define CFG_master_enable (1</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt;0) //   . #define PCLK_EN_DMA (1&lt;&lt;5) //   DMA. //   . #define dst_src (3&lt;&lt;30) // - 16  (). #define src_inc (1&lt;&lt;26) //   16    . #define src_size (1&lt;&lt;24) //  16 . #define dst_size (1&lt;&lt;28) //  16 . (      ). #define dst_prot_ctrl //     (,  , ) #define R_power (0&lt;&lt;14) // (    ,   )   . #define n_minus_1 (99&lt;&lt;4) //100  DMA. #define next_useburst (0&lt;&lt;3) //    ,  ... #define cycle_ctrl (1&lt;&lt;0) // . // . #define ST_DMA_DAC_STRYKT dst_src|src_inc|src_size|dst_size|R_power|n_minus_1|next_useburst|cycle_ctrl struct DAC_ST { uint32_t Destination_end_pointer; //   . uint32_t Source_end_pointer; //    uint32_t channel_cfg; // . uint32_t NULL; // . } __align(1024) DAC_ST; struct DAC_ST DAC_ST_ADC[8] ; void DMA_and_DAC (void) { DAC_ST_ADC[7].Destination_end_pointer = (uint32_t)C_4 + sizeof(C_4) - 1; //     (C_4 -      100 ). DAC_ST_ADC[7].Source_end_pointer = (uint32_t)&amp;(DAC-&gt;</span></span></span><span class="hljs-meta">DAC2_DATA); //   ( )   (  DAC) DAC_ST_ADC[7].channel_cfg = (uint32_t)(ST_DMA_DAC_STRYKT); //  . DAC_ST_ADC[7].NULL = (uint32_t)0; // . RST_CLK-&gt;PER_CLOCK|=PCLK_EN_DMA; //  DMA. DMA-&gt;CTRL_BASE_PTR = (uint32_t)&amp;DAC_ST_ADC; //   . DMA-&gt;CFG = CFG_master_enable; //  DMA. }</span></span></code> </pre> </div></div><br><br><h4>  We obtain a sinusoidal signal using DMA. </h4><br>  As we remember, we set up DMA to stop after each transmission.  Now, with the help of the system timer, we need to allow the transfer of the next data block to the DAC. <br><div class="spoiler">  <b class="spoiler_title">Configure the timer.</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Init_SysTick (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { SysTick-&gt;LOAD = <span class="hljs-number"><span class="hljs-number">80000000</span></span>/<span class="hljs-number"><span class="hljs-number">261.63</span></span>/<span class="hljs-number"><span class="hljs-number">100</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>; SysTick-&gt;<span class="hljs-built_in"><span class="hljs-built_in">CTRL</span></span> |= <span class="hljs-built_in"><span class="hljs-built_in">CLKSOURCE</span></span>|TCKINT|ENABLE; }</code> </pre> </div></div><br>  Next, in the interrupt of the system timer, we need to check whether the DMA passed everything.  If so, you need to re-configure its structure.  The fact is that after each transmission, DMA independently takes away from the number of transmissions by one.  Therefore, after all transmissions - you need to restore the original value for the transmission of a sine wave again.  After that, you need to allow the channel to work again (after the transfer, the channel becomes prohibited) and restart the transfer. <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> uint16_t Loop = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> uint32_t Delay_dec = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> SysTick_Handler (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((DAC_ST_ADC[<span class="hljs-number"><span class="hljs-number">7</span></span>].channel_cfg &amp; (<span class="hljs-number"><span class="hljs-number">0x3FF</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>)) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { DAC_ST_ADC[<span class="hljs-number"><span class="hljs-number">7</span></span>].channel_cfg = (uint32_t)(ST_DMA_DAC_STRYKT); } <span class="hljs-comment"><span class="hljs-comment">// DMA. DMA-&gt;CHNL_ENABLE_SET = 1&lt;&lt;8; //   DMA 8. DMA-&gt;CHNL_SW_REQUEST = 1&lt;&lt;8; //  . }</span></span></code> </pre><br><br><h4>  Instead of a conclusion. </h4><br>  Although we managed to learn how to work with DMA, we still could not unload the processor.  In the next article I will analyze the work of the timer and shift the work with DMA onto it, leaving the processor power for our needs. <br>  Thank you very much I want to say to <b>Yurock</b> , who shared an example of a DMA configuration code under the DAC <a href="http://forum.milandr.ru/viewtopic.php%3Ff%3D33%26t%3D2495">at the official official forum</a> .  Initially, I planned to write an article on the analysis of this example.  For I understood with him about 3 days.  It was too difficult for me.  Using a timer and various structures. <br>  <a href="">Code example from the lesson.</a> <br><div class="spoiler">  <b class="spoiler_title">List of previous articles.</b> <div class="spoiler_text">  1. <a href="http://habrahabr.ru/post/255199/">We turn from STM32F103 to K1986BE92QI.</a>  <a href="http://habrahabr.ru/post/255199/">Or the first acquaintance with the Russian microcontroller.</a> <br>  2. <a href="http://habrahabr.ru/post/255323/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255323/">Setup project in keil and flashing LED.</a> <br>  3. <a href="http://habrahabr.ru/post/255415/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255415/">System Timer (SysTick).</a> <br>  4. <a href="http://habrahabr.ru/post/255479/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255479/">Setting the clock frequency.</a> <br>  5. <a href="http://habrahabr.ru/post/255513/">We are switching from STM32 to the Russian K1986BE92QI microcontroller.</a>  <a href="http://habrahabr.ru/post/255513/">Practical application: Generate and reproduce sound.</a>  <a href="http://habrahabr.ru/post/255513/">Part one: we generate a square and sinusoidal signal.</a>  <a href="http://habrahabr.ru/post/255513/">Mastering the DAC (DAC).</a> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/256091/">https://habr.com/ru/post/256091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256081/index.html">How SpaceX uses the GPU to calculate rocket engines</a></li>
<li><a href="../256083/index.html">WEB 3.0. From cytocentricism to user centrism, from anarchy to pluralism</a></li>
<li><a href="../256085/index.html">Restoration of the PC "Microsha"</a></li>
<li><a href="../256087/index.html">Robot Assistant Lexi took first place at the Imagine Cup</a></li>
<li><a href="../256089/index.html">Intel Edison. First start</a></li>
<li><a href="../256095/index.html">jspm - browser package manager</a></li>
<li><a href="../256097/index.html">Run the music player in the emulator</a></li>
<li><a href="../256101/index.html">Homemade NAS from a netbook with a reworked PCI express SATA controller for ExpressCard / 34</a></li>
<li><a href="../256103/index.html">Firmware for electronics 3D scanner</a></li>
<li><a href="../256105/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ156 (April 13 - 19, 2015)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>