<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The performance of animations on sites</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When developing sites that go beyond the conventional bootstrap, sooner or later there are issues related to the performance of animations. Especially...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The performance of animations on sites</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="image"></p><br><p>  When developing sites that go beyond the conventional bootstrap, sooner or later there are issues related to the performance of animations.  Especially important they are in design sites, such as those that go to the catalogs Awwwards, FWA, CSS Design Awards, etc.  In this case, often the task of creating animations and subsequent optimization, if it is needed, falls on the shoulders of not very experienced developers who do not even know where to start.  Usually, all this results in slowing down sites that cannot be used, and the subsequent negative attitude towards the entire class of such projects.  In this article, we will try to make out where the border of acceptable animation performance is, which bottlenecks are often found and where to look in the developer‚Äôs tools first. </p><a name="habracut"></a><br><p>  <em>A small note: since this article is intended more for novice developers and its goal is to show general approaches to optimizing animations, many things will be given in a simplified, not quite academic form.</em> </p><br><h2 id="kak-brauzer-otobrazhaet-stranicu">  How the browser displays the page </h2><br><p>  First of all, it is useful to understand what happens when the browser displays the current state of the page to us.  There are four basic steps: </p><br><ol><li>  Style calculation (browser parses CSS selectors, determines which styles to apply to). </li><li>  Layout creation (the page layout is actually formed) </li><li>  Painting (creates pixel representations of elements for later rendering) </li><li>  Layer composition (the browser puts everything together and displays it on the screen) </li></ol><br><p>  In this case, the browser always acts in this sequence and goes to the end.  At initial display of the page after its loading there pass all four steps.  In the future, our actions can cause the execution of one of them, but at the same time all the subsequent ones will be executed.  But not the previous ones. </p><br><p>  We will consider the bottlenecks of each of these steps further, and now let us ask ourselves one stupid at first glance question that we should start with ... </p><br><h2 id="tormozit-ili-ne-tormozit-vot-v-chem-vopros">  Brakes or does not brake, that is the question ... </h2><br><p>  Very often, you can meet people who do not do anything with a clearly inhibiting site and say ‚Äúand my page speed gives 100 points, all is well‚Äù.  Or vice versa, on a well-functioning website, people have been doing some kind of optimization for a long time, because some algorithm works inefficiently for some mysterious metrics.  But between these extremes should be the middle of common sense, so where is it? </p><br><p><img src="https://habrastorage.org/webt/zv/su/nv/zvsunvxfwjqvs98q0_yhc9s5jry.jpeg" alt="image"></p><br><p>  To <del>  learn zen </del>  to understand whether you need to optimize your animations, you need to realize a deep philosophical thought: </p><br><blockquote>  If you see that the site slows down, then it slows down.  If you do not see that the site slows down, it means it does not slow down. </blockquote><p>  Many people for some reason consider this statement very stupid, but is it so?  For the end user, performance is not some metrics or ideal algorithms with a rigorous mathematical justification.  For him, performance is one of two things: slows down or does not slow down. </p><br><p>  How does he define it?  The eye of a person who spends a lot of time behind the monitor begins to react sharply to a drop in fps.  This causes a strange feeling of discomfort.  Accordingly, our task as developers is to prevent subsidence.  Is the user accustomed to seeing the browser work at 60fps?  Well, then we do everything so that all remains so.  Take a laptop with an average iron and look.  We see much less than 60fps - we optimize.  We see about 60 - do not touch anything.  The user will still not notice the difference, and we will spend a lot of time optimizing for the sake of optimizations. </p><br><blockquote>  Don't do optimizations for the sake of optimizations. </blockquote><br><h2 id="165ms">  16.5ms </h2><br><p>  It is not convenient to express in terms of fps, so let's move on to milliseconds.  With a simple 1000ms / 60fps division, we get about 16.5ms of time per frame. </p><br><p>  What does this mean?  For 16.5ms, the browser should show us the current state of the page with the animation, going through the steps that we saw above, and at the same time there should be resources for the work of other scripts, communication with the server, etc.  If the display of the current state of the page will spend more time - we will see through the eyes of the lag.  If it is about 16ms, there will be no sagging, but it is likely that the iron load will be very high, the coolers will buzz and the phones will warm up.  Thus, we need to ensure that the rendering of one frame does not approach this value in time, and even better was not more than 10ms, so that the performance margin remains.  Do not forget also that the tests are always carried out on the middle gland - for example, in the following examples, screenshots will be taken on a Pentium Silver with integrated graphics. </p><br><blockquote>  Perform tests on the hardware that your users are more likely to have.  If you have a workbench processor and a mining farm under the table, then everything will work well for you, while your users with budget laptops can be very sad. </blockquote><p>  In order not to rely only on your keen eye and intuition, it is useful to master the developer tools, at least at a basic level.  They will not only give accurate performance data, but also tell you where to look for the problem if everything is not working very well. </p><br><h2 id="instrumenty-razrabotchika-v-google-chrome">  Google Chrome Developer Tools </h2><br><p>  Many web designers are afraid of developer tools in the browser almost more than the linux console.  But in reality there is nothing to fear.  Yes, there are a lot of buttons, but they are redundant to solve our problems.  Now we will see where to pay attention in the first place, to understand what to do with the animation, and whether we need to do anything at all. </p><br><p>  When it comes to performance, we will spend most of the time in the performance tab and will press the same button. </p><br><p><img src="https://habrastorage.org/webt/a_/wd/vn/a_wdvnjnvppuvnrzp_f4sxp4gb0.png" alt="image"></p><br><p>  The keyboard shortcut Ctrl-E or the round button on the left starts and stops recording what is happening.  Results are displayed here.  The browser writes a lot of things, but it's better to see it once than to read it many times, so take some animation and look at it.  Let it be a simple CSS animation first.  If you open it to full screen, then you will see that it works with noticeable jams: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/Xwrqpw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  We will record a few seconds in full screen mode and see what happens there: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="image"></p><br><p>  The browser records everything that it does.  At the top of the window we see the fps graph.  On it you can easily detect the anomaly, if in the process of working with the page it begins to drastically slow down.  If you click on the graph with the mouse and pull it to the side or twist the wheel, you can select this time range and detailed information for it will be displayed below.  In our simple example, there are no anomalies, but it is clearly seen that everything does not work very evenly. </p><br><p>  Immediately pay attention to the line <em>Frames</em> , it contains information about the time spent on each frame.  You can see that this time constantly jumps and noticeably exceeds 16ms (below, in practical examples, we will slightly improve this animation). </p><br><p>  Next we see a few lines in which the load is displayed in different colors - you can see how much time the browser has spent on different activities.  We have a uniform animation and for each frame the same operations are performed, indicated by purple and green.  If you hover the mouse over the colored blocks, it will become clear that we are dealing with those points that were mentioned at the beginning ‚Äî <em>recalculate style</em> and <em>update layer tree</em> ‚Äî purple, and <em>paint</em> and <em>composite layers</em> ‚Äî green. </p><br><p>  Consider another animation.  This time with scripts - a simple noise generator.  This is a pretty illustrative example, although it is of no interest from the point of view of design: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/QRLrBJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> You may notice that yellow blocks have been added to display the execution of scripts.  If there are a lot of function calls, then one more block will be added for each call - it is easy to find the heaviest function with their size, with which it is probably worth starting optimization. </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="image"></p><br><p>  In the example, the time taken for one frame varies around 80ms.  But what‚Äôs really there, even with the naked eye, you can clearly see how everything is jerking.  Looking at the <em>summary</em> section below, we see that the most time is occupied by scripts.  Compared to them, <em>rendering</em> and <em>painting</em> look like errors that can be neglected.  Not always, of course, it happens, but quite often. </p><br><p>  If you click on the block marked as <em>function call</em> , then below there will be a link to the function in the script code.  If you go through it, you can see that in this example, there is a cycle for all pixels on the screen.  Such a task would be more logical to do on shaders, then the performance would be much better.  But we will look at it in practical examples. </p><br><h2 id="chto-delat-esli">  What to do, if... </h2><br><p>  We learned what steps there are when displaying the current state of the page in the browser, and where to see which one takes the most time.  It is time to get acquainted with the most common reasons why a particular step begins to require too many resources and give a couple of tips on what to do in this or that case. </p><br><h2 id="style-calculation">  Style calculation </h2><br><p>  If you see that already at this step the problems begin - most likely the point is not even in animation, but in the fact that there are too many elements on the page.  In design sites, this is quite rare, usually such a problem is a satellite of large tables with thousands of elements, but if you still encounter this: </p><br><blockquote>  Reduce the number of elements on the page, simplify the markup.  Pay special attention to duplicate pieces of code with wrappers, it is likely that they can be removed. </blockquote><p>  The second reason related to the first is complex CSS selectors.  If on small pages it is quite possible to use deep nesting, tricky hacks with neighboring elements, etc., then on a really large page this can all lead to poor performance. </p><br><blockquote>  Simplify CSS selectors, use BEM. </blockquote><br><h2 id="layout-creation">  Layout creation </h2><br><p>  This item is closer to the design and animations, here begin interesting things.  The first thing that is important to understand is that the layout is formed entirely.  If we change something, it is formed again.  For this reason, on a large page, even minor changes can cause noticeable delays in this step. </p><br><p>  The main rule that we follow when creating animations is to not allow the restructuring of the layout at any cost.  Therefore, we usually do not try to optimize it (and there are no special opportunities), but we try to avoid it. </p><br><p>  There are many <a href="https://csstriggers.com/">properties</a> that can cause a lot of rebuilding of the layout, you can find lists on the Internet, for example, at <a href="https://csstriggers.com/">csstriggers.com</a> there is a good one.  More often than others in animations one can come across properties: </p><br><pre><code class="plaintext hljs">display position / top / left / right / bottom width / height padding / margin border font-size / font-weight / line-height ...</code> </pre> <br><p>  You may notice that all these properties combine one thing - they describe the geometric characteristics of the elements - the display parameters, size and physical location.  So instead of remembering them all, remember what they refer to. </p><br><blockquote>  Do not change the geometric properties of elements, it is better to use transform and opacity. </blockquote><p>  Separately, it is worth noting that changing the background of the element will also take us back to this step.  We constantly forget about it, so we will highlight it into a separate recommendation: </p><br><blockquote>  Do not change the background elements. </blockquote><p>  In some browsers ( <del>  I will not poke a finger in Firefox </del>  ) a characteristic lag of CSS animations with transformations may appear, especially if more than one animation is performed per unit of time.  Outwardly, this may look not only as a pause in her work, but also as a ‚Äúbreakdown‚Äù of the animation to its very beginning.  It seems that the browser is constantly relying on something.  This behavior is almost always <em>improved</em> with the help of the <em>backface-visibility</em> property. </p><br><blockquote>  If possible, add backface-visibility: hidden elements to be animated. </blockquote><p>  Also, the restructuring of the layout is caused by our calls to the elements from the scripts.  Moreover, it does not have to be a direct change in CSS, it can be an appeal to certain properties and methods of elements.  The most common: </p><br><pre> <code class="plaintext hljs">offset*** client*** inner*** scroll***</code> </pre> <br><p>  In animations, be careful with them, because  if we begin to address these properties and methods for a large number of elements, each time this will cause a restructuring of the layout. </p><br><blockquote>  Avoid referring to the mentioned properties and methods for individual elements in cycles. </blockquote><br><h2 id="painting-i-layer-composition">  Painting and layer composition </h2><br><p>  These two steps will be considered together, because  they are to some extent related and usually if there is a problem with one, they will be with the other.  Skip these steps, avoid them, will not work, so we are trying to somehow optimize them. </p><br><p>  The browser does not prepare the pixel image of the page entirely, but in parts - in layers.  There may be many.  Each layer exists as if in itself and does not affect the rest, which sets the stage for some CSS hacks.  But we will talk about them another time.  Then from these layers the final image is collected.  In the context of animations, it is very useful to render the animated elements in a separate layer so that their changes do not affect everything around.  It is desirable that the contents of the elements was small.  We can do this using the <em>will-change</em> property or, as it was done before, <em>transform: translateZ (0)</em> .  The only thing to remember is that you cannot increase the number of layers indefinitely.  At some point, it will play a cruel joke and the performance on the contrary will fall.  So there will be two tips: </p><br><blockquote>  Use will-change or transform: translateZ (0) to place animated elements on a separate layer. </blockquote><p>  But at the same time </p><br><blockquote>  Do not overdo it with this case.  Check in the developer‚Äôs tools that it‚Äôs not getting worse. </blockquote><p>  Very often, serious problems are caused by filters that somehow transform the image of elements.  These may be simple CSS filters with <em>blur</em> or confused variants with SVG, but the effect will be the same - noticeable performance degradation. </p><br><blockquote>  Do not use complex filters.  If you still need the intended effect - consider the option of implementing it on WebGL. </blockquote><br><h2 id="naskolko-eti-sovety-rabotayut">  How do these tips work? </h2><br><p>  Work, but do not need to expect a miracle from them.  On the network, newbies sometimes say ‚ÄúI added will-change, but nothing has changed.‚Äù  This usually means that the main problem was elsewhere, and this technique gave such a small performance boost that it went unnoticed.  That is why it is important to use developer tools to clearly understand exactly where the bottleneck is and not to waste time and energy on trying to optimize what works fine. </p><br><p>  From all this we can conclude that there are not so many ways to influence the rendering of the page, and the effect of them will not always be significant.  These techniques are not silver bullets, they are rather needed for polishing the animation.  If we look at sites with really bad performance, we note that in most cases our own scripts will be to blame, and not mysterious problems with parsing CSS somewhere in the bowels of the browser. </p><br><h2 id="skripty">  Scripts ... </h2><br><p>  Do you know where the problems with dragging animations grow most often (according to my observations)?  From this development approach: </p><br><p><img src="https://habrastorage.org/webt/31/ov/_a/31ov_auhpakgnb4tu2mtfapgi7w.jpeg" alt="image"></p><br><p>  It sounds silly, but it is.  Constantly there are solutions, clearly from somewhere copied completely without an understanding of what is what.  It even happens that you can delete half of the code and everything will continue to work.  Often the code in the responses to the SO or Toaster is not intended for your production.  This should be obvious.  It shows the idea, answers the question, but is not at all the best final option for your specific task. </p><br><blockquote>  If you already copy, then at least look at the code for unnecessary actions. </blockquote><br><h2 id="requestanimationframe">  RequestAnimationFrame </h2><br><p>  People often talk about this method and recommend using it instead of <em>setTimeout / setInterval</em> in animations.  This makes sense, since those methods tend to become out of sync with the frames that the browser redraws and as a result, small lags are obtained.  But there are two comments. </p><br><p>  First, if more than one element is animated on the page and we will call requestAnimationFrame many times, this will lead to a sharp subsidence of fps.  In theory, this should not be so, but in practice everything happens that way.  Read the tests <a href="https://jsperf.com/single-raf-draw-calls-vs-multiple-raf-draw-calls">here</a> . </p><br><blockquote>  Merge all callbacks for animations into one requestAnimationFrame. </blockquote><p>  The second point is rather related to the situation when we already have a heavy animation, possibly with the use of canvas, which we cannot get rid of or have no time to redo, and the following happens: let's say the animation should run in N seconds and we already use <em>requestAnimationFrame</em> .  But it takes a lot of resources to calculate the current state and we see the following picture: the animation works smoothly and beautifully, but in 2N or even 3N seconds.  As a result, everything is perceived by the ooochchchcheeenn meeeeddlleennym.  In order to at least somehow correct this behavior, you can go against all recommendations, thereby taking advantage of <em>setInterval / setTimeout</em> and linking the states of the elements being animated to physical time, and not to abstract frames.  As a result, we get a formal decrease in fps, but with the psychological effect of productivity gains. </p><br><blockquote>  In the case of extremely slow animations, it may make sense to refuse requestAnimationFrame in favor of setInterval / setTimeout. </blockquote><br><h2 id="canvas-i-sheydery">  Canvas and Shaders </h2><br><p>  Much of the animations on non-standard sites are related to canvas.  This is quite understandable, CSS is a limited thing, but here we can realize any designer fantasies.  But it must be borne in mind that the usual 2d canvas is far from the most productive technology.  If you start to draw a lot of elements on it or work with pixels directly, then you will quickly encounter the fact that fps sags, or all of a sudden, <em>painting</em> and <em>layer composition</em> start to take an indecent amount of time.  This problem can be clearly seen in the example: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/vdYRoj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Let's take a look at what the browser does (the latest Google Chrome under Linux): </p><br><p><img src="https://habrastorage.org/webt/na/ox/5k/naox5kmmcqfuosbsfhgozpq91zw.jpeg" alt="image"></p><br><p>  Pay attention to how much the <em>layer</em> has expanded.  It looks a bit illogical, because there is only one element, what can be arranged there for so long?  But when using 2d canvas, this behavior is not uncommon, and something very difficult to do with it.  This is one of the reasons why we usually tend to use WebGL, there are no such questions. </p><br><blockquote>  If there is a choice between 2d canvass and WebGL, choose the second one.  This will give an initial performance bonus on the same tasks. </blockquote><p>  What is WebGL usually associated with?  With shaders.  Shader debugging is a headache for anyone working with them.  And developer tools are practically powerless here.  Usually, if there are too many calculations in shaders, we see in the summary below that the ‚Äúidle time‚Äù is most of the time, which in fact is the execution of our shaders independently of the browser, and we cannot get any useful details. </p><br><p>  There are various recommendations on which functions to prefer to others in shaders, because they are supposedly better optimized.  Or that you need to avoid blocking operations.  This is all true, but according to my observations, in most cases, shaders, which too slow down the work of the site, are just very large shaders.  If you wrote 100 GLSL lines in one place, this is almost guaranteed to work poorly.  And if there are also different nested constructions, cycles, then all - write gone.  It is difficult to give any recommendations here, except that: </p><br><blockquote>  If during your work you understood that everything is more complicated than it seemed initially, and that there will be a lot of code and it will slow down - it is better to discuss this with the designer and customer as early as possible and think about what can be changed. </blockquote><p>  It is often possible to conclude that a pre-prepared video will work much better than trying to render some kind of a confused piece in real time.  Remember this.  Yes, everyone wants to show themselves, they want to show off ‚Äúand I still can do it like this,‚Äù but do not forget about the end users. </p><br><p>  In connection with this idea, the ‚Äúdisease‚Äù is remembered, to which former Olympiads are especially susceptible.  For some reason, it manifests itself strongly when working with canvass.  For her reason, you should always carefully copy the code of such people.  They try to use ‚Äúcorrect‚Äù mathematical algorithms, complex physical formulas, calculate all the movements of elements with great accuracy, even where it is completely useless.  This leads to an increase in the load on the processor and to the fact that it does not have time to calculate anything for our conditional 10ms.  In practice, it is often possible to do with approximate formulas and school knowledge of physics.  No need to complicate things, we make websites, not software for ballistic missiles. </p><br><blockquote>  Use simple algorithms. </blockquote><p>  There is another trick called <em>RayMarching</em> .  Some people consider creating different effects with its help something like a challenge, warming up for the mind, and sometimes the results make a strong impression.  For example, a whole underwater world is generated here (put in a video, because from the calculations of this in real time the phone / laptop can easily hang itself): </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/mQXUHTTq4E8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  You can familiarize yourself with the shader <a href="https://www.shadertoy.com/view/4sXBRn">here</a> . </p><br><p>  In practice, this all requires incredible resources for work.  In full-screen mode, we have 400-800ms per frame (and in general in this example, up to 1500ms can rise): </p><br><p><img src="https://habrastorage.org/webt/pj/jj/pj/pjjjpj9fu4fcqkvtqg2bggwhqhc.jpeg" alt="image"></p><br><p>  So if you catch yourself thinking to do something on the combat site - give yourself a keyboard over the head, drink tea and think about alternative effects. </p><br><blockquote>  Do not use RayMarching, this is a sure way to kill performance. </blockquote><br><h2 id="prakticheskiy-primer">  Practical example </h2><br><p>  In the articles about performance, there are often not enough examples, and it is difficult to believe in the word.  So consider a couple.  Remember the first example with a rotating tunnel on CSS?  The browser did a lot of things: </p><br><p><img src="https://habrastorage.org/webt/ih/4a/ik/ih4aikfcshl-qmlrus_osjofine.jpeg" alt="image"></p><br><p>  We want to speed it up a bit.  Where to begin?  We see purple blocks, which means that the browser is constantly rebuilding the layout.  There are no scripts there, but there are CSS animations in which something changes.  Let's look at their code: </p><br><pre> <code class="css hljs">@<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> rotate { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(0); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rotate</span></span>(360deg); } } @<span class="hljs-keyword"><span class="hljs-keyword">keyframes</span></span> move-block { <span class="hljs-selector-tag"><span class="hljs-selector-tag">from</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(0); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color1; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">to</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">transform</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">translateX</span></span>(-@block-size * 6); <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: @color2; } }</code> </pre> <br><p>  Transformations do not frighten us, but we see a change in the background of the elements.  We recall that this may cause a restructuring of the layout, and we think what can be done in this situation ... </p><br><p>  Changing the background should be removed at any cost, so based on the general idea of ‚Äã‚Äãthe animation, we decide that we can put a radial gradient on top, which will create almost the same volume effect.  Someone will say that gradients are bad for performance, but we are not going to change it.  Let it be better once it has a bad impact, than we will have a whole mountain of constantly badly influencing elements.  The result is: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/OYLZpx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Let's see what the browser does: </p><br><p><img src="https://habrastorage.org/webt/0i/hc/oh/0ihcohn8cxnwbrq78qgmo8b0-w4.jpeg" alt="image"></p><br><p>  Wow ... Instead of a heap of actions, we see rare references to the GPU and nothing more, while the animation itself began to work noticeably smoother. </p><br><h2 id="esche-primer">  Another example </h2><br><p>  Recall how the browser looked like in a noise generator: </p><br><p><img src="https://habrastorage.org/webt/er/j_/cb/erj_cbmcg89tvzk-dco35nqcmia.jpeg" alt="image"></p><br><p>  The problem is definitely in the scripts.  It can be seen that the block "render" is the largest.  This is our main function for image rendering.  Let's look at it: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">render</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> imageData = CTX.createImageData(CTX.canvas.width, CTX.canvas.height); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; imageData.data.length; i += <span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> color = getRandom(); imageData.data[i] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">2</span></span>] = color; imageData.data[i + <span class="hljs-number"><span class="hljs-number">3</span></span>] = <span class="hljs-number"><span class="hljs-number">255</span></span>; } CTX.putImageData(imageData, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); requestAnimationFrame(render); }</code> </pre> <br><p>  There is definitely work with individual pixels.  This is not very cool.  We said that, if possible, it‚Äôs better to use not 2d canvas, but WebGL, and this task just wants to be parallelized using a shader.  Let's do it: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/VOZxGp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  What happens in the end?  See for yourself: </p><br><p><img src="https://habrastorage.org/webt/3m/td/vh/3mtdvhlrjo4-cjuqmzieis4tr7w.jpeg" alt="image"></p><br><p>  Time per frame decreased to almost 16ms.  Of course this is not ideal, but still better than 80ms.  In complex beautiful animations such a performance boost can be very noticeable.  Taking this opportunity I recommend beginners to get acquainted with the <a href="https://habr.com/ru/post/420847/">introduction to programming of shaders</a> and with <a href="https://habr.com/ru/post/421821/">continuation with examples</a> . </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  In this article, we figured out when to optimize animation performance, how to use Chrome‚Äôs developer tools in this context, and what to look for first.  I hope this information will be useful to developers who first encountered such tasks and do not know where to start. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/450484/">https://habr.com/ru/post/450484/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450464/index.html">ZENLIX 3.5 - after 2 years</a></li>
<li><a href="../450466/index.html">Just about Prolog</a></li>
<li><a href="../45047/index.html">Watching HeadHunter</a></li>
<li><a href="../450474/index.html">Introduction to Python</a></li>
<li><a href="../45048/index.html">Reply ASUS Eee Top by MSI</a></li>
<li><a href="../450486/index.html">9. Check Point Getting Started R80.20. Application Control & URL Filtering</a></li>
<li><a href="../450494/index.html">How does the translation of the term trunk depend on the vendor of the switches?</a></li>
<li><a href="../4505/index.html">Tut.By demonstrates Internet censorship in Belarusian</a></li>
<li><a href="../450506/index.html">How to make an application out of the site and put it on Google Play in a few hours. Part 2/2: Trusted Web Activity</a></li>
<li><a href="../450518/index.html">Arduino and Processing. How to control the microcontroller on the COM port. Bilateral communication</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>