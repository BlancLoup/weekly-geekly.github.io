<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Exact calculation of geometric predicates</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day to you, colleagues. I suggest you read an article about the basic aspect of computational geometry - the exact calculation of predicates. 

 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Exact calculation of geometric predicates</h1><div class="post__text post__text-html js-mediator-article">  Good day to you, colleagues.  I suggest you read an article about the basic aspect of computational geometry - the exact calculation of predicates. <br><br>  It is possible that many of you have come across the ‚Äústrange‚Äù behavior of implementations of the algorithm of the vychgeoma: crashes and incorrect results.  In general, there is nothing surprising in these oddities - these are the costs of transferring continuous geometry to the harsh discrete realities of floating point arithmetic.  I would venture to suggest that some of you, by debugging your algorithms, solved similar problems by selecting magical constants.  Most likely, if this method and led to the result, it is likely to temporary. <br><br>  In this article, I will explain how to get rid of the flaws in floating-point calculations with little or no damage to efficiency.  Article layout: <br><ul><li>  geometric predicate "turn"; </li><li>  contradictory "naive" implementation of the turn; </li><li>  applying interval arithmetic to simplify the predicate calculation; </li><li>  long arithmetic and several alternative ways to calculate predicates; </li><li>  calculation of the calculation error of rotation in floating point numbers. </li></ul><br>  So, if you want to know why computational geometry is not a "science of selecting epsilons" and how to correctly and efficiently implement a geometric algorithm, click <a name="habracut"></a>  here. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Turn </h4><br>  In general, any algorithm, as a discrete structure, is implemented strictly.  Problems arise in conditional blocks where the value of a predicate is checked (for example, if a point lies inside a triangle, if a segment intersects a quadrilateral, etc.). <br><br>  Consider, for example, a turn, the simplest geometric predicate.  This input predicate takes three points on the plane. <img src="https://habrastorage.org/getpro/habr/post_images/476/26a/cba/47626acba15719e3290ea4873ab25b16.png">  and returns 1 if <em>c</em> lies to the left of the directed segment <em>ab</em> ;  -1 if on the right;  and 0, if three points lie on one straight line.  The predicate is implemented using the vector product: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/62d/333/718/62d33371899ddfdba5a407dbfb753336.png" title="Turn"><br><br>  This predicate, despite its simplicity, is very important: it can be used to check, for example, if a pair of segments intersect, if a point lies inside a triangle, etc.  Consider its implementation: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-keyword"><span class="hljs-keyword">turn_t</span></span> {left = <span class="hljs-number"><span class="hljs-number">1</span></span>, right = <span class="hljs-number"><span class="hljs-number">-1</span></span>, collinear = <span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cross</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point_2 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, point_2 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ax * by - bx * ay; } <span class="hljs-keyword"><span class="hljs-keyword">turn_t</span></span> turn(point_2 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; a, point_2 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; b, point_2 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp; c) { <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> det = cross(b - a, c - a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (det &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (det &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collinear; }</code> </pre> <br>  Consider a call to the turn function with the following input: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">point_2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">a</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; point_2 b = -a; point_2 c = a * (<span class="hljs-number"><span class="hljs-number">1L</span></span>L &lt;&lt; <span class="hljs-number"><span class="hljs-number">52</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">turn_t</span></span> res = turn(a, b, c); <span class="hljs-comment"><span class="hljs-comment">//  collinear</span></span></code> </pre><br>  Despite the fact that all points lie on one straight line, the result, due to the limited accuracy of floating-point arithmetic, is not equal to collinear.  Often, as a hot fix, it is believed that the vector product <img src="http://latex.codecogs.com/png.latex?\inline v = (b - a)\times(c - a)">  can be considered zero if <img src="http://latex.codecogs.com/png.latex?\inline |v|">  less than some predefined constant <em>e</em> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> det = cross(b - a, c - a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (det &gt; e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (det &lt; -e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collinear;</code> </pre><br>  The thought is unsuccessful, since the predicate will be incompatible at four points: for any such constant <em>e,</em> you can choose four points so that the predicate will return contradictory results.  For example, consider two parallel, not lying on one straight line segment <em>ab</em> and <em>cd</em> (see figure). <br><br><img src="http://habrastorage.org/storage2/84e/882/fe8/84e882fe8fb122e77f2426951254bd95.png"><br><br>  In this figure, the triangles <img src="http://latex.codecogs.com/png.latex?\inline v_1ab">  and <img src="http://latex.codecogs.com/png.latex?\inline v_2cd">  have the same area equal to <em>e / 2</em> .  Since the doubled area of ‚Äã‚Äãa triangle is equal to the product of height and base, all points of a long segment <em>ab</em> form, on the basis of <em>cd,</em> triangles of the same area.  This area will be less than the areas of similarly constructed triangles based on <em>ab</em> and vertices on <em>cd</em> .  From this it follows, for example, that for a certain constant <em>e, the</em> segment <em>ab</em> will be collinear to the segment <em>cd</em> , but <em>cd</em> will not be collinear to the segment <em>ab</em> . <br><br>  But note that usually collinear is a rather rare result.  If we could produce most of the left and right turns, comparing the vector product with some constant, and counting the rest of the answers in some less effective but accurate way (for example, using long arithmetic), then we could consider our task accomplished, since on average the calculation time of the rotation would increase slightly.  The calculation of the constant <em>e,</em> I will give in the appendix below, for those who are not afraid of tedious, but trivial calculations.  After the changes, the predicate will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> l = (bx - ax) * (cy - ay); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> r = (cx - ax) * (by - ay); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> e = (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(l) + <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( r)) * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;::epsilon() * <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> det = l - r; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (det &gt; e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (det &lt; -e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right; <span class="hljs-function"><span class="hljs-function">long_point_2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">la</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( c)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">long_t</span></span> ldet = cross(lb - la, lc - la); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldet &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ldet &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collinear;</code> </pre><br>  In general, we have already obtained an absolutely correct and fairly fast predicate.  There are two subtleties: firstly, it can be accelerated a little more, and, secondly, the derivation of the formula for the constant <em>e</em> in the general case is quite difficult, despite significant help from symbolic arithmetic (sympy, sage, etc.) .).  Now is the time to think about interval arithmetic. <br><br><h4>  Interval arithmetic </h4><br>  The main idea of ‚Äã‚Äãinterval arithmetic is to fix a real number in a certain segment with floating-point boundaries.  Any number that is exactly representable in floating arithmetic will be represented by a degenerate segment - a point. <br><br>  When two intervals are added, their boundaries are added: the upper boundaries are rounded up (k plus infinity), and the lower ones are rounded down (minus infinity).  It is easy to determine the remaining arithmetic operations from the following considerations: the exact value of a real number is unknown, it can be any in the segment.  Hence, the resulting segment must contain the results of the arithmetic action on all pairs of numbers from the operand segments. <br><br>  There are several implementations of interval arithmetic, for example, boost / interval. <br><br>  Using interval arithmetic, one can much more accurately determine the ‚Äúconfidence interval‚Äù of the predicate calculation in floating point arithmetic.  Interval arithmetic is, for obvious reasons, two to five times slower than ordinary arithmetic, but about three or four times faster than long arithmetic.  So in the implementation of predicates, it makes sense to specify the confidence interval after ordinary floating point arithmetic before calling long arithmetic: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> l = (bx - ax) * (cy - ay); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> r = (cx - ax) * (by - ay); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> e = (<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(l) + <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( r)) * <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;::epsilon() * <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> det = l - r; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (det &gt; e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (det &lt; -e) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> right; <span class="hljs-function"><span class="hljs-function">interval_point_2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ia</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( c)</span></span></span></span>; interval&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt; idet = cross(ib - ia, ic - ia); <span class="hljs-comment"><span class="hljs-comment">//     , , //    if (!zero_in(idet)) { if (idet &gt; 0) return left; return right; } long_point_2 la(a), lb(b), lc( c); long_t ldet = cross(lb - la, lc - la); if (ldet &gt; 0) return left; if (ldet &lt; 0) return right; return collinear;</span></span></code> </pre><br>  Please note that if you remove the usual arithmetic before the interval, the calculation speed will fall two to five times, but not by three or four orders of magnitude, as if we had left only long arithmetic.  Sometimes it is much more difficult to estimate the predicate's confidence interval than in this case, and the performance of long arithmetic does not allow it to be used as the main means of calculation.  In this case, interval arithmetic will be a reasonable compromise. <br><br><h4>  About long arithmetic </h4><br>  In general, long arithmetic is not the only way to accurately determine the sign of an arithmetic expression.  There are several algorithms that are more efficient than long arithmetic by an order and a half.  We are talking about algorithms <abbr title="Exact Sign of Sum Algorithm">ESSA</abbr> and Adaptive Precision Arithmetic.  I will not give these algorithms here, since it is easy to find detailed descriptions on the Internet.  I will only make a remark that can save some time during debugging: often the coprocessor flags are set in such a way that the calculations are carried out in ten-byte real numbers, which are pushed out to eight or four-byte real numbers when assigned.  Due to this, greater accuracy of computations is achieved, but this negatively affects the mentioned ESSA and Adaptive Precision Arithmetic algorithms.  As for the rest, these algorithms are quite portable and quite simply realizable. <br><br><h4>  findings </h4><br>  In this article, I introduced you to the method of filtered predicate calculation.  In the first step of the filter (floating point arithmetic), most of the input data is effectively eliminated.  In the second step (interval arithmetic), a significant part of the input data that passed the first filter is eliminated.  In the third step (long arithmetic, ESSA or Adaptive Precision), the remaining data that has passed through the previous steps is processed.  In our tests (a uniform distribution in the square) of their one hundred million input data, approximately two hundred thousand passed on interval arithmetic.  Only a few inputs have reached the length of arithmetic, which makes it possible to make an optimistic conclusion about the effectiveness and simplicity of this approach.  This approach is generally accepted: it is used, for example, by the library of computational geometry CGAL.  In your tasks, you can easily use your own filters, in accordance with the nature of your input data. <br><br><h4>  Links </h4><br><ul><li>  <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">Goldberg.</a>  <a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What every computer scientist should know about floating-point arithmetic</a> </li><li>  <a href="http://www.boost.org/doc/libs/1_48_0/libs/numeric/interval/doc/interval.htm">boost / interval library</a> </li><li>  <a href="http://cs.nyu.edu/yap/bks/egc/09/">Chee K. Yap.</a>  <a href="http://cs.nyu.edu/yap/bks/egc/09/">Exact geometric computations.</a> </li><li>  <a href="http://www.cs.berkeley.edu/~jrs/papers/robustr.pdf">JR Shewchuk.</a>  <a href="http://www.cs.berkeley.edu/~jrs/papers/robustr.pdf">Adaptive Precision Floating Arrowmetic and Fast Robust Geometric Predicates</a> </li></ul><br><h4>  Note.  Calculating the constant <em>e</em> to rotate </h4><br>  There is already a lot written about floating point numbers, so I will simply list some facts. <br><br>  A binary floating point number is represented as: <img src="http://latex.codecogs.com/png.latex?\inline a = \pm 1.a_1a_2a_3\dots a_{p - 1} \times 2^\gamma, a_i \in \{0, 1\}" title="Floating point binary representation">  .  Operations with an error on floating-point numbers (as opposed to the usual operations on real numbers) are usually designated as: <img src="http://latex.codecogs.com/png.latex?\inline \oplus, \ominus, \otimes" title="Floating point operations">  .  "Machine epsilon" different authors define differently, I will use the following definition: <img src="http://latex.codecogs.com/png.latex?\inline \varepsilon = 2^{-p}" title="Machine Epsilon">  .  Note in stl, for example, epsilon is twice as large.  Then the error of operations, subject to rounding to the nearest, can be expressed as: <br><br><img src="http://latex.codecogs.com/png.latex?a \oplus b = (a + b)(1 + \delta),\ |\delta| \leq \varepsilon" title="Accuracy +"><br><img src="http://latex.codecogs.com/png.latex?a \ominus b = (a - b)(1 + \delta),\ |\delta| \leq \varepsilon" title="Accuracy -"><br><img src="http://latex.codecogs.com/png.latex?a \otimes b = (a b)(1 + \delta),\ |\delta| \leq \varepsilon" title="Accuracy *"><br><br>  Calculate the rotation in floating point numbers: <br><br><img src="http://latex.codecogs.com/png.latex? \tilde{v} = (b_x \ominus a_x) \otimes (c_y \ominus a_y) \ominus (b_y \ominus a_y) \otimes (c_x \ominus a_x)" title="Floating point rotation">  . <br><br>  Let's move from floating point arithmetic to real arithmetic: <br><br><img src="http://latex.codecogs.com/png.latex? \begin{align*} \tilde{v} &amp; = \bigl[(b_x - a_x)(c_y - a_y)(1 + \delta_1)(1 + \delta_2)(1 + \delta_3) \\ \quad{} &amp; \quad{ } - (b_y - a_y)(c_x - a_x)(1 + \delta_4)(1 + \delta_5)(1 + \delta_6)\bigr](1 + \delta_7).\end{align*}" title="Turn with an error in real arithmetic"><br><br>  Now we formulate a sufficient condition for the correctness of the calculation of the sign <img src="http://latex.codecogs.com/png.latex?\inline \tilde{v}:\ |\tilde{v} - v| \leq e &lt; |\tilde{v}|" title="The limit of the constant e from below">  .  Imagining a ball centered at <img src="http://latex.codecogs.com/png.latex?\inline \tilde{v}">  and radius <em>e</em> , we can verify that this condition is correct: the ball will not contain a zero point, therefore, all points of this ball will have one sign, including the point <em>v</em> .  It remains to estimate the difference modulus. <img src="http://latex.codecogs.com/png.latex?\inline |\tilde{v} - {v}|">  .  Open the brackets with deltas and recall that the difference module does not exceed the sum of the modules, and the product module is equal to the product of the modules: <br><br><img src="http://latex.codecogs.com/png.latex? |\tilde{v} - v| \leq \bigl(|(b_x - a_x)(c_y - a_y)| + |(b_y - a_y)(c_x - a_x)|\bigr) \times (4\varepsilon + 6\varepsilon^2 + 4\varepsilon^3 + \varepsilon^4)." title="The limit of the constant e from below"><br><br>  We have obtained the lower bound of the number <em>e</em> in real numbers, but <em>e</em> is a floating point number.  notice, that <br><br><img src="http://latex.codecogs.com/png.latex? \begin{align*}\bigl(|(b_x - a_x)(c_y - a_y)| + |(b_y - a_y)(c_x - a_x)|\bigr) \times (1 -\varepsilon)^4 \leq\: \qquad{ } \\ \qquad{ } \leq \: |(b_x \ominus a_x)\otimes(c_y \ominus a_y)| \oplus |(b_y \ominus a_y)\otimes(c_x \ominus a_x)|.\end{align*}"><br><br>  From here immediately follows: <br><br><img src="http://latex.codecogs.com/png.latex? \begin{align*} |\tilde{v} - v| \leq \bigl(|(b_x \ominus a_x)\otimes(c_y \ominus a_y)| \oplus |(b_y \ominus a_y)\otimes(c_x \ominus a_x)|\bigr) \times\: \qquad{} \\ \qquad{} \times \: \frac{(4\varepsilon + 6\varepsilon^2 + 4\varepsilon^3 + \varepsilon^4)}{(1 -\varepsilon)^4}.\end{align*}" title="The limit of the constant e from below"><br><br>  It‚Äôs easy to get a fraction limit from above: <br><br><img src="http://latex.codecogs.com/png.latex? \frac{(4\varepsilon + 6\varepsilon^2 + 4\varepsilon^3 + \varepsilon^4)}{(1 -\varepsilon)^4} \leq 8\varepsilon"><br><br>  This means that the constant <em>e</em> we need can be calculated as follows: <br><br><img src="http://latex.codecogs.com/png.latex? e = \bigl(|(b_x \ominus a_x)\otimes(c_y \ominus a_y)| \oplus |(b_y \ominus a_y)\otimes(c_x \ominus a_x)|\bigr) \times 8\varepsilon."><br><br>  Note that the last multiplication, although real, does not derive a number from a set of floating point numbers, since the multiplier is a power of two. <br><br>  <strong>UPD.</strong>  Thanks <a href="https://habrahabr.ru/users/portah/" class="user_link">Portah</a> and <a href="https://habrahabr.ru/users/fsgs/" class="user_link">fsgs</a> for the specified typo: the cross function returns not point_2, but double. <br>  <strong>UPD2.</strong>  <a href="https://habrahabr.ru/users/mrrl/" class="user_link">Mrrl</a> gave <a href="http://habrahabr.ru/blogs/programming/138168/">an example</a> when it makes sense to rebuild filters to increase performance. </div><p>Source: <a href="https://habr.com/ru/post/138168/">https://habr.com/ru/post/138168/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../138161/index.html">We will evaluate your activity. Inexpensively</a></li>
<li><a href="../138162/index.html">Using bat files to deploy applications</a></li>
<li><a href="../138163/index.html">Optimization ORDER BY - what many people forget</a></li>
<li><a href="../138164/index.html">Update WIN and add Unlim</a></li>
<li><a href="../138166/index.html">Ulteo is a free solution for delivering desktops</a></li>
<li><a href="../138170/index.html">IM + developers received funding of $ 10 million</a></li>
<li><a href="../138171/index.html">The history of computer viruses</a></li>
<li><a href="../138172/index.html">The most common structure of sentences in Russian according to the version of the library Flibusta</a></li>
<li><a href="../138173/index.html">UTF-8: Encoding and Decoding</a></li>
<li><a href="../138175/index.html">Hackers have treated NASA nobly</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>