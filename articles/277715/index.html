<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>D std.ndslice as a replacement for Python Numpy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preface: I have been writing in Python for more than 6 years and I can call myself a professional in this language. Recently I even wrote a book about...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>D std.ndslice as a replacement for Python Numpy</h1><div class="post__text post__text-html js-mediator-article">  Preface: <a href="http://jackstouffer.com/blog/nd_slice.html">I have been writing</a> in Python for more than 6 years and I can call myself a professional in this language.  Recently I even wrote a <a href="https://www.packtpub.com/web-development/mastering-flask">book</a> about him.  However, for the last 8 months I have switched to D and for 4 months I have been actively involved in the development of this language in terms of the expansion of the standard library Phobos.  I also participated in the code review of the std.ndslice module which will be discussed. <br><br>  std.ndslice as well as Numpy is designed to work with multidimensional arrays.  However, unlike Numpy, ndslice has an extremely low overhead as it is based on ranges (ranges) that are used in the regular library throughout.  Ranges can avoid unnecessary copying procedures, as well as allow you to beautifully organize lazy calculations. <br><br>  In this article I would like to tell about what advantages std.ndslice gives in comparison with Numpy. <br><a name="habracut"></a><br><h4>  Why should Python programmers look towards D? </h4><br>  Because D allows you to write almost the same simple and understandable code as Python, while this code will work much faster than Python code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The following example creates a range of numbers from 0 to 999 using the <code>iota</code> function (the analog in Python is called <code>xrange</code> ) and returns an array of 5x5x40. <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.range : iota; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.experimental.ndslice; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> slice = sliced(iota(<span class="hljs-number"><span class="hljs-number">1000</span></span>), <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); }</code> </pre> <br>  Although D is a statically typed language, and an explicit type indication increases the readability of the code so that it will be easier for Python programmers to use automatic typing using the <code>auto</code> keyword. <br><br>  The <code>sliced</code> function returns a multi-dimensional slice.  At the input, it can take as simple arrays as well as <code>ranges</code> .  As a result, we have a 5x5x40 cube consisting of numbers from 0 to 999. <br><br>  A few words about what Ranges is.  It is more correct to translate them into Russian as ranges.  Ranges allow us to describe the rules for sorting data of any data type, be it a class or a structure.  It's enough that you implement the function: <code>front</code> , which returns the first element of the range, <code>popFront</code> , which goes to the next element and <code>empty</code> returns a boolean value indicating that the looped sequence is empty.  <code>Ranges</code> allow you to perform lazy brute-force access to data as they are needed.  The concept of Ranges <a href="http://ddili.org/ders/d.en/ranges.html">is covered</a> in more detail <a href="http://ddili.org/ders/d.en/ranges.html">here</a> . <br><br>  Please note that no empty memory allocations!  This happens because <code>iota</code> also allows you to generate lazy ranges, and <code>sliced</code> in lazy mode also receives data from <code>iota</code> and processes them as it is received. <br><br>  As you can see, std.ndslice works a little differently than Numpy.  Numpy creates its own type for data, while std.ndslice represents a way to manipulate already existing data.  This allows you to use the same data in your entire program without wasting resources on useless memory allocation!  It is not difficult to guess that this is an extremely serious impact on the performance of your decisions. <br><br>  Let's look at the following example.  In it, we will retrieve data from <code>stdin</code> , filter only unique strings, sort them, and then return to <code>stdout</code> . <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.algorithm; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { stdin // <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> stdin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> a range .byLine(KeepTerminator.yes) .uniq // stdin <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span>, so we need a <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span> .map!(a =&gt; a.idup) .<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> .sort // stdout.lockingTextWriter() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> an output range, meaning <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> can be // inserted <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> it, which <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> will be sent <span class="hljs-keyword"><span class="hljs-keyword">to stdout</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>(stdout.lockingTextWriter()); }</code> </pre> <br>  For those who wish to more thoroughly understand the lazy generation of ranges, I recommend reading <a href="http://wiki.dlang.org/Component_programming_with_ranges">this</a> article. <br><br>  Since <code>slice</code> has three dimensions, this is a range that returns ranges of ranges (ranges of ranges).  This is clearly seen in the following example: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.range : iota; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio : writeln; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.experimental.ndslice; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> slice = sliced(iota(<span class="hljs-number"><span class="hljs-number">1000</span></span>), <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); foreach (item; slice) { writeln(item); } }</code> </pre> <br>  The result of his work will be as follows (three dots for short): <br><br><pre> <code class="hljs lua"><span class="hljs-string"><span class="hljs-string">[[0, 1, ... 38, 39], [40, 41, ... 78, 79], [80, 81, ... 118, 119], [120, 121, ... 158, 159], [160, 161, ... 198, 199]]</span></span> ... <span class="hljs-string"><span class="hljs-string">[[800, 801, ... 838, 839], [840, 841, ... 878, 879], [880, 881, ... 918, 919], [920, 921, ... 958, 959], [960, 961, ... 998, 999]]</span></span></code> </pre> <br>  The <code>foreach</code> works much like a <code>for</code> in Python.  However, in D you can use it both in C style and in Python cycle style, but without the hassle of <code>enumerate</code> or <code>xrange</code> . <br><br>  Using UFCS (Uniform Function Call Syntax) you can rewrite the code in the following manner: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.range : iota; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.experimental.ndslice; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> slice = <span class="hljs-number"><span class="hljs-number">1000.</span></span>iota.sliced(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); }</code> </pre> <br>  <a href="http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394">UFCS</a> allows <a href="http://www.drdobbs.com/cpp/uniform-function-call-syntax/232700394">you</a> to record a method call on a chain and write: <br><br><pre> <code class="hljs swift">a.<span class="hljs-keyword"><span class="hljs-keyword">func</span></span>(b)</code> </pre> <br>  instead: <br><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span></code> </pre> <br>  Let's now generate an empty project using the <a href="http://code.dlang.org/getting_started">dub</a> package manager.  With the command <code>dub init</code> and in the file <code>\source\app.d</code> we write: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.experimental.ndslice; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre> <br>  Currently <code>std.experimental.ndslice;</code>  located in the <code>std.experimental</code> section.  This does not mean that it is raw.  This means that he needs to insist. <br><br>  Now we will build the project with the command: <br><br><pre> <code class="hljs">dub</code> </pre> <br>  Module D ndslice is very similar to Numpy: <br><br><pre> <code class="hljs matlab">a = numpy.arange(<span class="hljs-number"><span class="hljs-number">1000</span></span>).<span class="hljs-built_in"><span class="hljs-built_in">reshape</span></span>((<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>)) b = a[<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span>]</code> </pre> <br>  Equivalently: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> a = <span class="hljs-number"><span class="hljs-number">1000</span></span>.iota.sliced(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">auto</span></span> b = a[<span class="hljs-number"><span class="hljs-number">2</span></span> .. $, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span> .. <span class="hljs-number"><span class="hljs-number">20</span></span>];</code> </pre> <br>  Now let's create a two-dimensional array and get the middle of each column. <br><br>  Python: <br><br><pre> <code class="hljs haskell"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy data = numpy.arange(100000).reshape((100, 1000)) means = numpy.mean(<span class="hljs-title"><span class="hljs-title">data</span></span>, <span class="hljs-title"><span class="hljs-title">axis</span></span>=0)</code> </pre> <br>  D: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.range; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.algorithm.iteration; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.experimental.ndslice; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> means = <span class="hljs-number"><span class="hljs-number">100</span></span>_000.iota .sliced(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>) .transposed .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>!(r =&gt; sum(r) / r.length) .<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; }</code> </pre> <br>  In order for this code not to work in lazy mode, I had to call the <code>array</code> method.  However, in a real application, the result will not be calculated until it is used in another part of the program. <br><br>  Currently, Phobos does not have built-in <a href="https://github.com/DlangScience/dstats">statistics</a> .  Therefore, the example uses a simple lambda to find the average value.  <code>map!</code> function <code>map!</code>  has an exclamation mark at the end.  This means that this is a template function.  It allows at the compilation stage to generate code based on the expression specified in its body.  Here's a good article on how the <a href="http://nomad.so/2013/07/templates-in-d-explained/">patterns</a> themselves <a href="http://nomad.so/2013/07/templates-in-d-explained/">in D work</a> . <br><br>  Although the D code is a bit more verbose than in Python, but thanks to the <code>map!</code>  the code will work with any input data that is a range.  While the Python code will only work with special arrays from Numpy. <br><br>  Here I must say that after carrying out this test, it turned out that Python lost D at times and after long discussions on Hacker News, I realized that I had made a mistake and the comparison was not entirely correct.  <code>iota</code> dynamically creates data that the <code>sliced</code> function <code>sliced</code> .  And accordingly, we don‚Äôt touch the memory until its last relocation.  Also D returns an array with a <code>long</code> data type while Numpy is from <code>double</code> .  As a result, I rewrote the code and brought the value of the array to 1,000,000 instead of 10,000. Here‚Äôs what happened: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.range : iota; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span> : <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.algorithm; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.datetime; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.conv : to; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.stdio; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>.experimental.ndslice; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> test_count = <span class="hljs-number"><span class="hljs-number">10</span></span>_000; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span>[] means; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] data; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f0</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ means = data .sliced(<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>) .transposed .<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>!(r =&gt; sum(r, <span class="hljs-number"><span class="hljs-number">0L</span></span>) / cast(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) r.length) .<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ data = <span class="hljs-number"><span class="hljs-number">1</span></span>_000_000.iota.<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> r = benchmark!(f0)(test_count); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f0Result = to!Duration(r[<span class="hljs-number"><span class="hljs-number">0</span></span>] / test_count); f0Result.writeln; }</code> </pre> <br>  Tests conducted on the 2015 MacBook Pro with a 2.9 GHz Intel Core Broadwell i5.  In Python, I used the <code>%timeit</code> function in D <code>std.datetime.benchmark</code> to measure speed.  Compiled everything using LDC v0.17 with the following keys: <code>ldmd2 -release -inline -boundscheck=off -O</code> .  Or if you are using a dub, then the equivalent of these keys will be the <code>dub --build=release-nobounds --compiler=ldmd2</code> options <code>dub --build=release-nobounds --compiler=ldmd2</code> . <br><br>  Here are the results of the first test: <br><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">Python</span></span>: <span class="hljs-number"><span class="hljs-number">145</span></span> ¬µs <span class="hljs-type"><span class="hljs-type">LDC</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> ¬µs <span class="hljs-type"><span class="hljs-type">D</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> 29x faster</code> </pre> <br>  Here is the test of the revised version: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Python</span></span>: 1<span class="hljs-selector-class"><span class="hljs-selector-class">.43</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">msec</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LDC</span></span>: 628 Œº<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">D</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">is</span></span> 2<span class="hljs-selector-class"><span class="hljs-selector-class">.27x</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">faster</span></span></code> </pre> <br>  Agree not very bad difference considering the fact that Numpy is written in C, and in D everyone scolds the garbage collector. <br><br><h4>  How can D avoid Numpy problems? </h4><br>  Yes Numpy is fast, but it is fast only in comparison with simple Python masises.  But the problem is that it is only partially compatible with these simple arrays. <br><br>  The Numpy library is somewhere to the side of the rest of Python.  She lives her life.  It uses its own functions, it works with its types.  For example, if we need to use an array created in Python in NumPy, we will need to use <code>np.asarray</code> which will copy it into a new variable.  A quick <a href="https://github.com/search%3Fl%3Dpython%26amp%3Bq%3Dnp.asarray%26amp%3Btype%3DCode%26amp%3Butf8%3D%25E2%259C%2593">search on github</a> showed that thousands of projects use this crutch.  While data could simply be transferred from one function to another without these blank copies. <br><br><pre> <code class="hljs lua">import numpy as np a = <span class="hljs-string"><span class="hljs-string">[[0.2,0.5,0.3], [0.2,0.5,0.3]]</span></span> p = np.asarray(a) y = np.asarray([<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre> <br>  Try to solve this problem by rewriting part of the standard Python library to use Numpy types.  However, this is still not a full-fledged solution, which leads to remarkable jokes when writing: <br><br><pre> <code class="hljs lisp">sum(<span class="hljs-name"><span class="hljs-name">a</span></span>)</code> </pre> <br>  instead: <br><br><pre> <code class="hljs pgsql">a.sum()</code> </pre> <br>  we get a 10x drop in speed. <br><br>  D has no such problems by design.  This is a compiled, statically typed language.  During code generation, all types of variables are known.  In std.ndslice itself, you get full access to all the functions of the Phobos library, for example, to such wonderful things as std.algorithm and std.range.  Oh yeah, at the same time you can use <a href="http://nomad.so/2013/07/templates-in-d-explained/">patterns D</a> that allow you to generate code right at the compilation stage. <br><br>  Here is an example: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.range : iota; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.algorithm.iteration : sum; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.experimental.ndslice; <span class="hljs-type"><span class="hljs-type">void</span></span> main() { auto <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> = <span class="hljs-number"><span class="hljs-number">1000.</span></span>iota.sliced(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>); auto result = <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> // sum expects an <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> range <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> numerical <span class="hljs-keyword"><span class="hljs-keyword">values</span></span>, so <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> one // we <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> std.experimental.ndslice.byElement <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> the unwound // range .byElement .sum; }</code> </pre> <br>  You take and just use the <code>sum</code> function and it just takes and works, just like any other function from the base library. <br><br>  In Python itself, in order to get a list of a specified length initialized with a specific value, we need to write: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">a</span></span> = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre> <br>  Numpy will be completely different: <br><br><pre> <code class="hljs matlab">a = numpy.<span class="hljs-built_in"><span class="hljs-built_in">zeros</span></span>((<span class="hljs-number"><span class="hljs-number">1000</span></span>))</code> </pre> <br>  And if you do not use Numpy, then your code will be 4 times slower, not counting the extra copy operation that eats memory.  In D, range comes in handy, which allows us to do the same operation quickly and without empty copy operations: <br><br><pre> <code class="hljs pgsql">auto a = repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>;</code> </pre> <br>  And if needed, we can immediately call ndslice: <br><br><pre> <code class="hljs pgsql">auto a = repeat(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1000</span></span>).<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>.sliced(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>);</code> </pre> <br>  The main advantage of Numpy at present is its prevalence.  Now it is used really very widely from banking systems to machine learning.  There are a lot of books, examples and articles on it.  However, the mathematical possibilities in D will obviously be expanded very soon.  So the author of ndslice <a href="">stated</a> that he is now working on BLAS (Basic Linear Algebra Subprograms) for Phobos, which will also be fully <a href="https://github.com/DlangScience/mir">integrated</a> with ndslice and with the standard library. <br><br>  A powerful mathematical subsystem will allow you to very effectively solve a number of tasks where you need to work with big data.  For example, a computer vision system.  The prototype of one of these systems is already being developed and is called <a href="https://github.com/ljubobratovicrelja/dcv">DCV</a> . <br><br><h4>  Image processing on D </h4><br>  The following example will show how the median filter works allowing you to eliminate noise in the image.  The <code>movingWindowByChannel</code> function can also be used in other filters where a sliding window is required.  <code>movingWindowByChannel</code> allows <code>movingWindowByChannel</code> to move around the image using a sliding window.  Each such window is passed to a filter that calculates pixel values ‚Äã‚Äãbased on the selected zone. <br><br>  This function does not handle zones with partial overlap.  However, it can be used to calculate the values ‚Äã‚Äãin them too.  To do this, create an enlarged image with the edges reflecting the borders of the original image and then process it. <br><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/** Params: filter = unary function. Dimension window 2D is the argument. image = image dimensions `(h, w, c)`, where  is the number of channels in the image nr = number of rows in the window n = number of columns in the window Returns: image dimensions `(h - nr + 1, w - nc + 1, c)`, where  is the number of channels in the image. Dense data layout is guaranteed. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>!(<span class="hljs-number"><span class="hljs-number">3</span></span>, C*) movingWindowByChannel(<span class="hljs-keyword"><span class="hljs-keyword">alias</span></span> <span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>, C) (<span class="hljs-keyword"><span class="hljs-keyword">Slice</span></span>!(<span class="hljs-number"><span class="hljs-number">3</span></span>, C*) image, size_t nr, size_t nc) { // <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> imports <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> D <span class="hljs-keyword"><span class="hljs-keyword">work</span></span> much <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> Python<span class="hljs-string"><span class="hljs-string">'s local imports, // meaning if your code never runs this function, these will // never be imported because this function wasn'</span></span>t compiled <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.algorithm.iteration: map; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>; // <span class="hljs-number"><span class="hljs-number">0.</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>D // The last dimension represents the color channel. auto wnds = image // <span class="hljs-number"><span class="hljs-number">1.</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>D composed <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>D // Packs the last dimension. .pack!<span class="hljs-number"><span class="hljs-number">1</span></span> // <span class="hljs-number"><span class="hljs-number">2.</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>D composed <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>D composed <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>D // Splits image <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> overlapping windows. .windows(nr, nc) // <span class="hljs-number"><span class="hljs-number">3.</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>D // Unpacks the windows. .unpack // <span class="hljs-number"><span class="hljs-number">4.</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>D // Brings the color channel dimension <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the third position. .transposed!(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) // <span class="hljs-number"><span class="hljs-number">5.</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>D Composed <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>D // Packs the last two dimensions. .pack!<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wnds // <span class="hljs-number"><span class="hljs-number">6.</span></span> Range composed <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>D // Gathers <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> windows <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the range. .byElement // <span class="hljs-number"><span class="hljs-number">7.</span></span> Range composed <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pixels // <span class="hljs-number"><span class="hljs-number">2</span></span>D <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> pixel lazy <span class="hljs-keyword"><span class="hljs-keyword">conversion</span></span>. .map!<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span> // <span class="hljs-number"><span class="hljs-number">8.</span></span> `C[]` // The <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> memory allocation <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>. .<span class="hljs-keyword"><span class="hljs-keyword">array</span></span> // <span class="hljs-number"><span class="hljs-number">9.</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>D // <span class="hljs-keyword"><span class="hljs-keyword">Returns</span></span> <span class="hljs-keyword"><span class="hljs-keyword">slice</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> corresponding shape. .sliced(wnds.shape); }</code> </pre> <br>  The following function is an example of how to calculate the median of an object.  The function is greatly simplified in order to increase readability. <br><br><pre> <code class="hljs pgsql"><span class="hljs-comment"><span class="hljs-comment">/** Params: r = input range buf = buffer with length no less than the number of elements in `r` Returns: median value over the range `r` */</span></span> T median(Range, T)(Range r, T[] buf) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.algorithm.sorting: sort; size_t n; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (e; r) { buf[n++] = e; } buf[<span class="hljs-number"><span class="hljs-number">0</span></span> .. n].sort(); <span class="hljs-keyword"><span class="hljs-keyword">immutable</span></span> m = n &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n &amp; <span class="hljs-number"><span class="hljs-number">1</span></span> ? buf[m] : cast(T)((buf[m - <span class="hljs-number"><span class="hljs-number">1</span></span>] + buf[m]) / <span class="hljs-number"><span class="hljs-number">2</span></span>); }</code> </pre> <br>  And now Main itself: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">void</span></span> main(string[] args) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.conv: <span class="hljs-keyword"><span class="hljs-keyword">to</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.getopt: getopt, defaultGetoptPrinter; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> std.path: stripExtension; // <span class="hljs-keyword"><span class="hljs-keyword">In</span></span> D, getopt <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> part <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the standard library uint nr, nc, def = <span class="hljs-number"><span class="hljs-number">3</span></span>; auto helpInformation = args.getopt( "nr", "number of rows in window, default value is " ~ def.<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>!string, &amp;nr, "nc", "number of columns in window, default value is equal to nr", &amp;nc); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (helpInformation.helpWanted) { defaultGetoptPrinter( "Usage: median-filter [&lt;options...&gt;] [&lt;file_names...&gt;]\noptions:", helpInformation.<span class="hljs-keyword"><span class="hljs-keyword">options</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nr) nr = def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nc) nc = nr; auto buf = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ubyte[nr * nc]; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-type"><span class="hljs-type">name</span></span>; args[<span class="hljs-number"><span class="hljs-number">1</span></span> .. $]) { <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> imageformats; // can be <span class="hljs-built_in"><span class="hljs-built_in">found</span></span> at code.dlang.org IFImage image = read_image(<span class="hljs-type"><span class="hljs-type">name</span></span>); auto ret = image.pixels .sliced(cast(size_t)image.h, cast(size_t)image.w, cast(size_t)image.c) .movingWindowByChannel !(<span class="hljs-keyword"><span class="hljs-keyword">window</span></span> =&gt; median(<span class="hljs-keyword"><span class="hljs-keyword">window</span></span>.byElement, buf)) (nr, nc); write_image( <span class="hljs-type"><span class="hljs-type">name</span></span>.stripExtension ~ "_filtered.png", ret.length!<span class="hljs-number"><span class="hljs-number">1</span></span>, ret.length!<span class="hljs-number"><span class="hljs-number">0</span></span>, (&amp;ret[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>])[<span class="hljs-number"><span class="hljs-number">0</span></span> .. ret.elementsCount]); } }</code> </pre> <br>  If not all the examples seemed clear to you, I recommend that you read the free version of the wonderful book <a href="http://ddili.org/ders/d.en/">Programming in D.</a> <br><br>  PS If you know how to translate this publication in the status of "translations", then write in private. <br></div><p>Source: <a href="https://habr.com/ru/post/277715/">https://habr.com/ru/post/277715/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../277703/index.html">Leona Philpot - ‚Äúunderwater‚Äù way to cool Microsoft data center</a></li>
<li><a href="../277705/index.html">Library development for iOS / Android on Golang</a></li>
<li><a href="../277707/index.html">10 habits of content developer.js</a></li>
<li><a href="../277711/index.html">C ++ SDK for Amazon Web Services</a></li>
<li><a href="../277713/index.html">Preparing for the CISA exam. Business Continuity Definitions</a></li>
<li><a href="../277717/index.html">LLVM: do-it-yourself compiler. Introduction</a></li>
<li><a href="../277721/index.html">Mesh router is easy</a></li>
<li><a href="../277723/index.html">Asymmetric solutions. ICS Information Security in Energy</a></li>
<li><a href="../277725/index.html">Microsoft Android emulator cooling beer with IoT and Windows 10 and The Maker Show for those who like to solder</a></li>
<li><a href="../277727/index.html">Another implementation of the is_function <T> metafunction for C ++ 98/03</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>