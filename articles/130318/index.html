<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Memory barriers and non-blocking synchronization in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In this article I want to talk about the use of some constructions that are used to implement non-blocking synchronization. It's about ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Memory barriers and non-blocking synchronization in .NET</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In this article I want to talk about the use of some constructions that are used to implement non-blocking synchronization.  It's about the volatile keyword, VolatileRead, VolatileWrite, and MemoryBarrier functions.  We will consider what problems force us to use these language constructs and their solutions.  When discussing memory barriers, let's briefly review the .NET memory model. <br><a name="habracut"></a><br><h4>  Compiler optimizations </h4><br>  The main problems that a programmer encounters when using non-blocking synchronization are optimizing the compiler and rearranging instructions by the processor. <br>  Let's start with an example when the compiler brings a problem into a multi-threaded program: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReorderTest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _a; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> task = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Task(Bar); task.Start(); Thread.Sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); _a = <span class="hljs-number"><span class="hljs-number">0</span></span>; task.Wait(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_a == <span class="hljs-number"><span class="hljs-number">1</span></span>) { } } }</code> </pre> <br>  By running this example, you can make sure that the program freezes.  The reason lies in the fact that the compiler caches the _a variable in the processor register. <br>  To solve such problems, C # provides the keyword volatile.  The use of this keyword to a variable forbids the compiler to optimize in any way the references to it. <br><br>  This is what the revised declaration for _a will look like. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _a;</code> </pre><br>  Disabling compiler optimizations is not the only effect of using this keyword.  Other effects will be discussed later. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Rearrangement of instructions </h4><br>  Consider now the case when the source of problems is the rearrangement of instructions by the processor. <br>  Let there be the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReorderTest2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _a = <span class="hljs-number"><span class="hljs-number">1</span></span>; _b = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_b == <span class="hljs-number"><span class="hljs-number">1</span></span>) { Console.WriteLine(_a); } } }</code> </pre><br>  Procedures Foo and Bar run simultaneously from different threads. <br>  Is this code correct, that is, can we say with confidence that the program will never output zero?  If we were talking about single-threaded programs, then to check this code it would be enough to run it once.  But, since we are dealing with multithreading, this is not enough.  Instead, we need to understand whether we have guarantees that the program will work correctly. <br><br><h5>  .NET memory model </h5><br>  As already mentioned, the incorrect behavior of a multithreaded program can be caused by permutations of instructions on the processor.  Consider this problem in more detail. <br>  Any modern processor can swap memory read and write instructions for optimization.  Let me explain this with an example. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = _a; _b = <span class="hljs-number"><span class="hljs-number">10</span></span>;</code> </pre><br>  In this code, the variable _a is first read, then _b is written.  But when executing this program, the processor can rearrange read and write instructions, that is, the variable _b will be written first, and only then _a will be read.  For a single-threaded program, such a permutation does not matter, but for a multi-threaded program this can turn into a problem.  We have now reviewed the load-write permutation.  Similar permutations are possible for other combinations of instructions. <br><br>  The set of permutation rules of such instructions is called a memory model.  The .NET platform has its own memory model, which abstracts us from the memory models of a particular processor. <br>  This is the .NET memory model. <br><table><tbody><tr><td>  Permutation Type </td><td>  Permutation Allowed </td></tr><tr><td>  Download Download </td><td>  Yes </td></tr><tr><td>  Download Record </td><td>  Yes </td></tr><tr><td>  Write-load </td><td>  Yes </td></tr><tr><td>  Record record </td><td>  Not </td></tr></tbody></table><br>  Now we can consider our example from the point of view of the .NET memory model.  Since a write-write permutation is prohibited, writing to the _a variable will always occur before writing to the _b variable, and here the program will work correctly.  The problem is in the procedure Bar.  Since the permutation of reading instructions is not prohibited, the _b variable can be read before _a. <br>  After permutation, the code will be executed as if it were written as follows: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tmp = _a; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_b == <span class="hljs-number"><span class="hljs-number">1</span></span>) { Console.WriteLine(tmp); }</code> </pre><br>  When we talk about permutations of instructions, we mean the permutation of instructions of the same thread that read / write different variables.  If the same variable is written in different streams, then their order is random in any case.  And if we are talking about reading and writing the same variable, for example, like this: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = GetA(); UseA(a);</code> </pre><br>  it is clear that there can be no permutations here. <br><br><h5>  Memory barriers </h5><br>  To solve this problem, there is a universal method - adding a memory barrier (memory barrier, memory fence). <br>  There are several types of memory barriers: full, release fence and accure fence. <br>  A full barrier ensures that all reads and writes located before / after the barrier will also be executed before / after the barrier, that is, no memory access instruction can jump over the barrier. <br>  Now let's deal with two other types of barriers: <br>  Accure fence guarantees that the instructions after the barrier will not be moved to the position before the barrier. <br>  Release Fence ensures that instructions up to the barrier will not be moved to the position after the barrier. <br>  Just a couple of words about terminology.  The term volatile write means writing to memory in combination with the creation of a release fence.  The term volatile read means reading memory in combination with creating an accure fence. <br><br>  .NET provides the following methods of working with memory barriers: <br><ul><li>  Thread.MemoryBarrier () method creates a complete memory barrier </li><li>  the volatile keyword turns each operation on a variable marked with this word into volatile write or volatile read, respectively. </li><li>  Thread.VolatileRead () method performs volatile read </li><li>  Thread.VolatileWrite () method performs volatile write </li></ul><br>  Let's return to our example.  As we already understood, the problem may arise due to the rearrangement of reading instructions.  To solve it, we add a memory barrier between the readings _a and _b.  After that, we have a guarantee that the stream in which the Bar method is executed will see the records in the correct order. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReorderTest2</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _a; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _b; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _a = <span class="hljs-number"><span class="hljs-number">1</span></span>; _b = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_a == <span class="hljs-number"><span class="hljs-number">1</span></span>) { Thread.MemoryBarrier(); Console.WriteLine(_b); } } }</code> </pre><br>  Using the full memory barrier is redundant here.  To eliminate the permutation of reading instructions, it is sufficient to use volatile read while reading _a.  This can be achieved using the Thread.VolatileRead method or the volatile keyword. <br><br><h4>  Methods Thread.VolatileWrite and Thread.VolatileRead </h4><br>  Let's explore the Thread.VolatileWrite and Thread.VolatileRead methods in more detail. <br>  On MSDN, VolatileWrite is written: ‚ÄúWrites a value directly to a field, so that it becomes visible to all processors on the computer.‚Äù <br>  In fact, this description is not entirely correct.  These methods guarantee two things: the absence of compiler optimizations <sup>1</sup> and the absence of permutations of instructions in accordance with volatile read or write properties.  Strictly speaking, the VolatileWrite method does not guarantee that the value will immediately become visible to other processors, and the VolatileRead method does not guarantee that the value will not be read from cache <sup>2</sup> .  But due to the lack of optimizations of the code by the compiler and the <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25B3%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BD%25D1%2582%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_%25D0%25BA%25D1%258D%25D1%2588%25D0%25B0">coherence of the</a> processor caches, we can assume that the description from MSDN is correct. <br><br>  Consider how these methods are implemented: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VolatileRead</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> num = address; Thread.MemoryBarrier(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> num; } [MethodImpl(MethodImplOptions.NoInlining)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">VolatileWrite</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">ref</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { Thread.MemoryBarrier(); address = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; }</code> </pre><br>  What else can you see here? <br>  First, it uses a complete memory barrier.  As we said, volatile write should create a release fence.  Since release fence is a special case of a complete barrier, this implementation is correct, but redundant.  If there was a release fence, the processor / compiler would have more options for optimization.  Why the .NET development team implemented these functions precisely through a complete barrier is hard to say.  But it is important to remember that these are just the details of the current implementation, and no one guarantees that it will not change in the future. <br><br><h5>  Compiler and CPU Optimization </h5><br>  I want to note once again: both the volatile keyword and all three considered functions of installing memory barriers affect both processor optimization and compiler optimization. <br>  That is, for example, this code is a completely correct solution to the problem shown in the first example: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (_a == <span class="hljs-number"><span class="hljs-number">1</span></span>) { Thread.MemoryBarrier(); } }</code> </pre><br><br><h4>  Danger volatile </h4><br>  Looking at the implementation of the VolatileWrite and VolatileRead methods, it becomes clear that such a pair of instructions can be rearranged: <br><pre> <code class="cs hljs">Thread.VolatileWrite(b) Thread.VolatileRead(a)</code> </pre><br>  Since this behavior is inherent in the definition of volatile read and write terms, this is not a bug and operations with variables marked with the volatile keyword have a similar behavior. <br>  But in practice, this behavior may be unexpected. <br>  Consider an example: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _firstBool; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _secondBool; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _firstString; <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _secondString; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _okCount; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _failCount; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Program().Go(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Go</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { Parallel.Invoke(DoThreadA, DoThreadB); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_firstString == <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; _secondString == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { _failCount++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { _okCount++; } Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"ok - {0}, fail - {1}, fail percent - {2}"</span></span>, _okCount, _failCount, GetFailPercent()); Clear(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetFailPercent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)_failCount / (_okCount + _failCount) * <span class="hljs-number"><span class="hljs-number">100</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _firstBool = <span class="hljs-number"><span class="hljs-number">0</span></span>; _secondBool = <span class="hljs-number"><span class="hljs-number">0</span></span>; _firstString = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; _secondString = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoThreadA</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _firstBool = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//Thread.MemoryBarrier(); if (_secondBool == 1) { _firstString = "a"; } } private void DoThreadB() { _secondBool = 1; //Thread.MemoryBarrier(); if (_firstBool == 1) { _secondString = "a"; } } }</span></span></code> </pre><br>  If the instructions of the program would be executed exactly in the order in which they are defined, then at least one line would always turn out to be equal to ‚Äúa‚Äù.  In fact, due to the rearrangement of instructions, this is not always the case.  Replacing the volatile keyword with the appropriate methods, as expected, does not change the result. <br>  To correct the behavior of this program, it is enough to uncomment lines with full memory barriers. <br><br><h4>  Performance Thread.Volatile * and volatile keyword </h4><br>  On most platforms (more precisely, on all platforms supported by Windows, except for the dying IA64), all writing and reading are volatile write and volatile read, respectively.  Thus, at run time, the volatile keyword has no effect on performance.  In contrast, the Thread.Volatile * methods, first, bear the overhead of the method call itself, labeled MethodImplOptions.NoInlining, and, second, in the current implementation, they create a complete memory barrier.  That is, in terms of performance, in most cases the use of a keyword is preferable. <br><hr><br><h4>  Links </h4><br>  <sup>1</sup> See page 514 by Joe Duffy.  Concurrent Programming on Windows <br>  <sup>2</sup> See <a href="https://connect.microsoft.com/VisualStudio/feedback/details/94808/volatilewrite-implemented-incorrectly">VolatileWrite implemented incorrectly</a> <br><br><h4>  Used literature: </h4><br><ol><li>  Joseph Albahari.  <a href="http://www.albahari.com/threading/part4.aspx">Threading in C #</a> </li><li>  Vance Morrison.  <a href="http://msdn.microsoft.com/en-us/magazine/cc163715.aspx">Understand the Impact of Low-Lock Techniques in Multithreaded Apps</a> </li><li>  Pedram Rezaei.  <a href="http://blogs.msdn.com/b/pedram/archive/2007/12/28/clr-2-0-memory-model.aspx">CLR 2.0 memory model</a> </li><li>  MS Connect: <a href="https://connect.microsoft.com/VisualStudio/feedback/details/94808/volatilewrite-implemented-incorrectly">VolatileWrite implemented incorrectly</a> </li><li>  <a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-335.pdf">ECMA-335 Common Language Infrastructure (CLI)</a> </li><li>  <a href="http://msdn.microsoft.com/en-us/library/ms228593.aspx">C # Language Specification</a> </li><li>  Jeffrey Richter.  CLR via C # Third Edition </li><li>  Joe duffy  Concurrent Programming on Windows </li><li>  Joseph Albahari.  C # 4.0 in a nutshell </li></ol></div><p>Source: <a href="https://habr.com/ru/post/130318/">https://habr.com/ru/post/130318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../130312/index.html">Applications of other mobile OS can be ported to Windows Phone</a></li>
<li><a href="../130313/index.html">Google+ now supports real-time search and hashtags</a></li>
<li><a href="../130314/index.html">Google+ has instant search and support # hashtags</a></li>
<li><a href="../130316/index.html">Intel HD Graphics P3000 Workstation - Comparison and Application</a></li>
<li><a href="../130317/index.html">Mobile and tablet future of Flash looks less and less radiant</a></li>
<li><a href="../130319/index.html">Background upload lists</a></li>
<li><a href="../130320/index.html">Configuring Replication in SQL 2008</a></li>
<li><a href="../130321/index.html">We're saving ourselves from the paper flood, or how to spend the International Day without paper.</a></li>
<li><a href="../130323/index.html">"Bloated code" in commercial software development</a></li>
<li><a href="../130325/index.html">9 rules how to protect your Asterisk!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>