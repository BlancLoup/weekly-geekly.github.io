<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a game on Lua and L√ñVE - 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents  Table of contents 


- Article 1 Part 1. Game cycle Part 2. Libraries Part 3. Rooms and areas Part 4. Exercises 
- Part 1. Game cyc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a game on Lua and L√ñVE - 6</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/625/305/a37/625305a37f81962551aed8611bab6bda.jpg" alt="image"></div><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><h2>  Table of contents </h2><br><ul><li>  <a href="https://habrahabr.ru/post/349276/">Article 1</a> <ul><li>  Part 1. Game cycle </li><li>  Part 2. Libraries </li><li>  Part 3. Rooms and areas </li><li>  Part 4. Exercises </li></ul></li><li>  <a href="https://habrahabr.ru/post/349440/">Article 2</a> <ul><li>  Part 5. Basics of the game </li><li>  Part 6. Basics of the Player Class </li></ul></li><li>  <a href="https://habrahabr.ru/post/349718/">Article 3</a> <ul><li>  Part 7. Player Parameters and Attacks </li><li>  Part 8. Enemies </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 4</a> <ul><li>  Part 9. Director and game cycle </li><li>  Part 10. Code Writing Practices </li><li>  Part 11. Passive skills </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 5</a> <ul><li>  Part 12. Other Passive Skills </li></ul></li><li>  <a href="https://habrahabr.ru/post/352896/">Article 5</a> <ul><li>  Part 13. The skill tree </li></ul></li></ul><br>  14. Console <br><br>  15. Final </div></div><br><h2>  Part 13: The skill tree </h2><br><h2>  Introduction </h2><br>  In this part of the article we will focus on creating a tree of skills.  <a href="https://streamable.com/9bj59" rel="nofollow">Here is what it looks like now</a> .  We will not locate each node manually (I will leave this as an exercise), but consider everything necessary for the implementation and proper operation of the tree of skills. <br><br>  First, we will look at how to set each node, then learn how to read these definitions, create the necessary objects, and apply appropriate passive skills to the player.  Then we move on to the main objects (nodes and links), and then consider saving and loading the tree.  And at the end we implement the functionality necessary for the player to spend skill points on tree nodes. <br><a name="habracut"></a><br><h2>  Skill tree </h2><br>  A skill tree can be defined in many different ways, each with its own advantages and disadvantages.  We can choose from about three options: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Create a skill tree editor that places, connects and determines the parameters of each node visually; </li><li>  Create a skill tree editor that places and links nodes visually, but defines the parameters for each node in a text file; </li><li>  Define everything in a text file. </li></ul><br>  I am one of those people who want to make implementation as easy as possible and who have no problems with doing a large amount of manual and boring work, so I usually solve problems in this way.  That is, of the three options proposed above, I tend to the third. <br><br>  For the first two options, we would need to create a visual skill tree editor.  To understand what this entails, we must try to list the high-level functions that the visual editor of the skill tree must have: <br><br><ul><li>  Placement of new nodes </li><li>  Tying nodes together </li><li>  Deleting nodes </li><li>  Moving nodes </li><li>  Text input to define the parameters of each node </li></ul><br>  I only thought of these high-level features that imply other functions: <br><br><ul><li>  The nodes are likely to somehow align with each other, that is, we need some sort of alignment system.  Perhaps the nodes can be placed only in accordance with a certain grid system. </li><li>  Linking, deleting, and moving nodes implies that we need to be able to select certain nodes to which we want to apply such actions.  This means that we also have to implement the node selection function. </li><li>  If we choose the option in which the parameters are determined visually, then text input is required.  You can organize the correct operation of the TextInput element in L√ñVE in several ways, with a little effort ( <a href="https://github.com/keharriso/love-nuklear">github.com/keharriso/love-nuklear</a> ), so we only need to add the logic of the display of the text input element and read information from it after writing. </li></ul><br>  As you can see, adding the skill tree editor does not seem like a lot of work compared to what we have already done.  Therefore, if you want to choose this option, then it is quite viable and can in your case improve the process of creating a tree of skills.  But as I said, I usually have no problems with performing large volumes of manual and boring work, that is, I can easily determine everything in a text file.  Therefore, in this article we will not implement any skill tree editor and fully define it in a text file. <br><br><h2>  Tree definition </h2><br>  So, to start defining a tree, we need to think about what elements the node consists of: <br><br><ul><li>  Passive skill text: <br><ul><li>  Title </li><li>  Parameters that can be changed (6% Increased HP, +10 Max Ammo, etc.) </li></ul></li><li>  Position </li><li>  Attached nodes </li><li>  Node type (normal, medium or large) </li></ul><br>  An example of a ‚Äú4% Increased HP‚Äù node is shown in the gif below: <br><br><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath131.gif"></div><br>  For example, it may have the following definition: <br><br><pre><code class="lua hljs">tree[<span class="hljs-number"><span class="hljs-number">10</span></span>] = { name = <span class="hljs-string"><span class="hljs-string">'HP'</span></span>, stats = { {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span> = <span class="hljs-number"><span class="hljs-number">0.04</span></span>} } x = <span class="hljs-number"><span class="hljs-number">150</span></span>, y = <span class="hljs-number"><span class="hljs-number">150</span></span>, links = {<span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> = <span class="hljs-string"><span class="hljs-string">'Small'</span></span>, }</code> </pre> <br>  We believe that <code>(150, 150)</code> is a suitable position, and the positions in the <code>tree</code> table of the nodes associated with it are 4, 6, and 8 (the position of the node is 10, since it is defined in the <code>tree[10]</code> ).  Thus, we can easily define hundreds of tree nodes, pass this huge table to a certain function that considers it, creates Node objects and associates them in an appropriate way, after which we can apply any necessary logic to the tree. <br><br><h2>  Nodes and Camera </h2><br>  Now that we have an idea of ‚Äã‚Äãhow the tree file will look like, we can begin the implementation on this basis.  The first thing we need is to create a new room <code>SkillTree</code> and then use <code>gotoRoom</code> to go into it at the beginning of the game (because now we will work in it).  The basics of this room will be the same as that of the Stage room, so I will assume that you will manage to create it yourself. <br><br>  We will define two nodes in the <code>tree.lua</code> file, but for now we will do it only by their position.  Our goal is to read these nodes from a file and create them in the SkillTree room.  We can define them as follows: <br><br><pre> <code class="lua hljs">tree = {} tree[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>} tree[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">32</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre> <br>  And we can consider them as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.nodes = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(tree) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.nodes, Node(node.x, node.y)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we believe that all objects of our SkillTree will not be inside the Area, that is, we do not need to use <code>addGameObject</code> to add a new game object to the environment.  It also means that we will need to track existing objects on our own.  In this case, we do this in the <code>nodes</code> table.  The <code>Node</code> object looks like this: <br><br><pre> <code class="lua hljs">Node = Object:extend() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span></span> self.x, self.y = x, y <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(default_color) love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, self.x, self.y, <span class="hljs-number"><span class="hljs-number">12</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  This is a simple object that does not extend the capabilities of GameObject at all.  For now, we‚Äôll just draw in his position as a circle.  If we go around the list of <code>nodes</code> and call update / draw for each node that is in it, assuming the camera is fixed at position <code>0, 0</code> (unlike the Stage room, where it is fixed at <code>gw/2, gh/2</code> ) then it should look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1a/ba0/98e/e1aba098e17fc9bd7003ee862de2d9c7.png"></div><br>  As expected, we see here both nodes that are defined in the tree file. <br><br><h3>  Camera </h3><br>  For the skill tree to work properly, we need to change the camera's work slightly.  As long as we have the same behavior as in the Stage room, then the camera is simply tied to the position and does not do anything interesting.  But in SkillTree, we want the camera to move with the mouse, and the player can move it away (and zoom in back), so that we can see most of the tree at the same time. <br><br>  To move the camera, we want to make sure that when the player holds the left mouse button and drags the screen, it moves in the opposite direction.  That is, when the player holds the button and moves the mouse up, we want the camera to move down.  The easiest way to achieve this is by tracking the position of the mouse in the previous frame, as well as in the current frame, and then moving in the direction opposite to the vector <code>current_frame_position - previous_frame_position</code> .  It all looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:down(<span class="hljs-string"><span class="hljs-string">'left_click'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> mx, my = camera:getMousePosition(sx, sy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sx*gw, sy*gh) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> dx, dy = mx - self.previous_mx, my - self.previous_my camera:move(-dx, -dy) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.previous_mx, self.previous_my = camera:getMousePosition(sx, sy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sx*gw, sy*gh) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  If you check, then everything will work as intended.  Note that <code>camera:getMousePosition</code> slightly changed compared <a href="http://hump.readthedocs.io/en/latest/camera.html" rel="nofollow">to the default functionality</a> , since we work with the canvas in a different way than the library expects.  I changed it a long time ago, so I don‚Äôt remember why I did it, so I‚Äôll just leave it at that.  But if you're curious, then it is worth considering this in more detail and figuring out whether to do it this way, or there is a way to use the default camera module without changes. <br><br>  As far as distance / approximation is concerned, we simply change the camera's <code>scale</code> property when scrolling the mouse wheel up / down: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SKillTree:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:pressed(<span class="hljs-string"><span class="hljs-string">'zoom_in'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.timer:tween(<span class="hljs-string"><span class="hljs-string">'zoom'</span></span>, <span class="hljs-number"><span class="hljs-number">0.2</span></span>, camera, {scale = camera.scale + <span class="hljs-number"><span class="hljs-number">0.4</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:pressed(<span class="hljs-string"><span class="hljs-string">'zoom_out'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.timer:tween(<span class="hljs-string"><span class="hljs-string">'zoom'</span></span>, <span class="hljs-number"><span class="hljs-number">0.2</span></span>, camera, {scale = camera.scale - <span class="hljs-number"><span class="hljs-number">0.4</span></span>}, <span class="hljs-string"><span class="hljs-string">'in-out-cubic'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we use a timer to make the scaling a bit smoother and look better.  In addition, we give both timers the same <code>'zoom'</code> id, because we want one tween to stop when we start the other.  The only thing that remains in this code snippet is the addition of lower and upper scale limits, because we do not want it, for example, to go below. <br><br><h2>  Links and Parameters </h2><br>  Thanks to the previous code, we can add nodes and move through the tree.  Now we will look at connecting nodes and displaying their parameters. <br><br>  To link the nodes, we will create a <code>Line</code> object, and this Line object will receive in its constructors the <code>id</code> two nodes it connects.  <code>id</code> denotes the index of the node in the <code>tree</code> object.  That is, a node created from <code>tree[2]</code> will have <code>id = 2</code> .  We can modify the Node object as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id, x, y)</span></span></span></span> self.id = id self.x, self.y = x, y <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And we can create a Line object like this: <br><br><pre> <code class="lua hljs">Line = Object:extend() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Line:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node_1_id, node_2_id)</span></span></span></span> self.node_1_id, self.node_2_id = node_1_id, node_2_id self.node_1, self.node_2 = tree[node_1_id], tree[node_2_id] <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Line:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Line:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(default_color) love.graphics.line(self.node_1.x, self.node_1.y, self.node_2.x, self.node_2.y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we use the passed identifiers to get the corresponding nodes and save to <code>node_1</code> and <code>node_2</code> .  Then we simply draw a line between the positions of these nodes. <br><br>  Now in the SkillTree room we need to create Line objects based on the <code>links</code> table of each node in the tree.  Suppose we have a tree that looks like this: <br><br><pre> <code class="lua hljs">tree = {} tree[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, links = {<span class="hljs-number"><span class="hljs-number">2</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">32</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, links = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">32</span></span>, y = <span class="hljs-number"><span class="hljs-number">32</span></span>, links = {<span class="hljs-number"><span class="hljs-number">2</span></span>}}</code> </pre> <br>  We want node 1 to be connected to node 2, node 2 to be connected to node 1 and 3, and node 3 to be connected to node 2. From the point of view of implementation, we must go through each node and each of its links, and then Based on these relationships, create Line objects. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.nodes = {} self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span> = {} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(tree) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.nodes, Node(id, node.x, node.y)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(tree) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, linked_node_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(node.links) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>, Line(id, linked_node_id)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The last thing we can do here is draw the nodes using the <code>'fill'</code> mode, otherwise, the lines will be superimposed on the nodes and will be issued a little: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setColor(background_color) love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, self.x, self.y, self.r) love.graphics.setColor(default_color) love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, self.x, self.y, self.r) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And after that, everything should look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8f/ab6/3bb/d8fab63bb5577f5dab1b232ee74f4a20.png"></div><br><hr><br>  We now turn to the parameters: let's say we have such a tree: <br><br><pre> <code class="lua hljs">tree[<span class="hljs-number"><span class="hljs-number">1</span></span>] = { x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = { <span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>, <span class="hljs-string"><span class="hljs-string">'4% Increased Ammo'</span></span>, <span class="hljs-string"><span class="hljs-string">'ammo_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span> }, links = {<span class="hljs-number"><span class="hljs-number">2</span></span>} } tree[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">32</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'6% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">32</span></span>, y = <span class="hljs-number"><span class="hljs-number">32</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">2</span></span>}}</code> </pre> <br>  We want to achieve the following: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8e/f69/ffa/e8ef69ffa0c022150b07851a7b5a9322.gif"></div><br>  Regardless of distance or approximation, when the user hovers the mouse over a node, he must display his parameters in a small rectangle. <br><br>  The first thing we can do is find out if the player hovers over the node or not.  The easiest way to do this is to check whether the position of the mouse is inside the rectangle defining each node: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> mx, my = camera:getMousePosition(sx*camera.scale, sy*camera.scale, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sx*gw, sy*gh) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> mx &gt;= self.x - self.w/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> mx &lt;= self.x + self.w/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> my &gt;= self.y - self.h/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> my &lt;= self.y + self.h/<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.hot = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.hot = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  For each node, the width and height are determined, so we will check whether the position of the <code>mx, my</code> mouse is inside the rectangle defined by its width and height.  If so, then we set <code>hot</code> to true, otherwise false.  That is, <code>hot</code> is just a boolean, telling us if the cursor is pointing at a node. <br><br>  We now turn to drawing a rectangle.  We want to draw a rectangle on top of everything that is on the screen, so we cannot do it in the Node class, since each node is drawn sequentially and our rectangle can sometimes end up under one node or another.  Therefore, I do it directly in the room SkillTree.  It is also important that we do this outside the <code>camera:attach</code> and <code>camera:detach</code> block, because we want the size of this rectangle to remain the same regardless of the scale. <br><br>  Its basis is as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setCanvas(self.main_canvas) love.graphics.clear() ... camera:detach() <span class="hljs-comment"><span class="hljs-comment">-- Stats rectangle local font = fonts.m5x7_16 love.graphics.setFont(font) for _, node in ipairs(self.nodes) do if node.hot then -- Draw rectangle and stats here end end love.graphics.setColor(default_color) love.graphics.setCanvas() ... end</span></span></code> </pre> <br>  Before drawing a rectangle, we need to find out its width and height.  The width depends on the size of its longest parameter, because by definition the rectangle must be larger than it.  To do this, we will try to do something like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.nodes) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.hot <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> stats = tree[node.id].stats <span class="hljs-comment"><span class="hljs-comment">-- Figure out max_text_width to be able to set the proper rectangle width local max_text_width = 0 for i = 1, #stats, 3 do if font:getWidth(stats[i]) &gt; max_text_width then max_text_width = font:getWidth(stats[i]) end end end end ... end</span></span></code> </pre> <br>  The variable <code>stats</code> will contain a list of parameters for the current node.  That is, if we go through the <code>tree[2]</code> node, then the <code>stats</code> will matter <code>{'4% Increased HP', 'hp_multiplier', 0.04, '4% Increased Ammo', 'ammo_multiplier', 0.04}</code> .  The parameter table is always divided into three elements.  The first is the visual description of the parameter, then comes the variable that changes the Player object, and then the value of this effect.  We only need a visual description, that is, we have to go through the table with an increment of 3, which we do in the for loop shown above. <br><br>  After that we need to find the width of the string, taking into account the font used, and for this we use <a href="https://love2d.org/wiki/Font:getWidth" rel="nofollow"><code>font:getWidth</code></a> .  The maximum width of all our parameters will be stored in the variable <code>max_text_width</code> , after which we can proceed to drawing the rectangle: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.nodes) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.hot <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Draw rectangle local mx, my = love.mouse.getPosition() mx, my = mx/sx, my/sy love.graphics.setColor(0, 0, 0, 222) love.graphics.rectangle('fill', mx, my, 16 + max_text_width, font:getHeight() + (#stats/3)*font:getHeight()) end end ... end</span></span></code> </pre> <br>  We want to draw a rectangle at the position of the mouse, except that we do not need to use <code>camera:getMousePosition</code> , because we do not take into account camera transformations.  However, we cannot simply use <code>love.mouse.getPosition</code> directly, because the canvas is scaled to <code>sx, sy</code> , that is, the mouse position returned by the L√ñVE function is incorrect if the scale of the game is different from 1. Therefore, to get the right value, we need to divide this position on the scale. <br><br>  Having obtained the correct position, we can draw a rectangle with a width of <code>16 + max_text_width</code> , which gives us a border of 8 pixels on each side, and a height of <code>font:getHeight() + (#stats/3)*font:getHeight()</code> .  The first element of this formula ( <code>font:getHeight()</code> ) is used for the same purpose as 16 in the width calculation, that is, it gives the value for the border.  In our case, the upper and lower bounds of the rectangle will be equal to <code>font:getHeight()/2</code> .  The second part is simply the height occupied by each line of parameters.  Since the parameters are grouped in three, it is logical to consider each parameter as <code>#stats/3</code> , and then multiply this number by the height of the line. <br><br>  The last thing to do is draw the text.  We know that the x position of all texts will be equal to <code>8 + mx</code> , because we decided that there would be a border of 8 pixels on each side.  And we also know that the position of the first text in y will be equal to <code>my + font:getHeight()/2</code> , because we decided that the border at the top and bottom will be equal to <code>font:getHeight()/2</code> .  We only need to figure out how to draw a few lines, but we already know this because we chose the height of the rectangle to be <code>(#stats/3)*font:getHeight()</code> .  This means that each line is drawn <code>1*font:getHeight()</code> , <code>2*font:getHeight()</code> and so on.  It all looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.nodes) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.hot <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-comment"><span class="hljs-comment">-- Draw text love.graphics.setColor(default_color) for i = 1, #stats, 3 do love.graphics.print(stats[i], math.floor(mx + 8), math.floor(my + font:getHeight()/2 + math.floor(i/3)*font:getHeight())) end end end ... end</span></span></code> </pre> <br>  And so we get the result we need.  If you look at the whole code, it looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> love.graphics.setCanvas(self.main_canvas) love.graphics.clear() ... <span class="hljs-comment"><span class="hljs-comment">-- Stats rectangle local font = fonts.m5x7_16 love.graphics.setFont(font) for _, node in ipairs(self.nodes) do if node.hot then local stats = tree[node.id].stats -- Figure out max_text_width to be able to set the proper rectangle width local max_text_width = 0 for i = 1, #stats, 3 do if font:getWidth(stats[i]) &gt; max_text_width then max_text_width = font:getWidth(stats[i]) end end -- Draw rectangle local mx, my = love.mouse.getPosition() mx, my = mx/sx, my/sy love.graphics.setColor(0, 0, 0, 222) love.graphics.rectangle('fill', mx, my, 16 + max_text_width, font:getHeight() + (#stats/3)*font:getHeight()) -- Draw text love.graphics.setColor(default_color) for i = 1, #stats, 3 do love.graphics.print(stats[i], math.floor(mx + 8), math.floor(my + font:getHeight()/2 + math.floor(i/3)*font:getHeight())) end end end love.graphics.setColor(default_color) love.graphics.setCanvas() ... end</span></span></code> </pre> <br>  And I know that if I had seen such a code a few years ago, I wouldn‚Äôt like it very much.  It looks ugly, disordered, and sometimes confusing, but from my experience, stereotypical rendering code in game development looks like this.  Everywhere there are a lot of small and seemingly random numbers, a lot of different problems instead of a whole piece of code, and so on.  Today I‚Äôve gotten used to this type of code and it‚Äôs not annoying me anymore, and I advise you to get used to it too, because if you try to make it cleaner, then in my experience it will only lead to more confusing and less intuitive solutions. <br><br><h2>  Gameplay </h2><br>  Now that we can arrange nodes and connect them together, we need to encode the logic of buying nodes.  A tree will have one or several ‚Äúentry points‚Äù from which a player can start buying nodes, and from which he can only buy nodes adjacent to already purchased ones.  For example, in my scheme there is a central initial node, which do not give any bonuses, with which four additional nodes are connected that make up the beginning of the tree: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/301/d71/218/301d71218f1f91d18ab491e21c0cf295.png"></div><br>  Suppose now that we have a tree that initially looks like this: <br><br><pre> <code class="lua hljs">tree = {} tree[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, links = {<span class="hljs-number"><span class="hljs-number">2</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">48</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">3</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">96</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'6% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.06</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">4</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">144</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>}}</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/9eb/036/38e9eb036c474d75e19b268f866ab89a.png"></div><br>  The first thing we need is to make this node 1 already activated, while others are not.  By activated node, I mean that it is already purchased by the player and its effects are applied in the gameplay.  Since node 1 has no effects, in this way we can create a ‚Äúsource node‚Äù from which the tree will grow. <br><br>  We will do this through the global <code>bought_node_indexes</code> table, which will simply contain a bunch of numbers pointing to the tree nodes that have already been bought.  In our case, we simply add <code>1</code> to it, that is, the <code>tree[1]</code> will be active.  We also need to slightly change nodes and links graphically so that we can more easily see which ones are active and which ones are not.  For now, we will simply display blocked nodes in gray (with alpha = 32 instead of 255), and not white: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fn.any(bought_node_indexes, self.id) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.bought = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.bought = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r, g, b = <span class="hljs-built_in"><span class="hljs-built_in">unpack</span></span>(default_color) love.graphics.setColor(background_color) love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, self.x, self.y, self.w) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.bought <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> love.graphics.circle(<span class="hljs-string"><span class="hljs-string">'line'</span></span>, self.x, self.y, self.w) love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And for links: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Line:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fn.any(bought_node_indexes, self.node_1_id) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> fn.any(bought_node_indexes, self.node_2_id) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.active = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> self.active = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Line:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r, g, b = <span class="hljs-built_in"><span class="hljs-built_in">unpack</span></span>(default_color) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">32</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> love.graphics.line(self.node_1.x, self.node_1.y, self.node_2.x, self.node_2.y) love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  We activate the line only when both its nodes are purchased, which looks logical.  If we say in the room designer SkillTree <code>bought_node_indexes = {1}</code> , we get something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/2df/bf4/9592dfbf4200906c496aaa021aa537de.png"></div><br>  And if we say that <code>bought_node_indexes = {1, 2}</code> , then we get this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/379/cfa/b3f/379cfab3f38f2b00147ec87d59985046.png"></div><br>  And everything works as we expected.  Now we want to add the logic necessary so that when a node is clicked, it is bought, if it is connected to another node that has already been purchased.  Determining whether we have enough skill points to purchase a node and adding a confirmation step before purchasing a node will be left for the exercises. <br><br>  Before we make it possible to buy nodes that are connected to already purchased ones, we need to fix a small problem with how we define our tree.  Now we have the following definition: <br><br><pre> <code class="lua hljs">tree = {} tree[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, links = {<span class="hljs-number"><span class="hljs-number">2</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">48</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">3</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">96</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'6% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.06</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">4</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">144</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>}}</code> </pre> <br>  One of the problems of this definition is its unidirectionality.  And this was logical to expect, since if it were not unidirectional, then we would have to define connections between several nodes many times: <br><br><pre> <code class="lua hljs">tree = {} tree[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, links = {<span class="hljs-number"><span class="hljs-number">2</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">48</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">96</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'6% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.06</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">144</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>, links = {<span class="hljs-number"><span class="hljs-number">3</span></span>}}}</code> </pre> <br>  And although in such an implementation there is no particularly big problem, we can make it so that it is enough to define the connections only once (in any direction), and then apply an operation that automatically makes the connections determined in the opposite direction. <br><br>  We can do this by walking through the list of all nodes, and then through all the connections of each node.  For each link found, we go to the corresponding node and add the current node to its links.  For example, if we are in node 1 and see that it is associated with 2, then we go to node 2 and add node 1 to its list of links. Thus, we guarantee that when we have a definition in one direction, there will be a definition and in the opposite direction.  In code, it looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.tree = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.copy(tree) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.tree) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, linked_node_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(node.links <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> {}) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.tree[linked_node_id], id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  First, it‚Äôs worth noting that instead of using the global variable <code>tree</code> we copy it locally to the <code>self.tree</code> attribute, and then use this attribute.  In the objects SkillTree, Node and Line we have to replace the references to the global <code>tree</code> local attribute <code>tree</code> SkillTree.  We have to do this because we will change the definition of the tree, adding the numbers of certain nodes to the relationship table, and in the general case (for the reasons explained in Part 10), we do not want to change global variables in this way.  This means that every time we enter the SkillTree room, we copy the global definition to a local one and use the local definition in the code. <br><br>  With this in mind, we will now go through all the nodes of the tree and create node feedbacks.  It is important to use <code>ipairs</code> <code>node.links or {}</code> inside the call, because a link table can be defined for some nodes.  It is also important to note that we do this before creating Node and Line objects, although this is not necessary. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, it should be noted here that sometimes the table </font></font><code>links</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will contain duplicate values. </font><font style="vertical-align: inherit;">Depending on the way the table is defined, </font></font><code>tree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we will sometimes have nodes bidirectionally, that is, the links will already be where they should be. </font><font style="vertical-align: inherit;">This is actually not a problem, except that it can lead to the creation of multiple Line objects. </font><font style="vertical-align: inherit;">To prevent this, we can re-walk the tree and make sure that all tables </font></font><code>links</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contain only unique values:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> id, node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.tree) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.links <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> node.links = fn.unique(node.links) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now the only thing left is to make it so that when we click on a node we check whether it is connected to the node already purchased: </font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Node:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.hot <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:pressed(<span class="hljs-string"><span class="hljs-string">'left_click'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current_room:canNodeBeBought(self.id) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> fn.any(bought_node_indexes, self.id) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(bought_node_indexes, self.id) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this will mean that if the mouse cursor is </font></font><code>canNodeBeBought</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hovered </font><font style="vertical-align: inherit;">over the node and the player presses the left mouse button, then we check with the help of the </font><font style="vertical-align: inherit;">SkillTree object </font><font style="vertical-align: inherit;">function </font><font style="vertical-align: inherit;">whether this node can be purchased (we will implement the function below). </font><font style="vertical-align: inherit;">If it can be bought, we add it to the global table </font></font><code>bought_node_indexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here we also make it so that you cannot add a node to this table twice. </font><font style="vertical-align: inherit;">Although if we had added it several times, it would not change anything and would not cause any bugs. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code>canNodeBeBought</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">works like this: it passes through the connected nodes to the node that was transferred to it and will check if any of them is inside the table </font></font><code>bought_node_indexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If so, then this node is connected to the already purchased one, that is, you can buy it:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkillTree:canNodeBeBought</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, linked_node_id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.tree[id]) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> fn.any(bought_node_indexes, linked_node_id) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is what we wanted: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/745/fe5/cb2/745fe5cb22c24cbe4f85cb3fb66502bb.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last problem we will consider is how to apply the effects of the selected nodes to the player. </font><font style="vertical-align: inherit;">This is simpler than it seems due to the way we structured everything in parts 11 and 12. Now the definition of a tree looks like this:</font></font><br><br><pre> <code class="lua hljs">tree = {} tree[<span class="hljs-number"><span class="hljs-number">1</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">0</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, links = {<span class="hljs-number"><span class="hljs-number">2</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">2</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">48</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">3</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">96</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'6% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.06</span></span>}, links = {<span class="hljs-number"><span class="hljs-number">4</span></span>}} tree[<span class="hljs-number"><span class="hljs-number">4</span></span>] = {x = <span class="hljs-number"><span class="hljs-number">144</span></span>, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, stats = {<span class="hljs-string"><span class="hljs-string">'4% Increased HP'</span></span>, <span class="hljs-string"><span class="hljs-string">'hp_multiplier'</span></span>, <span class="hljs-number"><span class="hljs-number">0.04</span></span>}}</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, we have the second parameter value - a string that should point to a variable defined in the Player object. </font><font style="vertical-align: inherit;">In our case, it is variable </font></font><code>hp_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If we go back to the Player object and see where it is used </font></font><code>hp_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we will see the following:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:setStats</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.max_hp = (self.max_hp + self.flat_hp)*self.hp_multiplier self.hp = self.max_hp ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is used in the function </font></font><code>setStats</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as a multiplier of base HP, folded with some simple HP value, which we expected. We want the following behavior from the tree: for all nodes inside </font></font><code>bought_node_indexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we apply their parameter to the corresponding player variable. That is, if inside this table there are nodes 2, 3 and 4, then the player must have </font></font><code>hp_multiplier</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equal to 1.14 (0.04 + 0.06 + 0.04 + base equal to 1). We can relatively simply implement it like this:</font></font><br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">treeToPlayer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(player)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, index <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(bought_node_indexes) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> stats = tree[index].stats <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, #stats, <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> attribute, value = stats[i+<span class="hljs-number"><span class="hljs-number">1</span></span>], stats[i+<span class="hljs-number"><span class="hljs-number">2</span></span>] player[attribute] = player[attribute] + value <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We define this function in </font></font><code>tree.lua</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. As expected, we go through all purchased nodes, and then by their parameters. For each parameter, we take an attribute ( </font></font><code>'hp_multiplier'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and value (0.04, 0.06), and then apply them to the player. In the example we are discussing, the line is </font></font><code>player[attribute] = player[attribute] + value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parsed into </font></font><code>player.hp_multiplier = player.hp_multiplier + 0.04</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or into </font></font><code>player.hp_multiplier = player.hp_multiplier + 0.06</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, depending on which node we cycle around. This means that by the end of the external for we will apply all purchased passive skills to player variables. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is important to note that various passive skills need to be handled a little differently. Some skills are of type boolean, others must be applied to variables that are Stat objects, and so on. All these differences need to be handled outside of this function. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">224. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement skill points. We have a global variable </font></font><code>skill_points</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that stores the amount of skill points a player has. When a player buys a new node in the skill tree, this variable should decrease by 1. The player should not be able to buy more nodes than he has skill points. A player can buy no more than 100 knots. If necessary, you can slightly change these numbers. For example, in my game, the price of each node increases depending on how many nodes the player has already bought. </font></font><br><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">225. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implement a step before buying nodes, where the player can refuse to buy. </font><font style="vertical-align: inherit;">This means that the player can click on the nodes, as if buying them, but to confirm the purchase, he must click on the ‚ÄúApply Points‚Äù button. </font><font style="vertical-align: inherit;">If you click on the ‚ÄúCancel‚Äù button, all selected nodes will be canceled. </font><font style="vertical-align: inherit;">Here is what it looks like:</font></font><br><br><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath132.gif"></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">226. (CONTENT)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Implement a skill tree. </font><font style="vertical-align: inherit;">You can make this tree of any size that suits you, but obviously, the larger it is, the more possible interactions it will have and the more interesting it will be. </font><font style="vertical-align: inherit;">For reference: here is what my tree looks like:</font></font><br><br><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath133.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not forget to add to each separate type of passive skill the corresponding behaviors in the function </font></font><code>treeToPlayer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> END </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this article ends. In the next part we will look at the Console room, and the part after it will be the last. In the last part, we will look at some aspects, one of which is loading and saving. We have not discussed one of the elements of the skill tree, namely the preservation of the nodes purchased by the player. We want these nodes to remain purchased throughout the passage, as well as after closing the game, so in the last part we will consider this feature in more detail.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And as I have said many times before, if you don‚Äôt want, you can don‚Äôt create a tree of skills. </font><font style="vertical-align: inherit;">If you performed all the actions from the previous parts, then you already have all realized passive skills from parts 11 and 12, and you can present them to the player in any form convenient for you. </font><font style="vertical-align: inherit;">I decided to use wood, but you can choose something else if manually creating a huge tree seems like a bad idea to you.</font></font></div><p>Source: <a href="https://habr.com/ru/post/352896/">https://habr.com/ru/post/352896/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352886/index.html">Unity (Unet) - integration with social networks and secure WebSockets</a></li>
<li><a href="../352888/index.html">RealWorld Project: Front End Framework Comparison</a></li>
<li><a href="../352890/index.html">"Unicorns" is small, but should be even less</a></li>
<li><a href="../352892/index.html">JPoint 2018 open java conference open</a></li>
<li><a href="../352894/index.html">The first in Belarus FrontSpot hakaton without rules. And it's not a joke</a></li>
<li><a href="../352898/index.html">Why I do not sign non-competition agreements</a></li>
<li><a href="../352900/index.html">How we opened a children's robotics center in a small town</a></li>
<li><a href="../352902/index.html">What's new in DataGrip 2018.1</a></li>
<li><a href="../352904/index.html">We create TUI on python</a></li>
<li><a href="../352906/index.html">Tamed floating point numbers. Is it possible to debug shaders for mobile devices on a PC?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>