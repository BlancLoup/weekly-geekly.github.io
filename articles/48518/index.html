<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Doing Liquid Resize with your own hands</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="You've probably already heard about Liquid Resize scaling technology, which takes into account the contents of the image. If you are wondering how it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Doing Liquid Resize with your own hands</h1><div class="post__text post__text-html js-mediator-article">  You've probably already heard about Liquid Resize scaling technology, which takes into account the contents of the image.  If you are wondering how it all works and how you can implement all this yourself, then read on (carefully, many pictures). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/6ff/adf/e65/6ffadfe65d850dac7c48ba90eff3f265.jpg"></div><br>  <font color="#cccccc">(UFO flew in and stretched this drawing here)</font> <br><a name="habracut"></a>  The article is posted by me at the request of my friend, who can not put it on Habr, because he does not have an account.  <b>Thanks to your advantages, the author has an invite, and he is now with us: <a href="https://habrahabr.ru/users/kotter/" class="user_link">Kotter</a></b> . <br><h3><br>  Content </h3><br><ul><li>  What is Seam Carving? </li><li>  A few comments on reading the article <br></li><li>  General scheme of the algorithm <br></li><li>  Point energy calculation </li><li>  Finding the chain with the minimum total energy </li><li>  Decrease figures </li><li>  Enlarging Drawings </li><li>  Examples </li><li>  Results </li></ul><br><h3>  What is Seam Carving? </h3><br>  Seam Carving is an image resizing algorithm that takes into account the contents of the image (as the authors call the Content-Aware Image Resizing Algorithm).  It was first demonstrated in 2007 and aroused considerable interest.  Probably many Habr's readers have heard about him, since there have already been <a href="http://eject.habrahabr.ru/blog/13534/">articles</a> on this topic. <br><br>  Then the question arises: how does this algorithm take into account the contents of the images?  In theory, everything is simple - first, the importance of different parts of the image is calculated, after which only those parts that, according to the algorithm, are not so important, change in size.  In practice, to implement this algorithm, we need to solve a number of questions: how to determine how important parts of the image are, how to find and compress less important parts of the image, etc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article I tried to answer these, as well as a number of other questions that arise when solving this problem. <br><br>  Those who now want to see what I finally got, can find examples of images and a demo program with commented source codes at the end of the article. <br><br><h3>  A few comments on reading the article </h3><br>  Before the article itself, I want to stipulate some conventions. <br><br>  First of all.  In the article I often use the term "energy", although I am not sure of the correctness of this term.  And I use it because the authors themselves call it the English word "energy".  Energy point means its importance in the image.  The more energy - the more important point. <br><br>  Secondly.  The article deals only with horizontal resizing.  With simultaneous resizing in both directions, the principle remains the same, only we now consider not only vertical chains of pixels, but also horizontal ones. <br><br>  Thirdly.  I have no experience writing under C # /. NET.  The choice of program platform / language was determined by the simplicity of the code for understanding and wide audience coverage.  Therefore, if I wrote something in the program ineffectively or not ‚Äúaccording to dotnetovsky‚Äù, then do not pay attention to it.  That's not the point of the program. <br><br>  Fourth.  Russian is not my native language, so sorry for any errors. <br><br>  And the last.  The program code is not optimal.  I chose simplicity between the simplicity of the code and the optimality of the code, so if you want to use this algorithm somewhere - optimize it for your task.  Fortunately, there is room for optimization. <br><br>  Actually, we finished with the prelude, now we come to the most interesting ... <br><br><h3>  General scheme of the algorithm </h3><br>  The whole algorithm consists of the following components: <br><br><ol><li>  Finding the energy of each point.  At this stage, we need to know which parts of the image are more important and which less important, based on these data, we will subsequently change the image size. </li><li>  Finding such a vertical chain of pixels so that the total energy of the pixels that make up this chain is minimal.  A pixel chain is such a set of pixels that exactly one pixel is selected in each row, and the neighboring pixels in it are connected by sides or corners.  If we find such a chain, we can remove it from the image, while at the same time affecting the content of the image as little as possible. </li><li>  When we find a chain with minimal energy, we can only remove it if we need to reduce the image, or stretch it if we need to enlarge the image. </li></ol><br>  Now consider each item in more detail. <br><br><h3>  Point energy calculation </h3><br>  First of all, we need to decide which parts of the image are important and which are not. <br><br>  To solve this problem, the authors of the algorithm suggest for each pixel to calculate its "energy" - that is, some kind of conditional indicator (in parrots), which will show whether this pixel is important in this image, or not. <br><br>  In principle, there are many ways to do this: from the simplest (for example, to count color changes as compared to the neighboring ones) to quite complex ones (for example, to make an analysis of a person‚Äôs attention focusing).  According to the authors themselves, they tested many energy functions, and one of the simplest functions gave one of the best results.  Therefore, we will use this function now.  Here she is: <br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/e83/cd9/612/e83cd961259d6e01de8cfc2e51bff7e3.jpg"></div><br><br>  If you, when seeing this formula with derivatives, were afraid that you will need to recall mathematical analysis, then in vain.  In fact, it is formulated quite simply: the energy of a pixel is equal to the change in color of neighboring pixels in comparison with a given pixel.  That is, the greater the difference in color between a given pixel and its neighbors, the greater its energy. <br><br>  Now consider the implementation of energy calculations in practice.  Let the points of the image are characterized by their intensity.  We have the following 3x3 pixel image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/317/3c9/d9f/3173c9d9f39ce23215b25b0aa4e5f483.jpg"></div><br>  First, we calculate the absolute value of the difference in intensity between the pixel and its neighbors (right and bottom), and then we calculate the energy of this pixel as the arithmetic average of these values. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/6a5/6f2/828/6a56f282839ebd47c348f67332ea2e69.jpg"></div><br><br>  For the selected pixel: the difference between it and the neighbor to the right is 8, the neighbor to the bottom is 3. The arithmetic average is (8 + 3) / 2 = 5.5.  But since it is more convenient and faster to work with integers, and such accuracy is superfluous, then we discard the fractional part.  That is, the energy of the selected pixel is equal to 5. <br><br>  Similarly, we calculate for the remaining pixels.  At the same time, the pixels that are extreme on the right and extreme on the bottom will only have a neighbor on the right or on the bottom, so for them the difference value will be the arithmetic average.  For the pixel in the right-bottom corner there are no such neighbors at all, so we simply take its energy as 0. Although it is theoretically possible to calculate energy for it, but we will not complicate our life, since in practice it can be neglected. <br><br>  As a result, we obtain the following matrix of pixel energies: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/ada/5d3/558/ada5d3558a8de6bfbc352ae98428f189.jpg"></div><br><br><br>  If, in our case, pixels are characterized not just by intensity, but by intensity values ‚Äã‚Äãseparately for R, G, B, then the pixel energy is equal to the sum of the energies for each of the components. <br>  An example of an energy map for an image: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage2/859/8b7/74a/8598b774a96215aeca677ef2cff72f42.jpg"></div><br><br>  In this picture, the darker the color on the energy map is, the more energy. <br><br>  I implemented finding the pixel energies using the following function: <br><pre><code class="hljs pgsql">private <span class="hljs-type"><span class="hljs-type">void</span></span> FindEnergy() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; imgHeight; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; imgWidth; j++) { energy[i, j] = <span class="hljs-number"><span class="hljs-number">0</span></span>; //     R, G, B <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; k &lt; <span class="hljs-number"><span class="hljs-number">3</span></span>; k++) { <span class="hljs-type"><span class="hljs-type">int</span></span> sum = <span class="hljs-number"><span class="hljs-number">0</span></span>, count = <span class="hljs-number"><span class="hljs-number">0</span></span>; //     ,    sum        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i != imgHeight - <span class="hljs-number"><span class="hljs-number">1</span></span>) { count++; sum += Math.Abs((<span class="hljs-type"><span class="hljs-type">int</span></span>)image[i, j, k] - (<span class="hljs-type"><span class="hljs-type">int</span></span>)image[i + <span class="hljs-number"><span class="hljs-number">1</span></span>, j, k]); } //     ,    sum        <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j != imgWidth - <span class="hljs-number"><span class="hljs-number">1</span></span>) { count++; sum += Math.Abs((<span class="hljs-type"><span class="hljs-type">int</span></span>)image[i, j, k] - (<span class="hljs-type"><span class="hljs-type">int</span></span>)image[i, j + <span class="hljs-number"><span class="hljs-number">1</span></span>, k]); } //   energy         k-  (   R, G  B) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count != <span class="hljs-number"><span class="hljs-number">0</span></span>) energy[i, j] += sum / count; } } }</code> </pre> <br>  The function works with global variables: energy is an array in which energy is written, and image is an array in which the image is stored. <br><br><h3>  Finding the chain with the minimum total energy </h3><br>  We already have energy values ‚Äã‚Äãfor each pixel, but now we need to choose those pixels whose energy value is minimal.  But if we start to pick up / add arbitrary pixels, then the image itself will simply crawl away and deform beyond recognition.  Of course, this result does not suit us.  Therefore, you must first select a chain of pixels, and then delete or add them.  What is not an arbitrary chain, and the "correct". <br><br>  The ‚Äúcorrect‚Äù chain is a set of points, such that exactly 1 pixel is selected in each line of the image, and the pixels in the adjacent lines are ‚Äúconnected‚Äù either by sides or corners. <br><br>  An example of "correct" chains: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/445/b24/f29/445b24f29703c48b942e86f85bf08af8.jpg"></div><br><br>  Example of "invalid" chains: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/6d5/576/e38/6d5576e38a2f163d99d817bb149db7e4.jpg"></div><br><br>  Now we know that we need to delete the "correct" chains, then we will not spoil the image much.  But which chain then choose?  The authors of the algorithm suggest to choose those chains for removal / stretching, the sum of the pixel energies that are included in it is minimal. <br><br>  This raises a completely natural question: how do we find such a chain? <br><br>  The first option is to iterate over all the chains, summarize them, and find them with the minimum amount.  The option, of course, is interesting, but then for processing even a small image we will have to wait for eternity :) If we have an eternity in store, then we write a brute-force code, start and wait.  If you want to see the result in a shorter period of time - then read on. <br><br>  Here dynamic programming comes to our rescue.  I will not go into details, and show what the ‚Äúdynamism‚Äù of programming is (by the way, the term ‚Äúprogramming‚Äù has nothing to do with writing code), and immediately proceed directly to the algorithm.  If someone does not know what ‚Äúdynamic programming‚Äù is and wants to know, he can read about it on <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5" title="Wikipedia">Wikipedia</a> or other sources. <br><br>  First, we will create a new array, which is equal in size to an array with pixel energies.  In this array, for each pixel we write the sum of the elements of the minimum chain of pixels that starts at the top edge of the image and ends at this pixel. <br><br>  We show the calculation process by example.  Suppose we have an array with energy values ‚Äã‚Äãfor each pixel: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/41f/e12/09f/41fe1209fd5b30a74075f0f97afe3a85.jpg"></div><br><br>  We will calculate the elements of this array along the lines - from the first to the last.  For the top line, the elements of this array will be equal to the elements of the array, since from each such element it is possible to build only 1 chain (all of unit length): <br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/fb6/44f/538/fb644f53822071af59c51bd60ea68ec3.jpg"></div><br><br>  Now let's calculate the second line.  Consider the selected cell.  We can build a chain from this cell in three ways, as shown in the figure.  Of these three methods, we need to choose the minimal one (since we consider the sums of precisely minimal chains).  For the selected cell, this will be a chain with the sum of 3, and add the energy of the cell itself to this chain.  Therefore, in this cell we write the number 7 (the sum of 3 and 4).  Similarly, we calculate all sums for all elements of the second line: <br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/1c5/d9b/a1c/1c5d9ba1c4e3d4af003d0b0774699c28.jpg"></div><br><br>  Let's move to the third line.  In principle, the third line is considered to be similar to the second.  Consider the selected cell again.  From it we can form such chains: <br><ul><li>  this cell plus the minimum chain is 8; </li><li>  this cell plus the minimum chain is 6; </li><li>  this cell plus the minimum chain is 7; </li></ul>  From these options again choose the minimum (6) and add to the energy of the cell itself (6).  We get the value of this cell is 12. Similarly, we consider the remaining elements of the third line. <br><br>  After calculating all the lines in this way, we get the following array as a result: <br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/4af/e3d/b5a/4afe3db5af1f7d540ed0a7dc3f1041b2.jpg"></div><br><br>  If we formalize the calculation of this array, we obtain the following formula: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/eb4/9db/556/eb49db556c103064c964ad4d9559c4b6.gif"></div><br><br>  where s is our array of sums, and e is an array of energies. <br><br>  My implementation of the calculation of the array of sums: <br><br><pre> <code class="hljs pgsql">private <span class="hljs-type"><span class="hljs-type">void</span></span> FindSum() { //     sum  energy   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; imgWidth; j++) sum[<span class="hljs-number"><span class="hljs-number">0</span></span>, j] = energy[<span class="hljs-number"><span class="hljs-number">0</span></span>, j]; //       (i,j)  sum   // energy[i,j] + MIN ( sum[i<span class="hljs-number"><span class="hljs-number">-1</span></span>, j<span class="hljs-number"><span class="hljs-number">-1</span></span>], sum[i<span class="hljs-number"><span class="hljs-number">-1</span></span>, j], sum[i<span class="hljs-number"><span class="hljs-number">-1</span></span>, j+<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; imgHeight; i++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-type"><span class="hljs-type">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; imgWidth; j++) { sum[i, j] = sum[i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sum[i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j - <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; sum[i, j]) sum[i, j] = sum[i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (j &lt; imgWidth - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; sum[i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j + <span class="hljs-number"><span class="hljs-number">1</span></span>] &lt; sum[i, j]) sum[i, j] = sum[i - <span class="hljs-number"><span class="hljs-number">1</span></span>, j + <span class="hljs-number"><span class="hljs-number">1</span></span>]; sum[i, j] += energy[i, j]; } }</code> </pre><br>  The function works with global variables: energy is an array in which energy is written and sum is an array in which the values ‚Äã‚Äãof sums are written. <br>  Now, when we already have this array, it is time to think - and why do we need it at all?  I will answer - according to this array we can now quickly find a chain with the minimum amount of energies. <br><br>  First we will find which pixel from the bottom line of the image belongs to this chain: the element that we are looking for will have the smallest value in the array of sums among the elements of the bottom line.  Why?  Recall that in this array the values ‚Äã‚Äãof the sum of the elements of the minimum chains are recorded from the top edge to the given pixel.  The chains that interest us end in a pixel from the last row.  Accordingly, for the entire picture, the minimum chain will be selected as the minimum of all the minimum chains that end in pixels from the bottom line. <br><br>  For our example, this will be the following element: <br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/4c5/142/259/4c5142259117a34f87d053fda308f3da.jpg"></div><br><br>  We already know on which pixel the minimum chain ends, now we can find a pixel from the last but one line.  As it was already written, from the lower pixel we can go only to 3 neighboring pixels on the line above: on the left-from the top, on the top or on the right-from the top.  Among these pixels, choose a pixel with the minimum value in the array of sums, and go to it.  We continue until we reach the top line.  The process is shown in the following figure: <br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/72d/95f/31b/72d95f31bc5d8bc33b50fe4f6d2efa9d.jpg"></div><br><br>  After performing all these operations, we get what we wanted - a set of pixels that we can change with minimal loss for the image. <br><br>  An example of a minimum chain in the figure: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/598/312/eab/598312eab8ee0f3afee38810d00a00b3.png"></div><br><br>  Software implementation of the chain search algorithm: <br><br><pre> <code class="hljs perl">private <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] FindShrinkedPixels() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">last</span></span> = imgHeight - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] res = new <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[imgHeight]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     sum,          res[<span class="hljs-keyword"><span class="hljs-keyword">last</span></span>] res[<span class="hljs-keyword"><span class="hljs-keyword">last</span></span>] = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">1</span></span>; j &lt; imgWidth; j++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum[<span class="hljs-keyword"><span class="hljs-keyword">last</span></span>, j] &lt; sum[<span class="hljs-keyword"><span class="hljs-keyword">last</span></span>, res[<span class="hljs-keyword"><span class="hljs-keyword">last</span></span>]]) res[<span class="hljs-keyword"><span class="hljs-keyword">last</span></span>] = j; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         . <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-keyword"><span class="hljs-keyword">last</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> prev -       //         (prev-<span class="hljs-number"><span class="hljs-number">1</span></span>), prev  (prev+<span class="hljs-number"><span class="hljs-number">1</span></span>),      <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> prev = res[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ,     sum,  ,    ,        res[i] res[i] = prev; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prev &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; sum[i, res[i]] &gt; sum[i, prev - <span class="hljs-number"><span class="hljs-number">1</span></span>]) res[i] = prev - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (prev &lt; imgWidth - <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; sum[i, res[i]] &gt; sum[i, prev + <span class="hljs-number"><span class="hljs-number">1</span></span>]) res[i] = prev + <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br><h3>  Decrease figures </h3><br>  We finally found a chain of pixels with which we will work.  Now you can remember why we were looking for it at all.  Our task is to resize the image.  The magnification and reduction of the image are slightly different, so first consider the reduction, and then the increase. <br><br>  If we need to reduce the width of the image by 1 pixel, then everything is simple: we find a vertical chain, as described above, and simply remove it from the image.  I implemented this operation using the following loop: <br><br><pre> <code class="hljs matlab"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span> &lt; imgHeight; <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (int <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> = cropPixels[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> &lt; imgWidth; <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>++) { pImage[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>] = pImage[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>]; }</code> </pre><br>  The i-th element of the cropPixels array contains the number of the pixel column, which we remove from the i-th line.  And the cycle itself does the <font>following: all the pixels that are written to the right of those that are deleted, we move one point to the left.</font>  <font>As a result of this operation, our pixel chain will be removed from the image.</font> <font><br><br></font>  <font>If we need to reduce the image not by 1 pixel, but by a larger value, then we perform the operation of deleting the chain as many times as necessary (each time we need to look for this chain).</font> <font><br><br></font>  <font>I want to note that the operation of reducing the image by n pixels and the operation of reducing the image by 1 pixel n times are not equivalent.</font>  <font>Their difference is that if we reduce by 1 pixel n times, then for each of the intermediate images we look for the pixel energy, and if we immediately reduce it by n, then we take the pixel energy from the original image.</font> <font><br></font> <br><h3>  Enlarging Drawings </h3><br>  We can already reduce images, now we need to figure out how to increase them. <br><br>  The first thing that comes to mind is exactly the same as when decreasing, choose chains and ‚Äústretch‚Äù them.  But if we implement it, we get the following result: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/155/03e/fd9/15503efd9f2421efac9d9cd496a0f7bc.jpg"></div><br><br>  As we can see, the program simply took one bar and stretched it, but this is not exactly what we need. <br><br>  The next thought may be, for example, this: you need to take more than one minimum chain, but as much as you need to complete the drawing to the desired width.  Suppose we implemented this algorithm, but what will happen if we increase the figure by 2 times? <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/8fa/2c6/5eb/8fa2c65eb25cfc76fad87975fe59f5c4.jpg"></div><br><br>  As you can see from this picture, we simply selected all the points and stretched them horizontally, but this is also not exactly what we need, since this method does not differ from the usual stretching. <br><br>  But in principle, the very idea of ‚Äã‚Äãthe latter method is correct, but with a slight change: we need to increase the image in stages, so that at each stage as many ‚Äúnon-important‚Äù parts of the image as possible and as few as ‚Äúimportant‚Äù ones are covered.  Then the question arises, how to break the process of increasing into stages?  There are a lot of options - from dividing up into stages manually, before writing some kind of heuristic analyzers.  But in my program I wrote simply - breaking into stages occurs in such a way that at each stage the image does not increase by more than 50%.  Sometimes it gives an acceptable result, sometimes not so much, but, as I have already written, there are a lot of options for implementing partitioning. <br><br>  If we increase our UFO picture this way, we get the following result: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/da9/85d/b61/da985db61d5ff804ada1238dc67032b6.jpg"></div><br><br>  As you can see, the UFO, man and tree remained unchanged. <br><br><h3>  Examples </h3><br>  All examples of scaling pictures were obtained using a program that I wrote in parallel with this article, implementing the algorithms that are described here. <br><br>  Source codes and binary programs can be downloaded at the bottom of the article. <br><br>  A classic example of Content-Aware Resizing: <br><br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/54f/967/61c/54f96761c29cb1c71f68d6b543b1571d.jpg"></div><br><br>  The following picture clearly expresses the ‚Äúimportant‚Äù objects and background. <br><br>  <s><a href="">(original)</a> <a href="">(reduced)</a> <a href="">(increased)</a></s> <br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/0a9/2cf/321/0a92cf321905919fe9664beffb42f9a2.jpg"></div><br><br><br>  Drawing starry sky  When resizing, the shape of the stars almost does not change. <br><br>  <s><a href="">(original)</a> <a href="">(reduced)</a> <a href="">(increased)</a></s> <br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/194/e24/442/194e24442cec353daf43695dae4a4a9a.jpg"></div><br><br>  And another example of scaling two photos taken by <a href="https://habrahabr.ru/users/gmm/" class="user_link">gmm</a> . <br><br>  <s><a href="">(original)</a> <a href="">(reduced)</a> <a href="">(increased)</a></s> <s><br></s> <div style="text-align:center;"> <s><img src="http://habrastorage.org/storage2/2c4/a4b/edb/2c4a4bedb8e7c03d7d549448dea43359.jpg"></s> </div><br><br><br><br>  <s><a href="">(original)</a> <a href="">(reduced)</a> <a href="">(increased)</a></s> <br><div style="text-align:center;"><img src="http://habrastorage.org/storage2/5d7/604/d8e/5d7604d8ef18318ce91517c03d099bfc.jpg"></div><br><br><h3><br>  Results </h3><br><br>  So, what we got as a result: <br><ul><li>  Knowledge of the principle of operation of such an interesting and useful algorithm as Seam Carving; </li><li>  The program in which you can play in the image size changer (of course there are also Photoshop and http://rsizr.com/, but in these cases you do not have the source code); </li><li>  Space for imagination on possible improvements of the algorithm (for example, you can attach a face detector to it, I think the results will be better); </li><li>  Knowing that Content-Aware Rescale in Photoshop is not a special Photoshop magic, but a simple algorithm that can be understood. </li></ul><br>  Thanks to those who read the article to the end, I hope it was interesting. <br><br><br><h3>  PS </h3><br>  <a href="http://narod.ru/disk/4812139000/SeamCarving_VS2008_(source).rar.html">Sources (VS 2008)</a> <br>  <a href="http://narod.ru/disk/4812140000/SeamCarving_VS2008_(bin).rar.html">Binary (.NET)</a> <br><br>  <b>upd</b> <br>  Useful links on the topic: <ul><li>  <a href="http://www.faculty.idc.ac.il/arik/papers/imret.pdf">PDF, in which the authors describe the algorithm (English, ~ 18 MB).</a> </li><li>  <a href="http://en.wikipedia.org/wiki/Sobel_operator">Improving the way to count energy Sobol operator (eng).</a> </li><li>  <a href="http://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">Dynamic programming on Russian Wikipedia.</a>  DP was used in this algorithm, but it has a much larger scope of application, so it is highly recommended to read for those who are not familiar with it. </li><li>  At the request of <a href="https://habrahabr.ru/users/prokoudine/" class="user_link">prokoudine</a> , I will mention some free implementations of the algorithm: <ul><li>  The <a href="http://liquidrescale.wikidot.com/">Liquid Rescale extension</a> for GIMP and <a href="http://www.imagemagick.org/script/index.php">ImageMagick</a> , based on the <a href="http://liblqr.wikidot.com/">liblqr</a> library, </li><li>  <a href="http://code.google.com/p/seam-carving-gui/">SeamCarvingGUI</a> based on <a href="http://sourceforge.net/projects/c-a-i-r/">CAIR</a> library </li></ul></li></ul>  The list can be replenished. </div><p>Source: <a href="https://habr.com/ru/post/48518/">https://habr.com/ru/post/48518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../48512/index.html">Caution: statistical misinformation</a></li>
<li><a href="../48514/index.html">Impressive "scientific" experiments at home + competition for Habralubiteley from SmartVideos.ru</a></li>
<li><a href="../48515/index.html">Ruby on Rails take the first step</a></li>
<li><a href="../48516/index.html">(a) Slideshow Wordpress Plugin</a></li>
<li><a href="../48517/index.html">Channel 9 - how we found Surface in the Redmond corridors</a></li>
<li><a href="../48519/index.html">Death of carriers</a></li>
<li><a href="../48520/index.html">Buy an idea - results</a></li>
<li><a href="../48522/index.html">Gnome panel applet displaying karma and habrasil</a></li>
<li><a href="../48523/index.html">Puzzle It! - project on the knee.</a></li>
<li><a href="../48524/index.html">SharePoint on earth, in the clouds and beyond the horizon: years, products, names</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>