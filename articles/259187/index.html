<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Shadow DOM (Shady DOM)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On Google I / O we were introduced to Polymer 1.0. This is a new release of the tool, which includes a number of features and innovations. Perhaps it ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Shadow DOM (Shady DOM)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d30/c4a/44b/d30c4a44b88e46ff87ae6922f4f3f5c7.png"><br><br>  On Google I / O we were introduced to Polymer 1.0.  This is a new release of the tool, which includes a number of features and innovations.  Perhaps it is worth starting with Shady DOM. <br><br><h2>  Why do we need another DOM? </h2><br><blockquote>  Encapsulation is the foundation of web components. </blockquote><br>  The goal of the web components is to provide the user with a simple interface for displaying complex elements whose implementation is hidden. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Browsers often use encapsulation.  For example, the <code>&lt;select&gt;</code> and <code>&lt;video&gt;</code> elements are displayed using a non-usable DOM, which only the browser knows about. <br><a name="habracut"></a><br>  There are many libraries that try to follow similar behaviors.  For example, a jQuery plugin that turns your chosen element into a slider.  As a rule, a plugin generates a bunch of DOMs around an element, trying to endow it with typical slider properties and capabilities.  This approach is an excellent practice, but the entire DOM generated for the needs of the slider is not hidden and is on the page.  This is not nearly as elegant as using <code>&lt;select&gt;</code> or <code>&lt;video&gt;</code> . <br><br>  Shadow DOM aims to solve this problem.  Browsers that support shadow DOM can display complex elements by hiding the implementation (DOM, CSS, JS). <br><br><blockquote>  Simple markup is good! </blockquote><br>  Let's imagine the <code>x-fade</code> element, the essence of which lies in the beautiful appearance of the image when it is loaded. <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cool.png"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  And, let's say, we implemented a plugin for it: <br><pre> <code class="javascript hljs">$(<span class="hljs-string"><span class="hljs-string">'x-fade'</span></span>).makeFade();</code> </pre><br>  The author will be very pleased, as he will achieve the necessary behavior. <br><br>  In fact, this is all we need from web components ‚Äî simple markup to achieve the necessary behavior.  But the plugin-based approach has a number of drawbacks, which solves the shadow DOM. <br><br><h2>  DOM pollution </h2><br>  Suppose after calling <code>makefade</code> , we have the following DOM: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cool.png"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  The <code>x-fade</code> plugin needs some DOM to achieve its goal.  The elements that he added are open, leading to the following problems: <br><ul><li>  Implementation details are disclosed. </li><li>  Selectors that go through the document tree will include <code>&lt;canvas&gt;</code> and <code>&lt;div&gt;</code> . </li><li>  Since the author did not expect the appearance of these elements, they may inherit unnecessary styles. </li><li>  The <code>&lt;img&gt;</code> element, on the contrary, can lose its styles, since it is no longer part of the former DOM. </li><li>  Can the author add a new item?  Change or delete?  What to do if the elements are no longer where they were originally. </li></ul><br><br><h2>  Tree scoping </h2><br>  The scope of the tree allows us to hide part of the DOM tree from the main document. <br>  If we implement <code>x-fade</code> using the shadow DOM, then after the <code>makeFade</code> call, our tree will look like this: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cool.png"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  That is, exactly the same as before initialization. <br>  Browser mapping is different from how it is represented in the code.  For the developer, this is still an element with only one <code>&lt;img&gt;</code> . <br>  Thanks to this opportunity, we solved all the above problems.  Namely: <br><ul><li>  Implementation details are hidden. </li><li>  Samples traversing the document will not include the <code>canvas</code> and the <code>&lt;div&gt;</code> . </li><li>  New items will not inherit styles. </li><li>  <code>&lt;img&gt;</code> will not lose its styles, as it has not moved anywhere. </li><li>  Developers can easily add a new image or change the current one. </li></ul><br><br><h2>  Shadow DOM Encapsulation </h2><br>  If we decide to look at the full picture of what we got, then we will see the following: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cool.png"</span></span></span><span class="hljs-tag">&gt;</span></span> #shadow-root <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">content</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">select</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"img"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Yeah, here's our <code>&lt;canvas&gt;</code> and <code>&lt;div&gt;</code> .  You could also mark the new <code>&lt;content&gt;</code> element.  This is an example of a shadow DOM composition with a so-called light DOM ‚Äî one that we can <i>pass to an</i> element. <br>  At the moment of rendering, these two DOMs are combined and look like the result of jQuery (for the browser, of course, we don‚Äôt see it): <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cool.png"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><h2>  Shadow DOM is so cool, so why do we need another shady DOM ?! </h2><br><img src="https://habrastorage.org/files/b6f/b04/6ef/b6fb046ef53a4f30965263c2970897e5.jpg"><br><br>  Shadow DOM hides the DOM tree from the entire document.  Selectors that we will do according to the document ( <code>childNodes</code> , <code>children</code> , <code>firstChild</code> etc.) will not include hidden items as a result. <br><br>  To make a polyfil for such behavior is VERY difficult.  We need to achieve the same composite mapping of the DOM tree, while hiding it from the logical code. <br>  This means that we need to modify all available methods for working with elements in order to return custom information. <br><br>  We implemented such a polyfil, but the price is: <br><br><ul><li>  A lot of code. </li><li>  Redefinition of methods, slows down work with elements. </li><li>  Structures like the <code>NodeList</code> are not under our control. </li><li>  Accessors (for example window.document, window.document.body) cannot be redefined. </li><li>  Polyphil returns proxied objects, which can be confusing. </li></ul><br>  Most of the projects simply can not be implemented due to the above disadvantages, and in Safari we have terrible performance. <br><br><h2>  Shady dom </h2><br><blockquote>  A la Frankenstein, which Google is trying to praise in every way.  It is a pity, but there is no other way out. </blockquote><br>  Roughly speaking, the Shady DOM provides us with a shadow DOM-compatible model of the scope of the tree.  The result of the work we get exactly the same DOM as with the jQuery plugin. <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cool.png"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">canvas</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In other words, gentlemen, all those flaws that we supposedly overcame - open implementation, problems with styles and the rest. <br><br>  All that could save Google from the side is how the tree is represented in the code.  But for this we MUST, use the new API for working with DOM and only then we will work with the elements as if nothing had happened and to see it like this: <br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">img</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cool.png"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x-fade</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In fact, within an element, it looks quite worthy of itself: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arrayOfNodes = Polymer.dom(x-fade).children;</code> </pre><br>  This way we can work with both the internal DOM and the <i>light</i> DOM. <br><br>  The shadow DOM model was not completely embossed from the polymer.  Shady compatibility with shadow allows us to write in the same style.  If you want, you can make the polymer decide where it can use the shadow DOM natively, and where to include shady. <br><br><h2>  findings </h2><br><ul><li>  Web components need encapsulation, aha ... </li><li>  Shadow DOM implements encapsulation, but only Google supports it natively. </li><li>  Trying to make a polyfil for shadow DOM is a difficult and slow in the long run. </li><li>  Shady DOM presents us with a super-fast analogue of the shadow DOM polyphile, but with <s>some of</s> the biggest bunch of flaws, but we have a new API for you. </li><li>  Shady DOM gives us the opportunity to expand the audience of applications that we can develop using this model. </li><li>  All these inconveniences prove that all platforms must support the shadow DOM natively. </li></ul><br><br>  In fact, I am very pleased with the polymer itself.  As was said at the conference, the components of the reactor work only in the reactor, the components of the angular are only with angular, and the components written with the use of polymer work everywhere.  They occupy a level between the web platform and the frameworks.  You can use them with any framework or write an application using only components. <br><br>  I had the experience of crossing Backbone with React components, but this is not as cool as it may seem.  But the polymer components + Backbone straight yum. </div><p>Source: <a href="https://habr.com/ru/post/259187/">https://habr.com/ru/post/259187/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259175/index.html">Attackers use Linux / Moose to compromise Linux-embedded systems, part 1</a></li>
<li><a href="../259177/index.html">Hola VPN extension sells user traffic and contains remote code execution vulnerabilities</a></li>
<li><a href="../259181/index.html">Reuters: US plans to target Stuxnet to North Korea</a></li>
<li><a href="../259183/index.html">16 reasons why players leave your game</a></li>
<li><a href="../259185/index.html">Game server on Scala + Akka: Case study</a></li>
<li><a href="../259189/index.html">The implementation of one of the variants of the mobile version of the site</a></li>
<li><a href="../259191/index.html">Sudden sofa of a leopard coloring</a></li>
<li><a href="../259193/index.html">Qucs project news: preparing for release 0.0.19</a></li>
<li><a href="../259195/index.html">The digest of interesting materials for the mobile # 105 developer (on May 25-31)</a></li>
<li><a href="../259197/index.html">What do we know about MODX 3 at the moment?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>