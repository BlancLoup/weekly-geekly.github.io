<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interproject Interaction Security</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Today, many Internet services interact with each other through the Internet. A special class of interactions is those in which the tran...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interproject Interaction Security</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Today, many Internet services interact with each other through the Internet.  A special class of interactions is those in which the transfer of confidential information (personal data, secret messages) or commands that must be clearly confirmed by someone (for example, money transfer or publication of a message on behalf of someone else).  It is obvious that such services should be reliably protected from intruders. <br><br>  Unfortunately, not all developers think about the degree of security of their applications.  The problem is somewhat aggravated by the fact that many e-business representatives are developing protocols that, when implemented in end services, can create serious vulnerabilities if used without proper understanding. <br><br>  The objective of this article is to briefly describe the possible types of attacks in case of inter-project (i.e. server-to-server) interaction and means of protection against them in order to use ready-made protocols more thoughtfully and develop your own.  The basics of information security will be preliminarily considered, since often the knowledge of end-developers in this area is somewhat fragmentary. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Protection (or lack of protection) against various types of attacks is demonstrated on the example of the protocols of today's popular systems: <a href="http://assist.ru/">Assist</a> , <a href="http://www.cyberplat.ru/">Cyberplat</a> , <a href="http://webmoney.ru/">WebMoney</a> , <a href="http://www.chronopay.com/">ChronoPay</a> , <a href="http://www.robokassa.ru/">Robokassa</a> and <a href="https://www.x.com/">PayPal</a> (payment systems), as well as <a href="http://openid.net/">OpenID</a> , <a href="http://dev.aol.com/api/openauth">OpenAuth</a> , <a href="http://oauth.net/">OAuth</a> (decentralized authentication). <br><a name="habracut"></a><br><h4>  Secure communication </h4><br>  So let's define what we mean by the words " <b>secure interaction</b> ". <br><br>  1. <b>Authentication</b> .  Let server A want to send a message to server B. B. should be able to verify that the message was sent from A. This verification is called server A authentication on server B. <br><br>  2. <b>Data integrity</b> .  We want to be sure that the message was not changed during the transfer (for example, $ 50 was paid, and confirmation was received at $ 500). <br><br>  3. <b>Confidentiality of interaction</b> .  This clause implies that only those parties are entitled to receive the message.  As a rule, this item implies <b>encryption of</b> information during transmission. <br><br>  In some cases, two more points can be considered: access control and the impossibility of non-repudiation, but for now we will leave it aside. <br><br><h4>  Cryptographic primitives </h4><br>  Here it is necessary to make some digression to the theory.  I will not describe in detail the basics of cryptography (otherwise the volume of the article will go beyond the reasonable), but briefly mention the basic " <b>cryptographic primitives</b> " to denote the knowledge necessary to understand the rest of the article.  Those interested can follow the links to Wikipedia and learn more. <br><ul><li>  There are various systems of <b><a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25BC%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">symmetric encryption</a></b> .  The basis of these systems is one key K, which is known to both parties.  This key is used to both encrypt and decrypt the message.  Examples of standards: <a href="http://ru.wikipedia.org/wiki/RC2">RC2</a> , <a href="http://ru.wikipedia.org/wiki/RC4">RC4</a> , <a href="http://ru.wikipedia.org/wiki/RC5">RC5</a> , <a href="http://ru.wikipedia.org/wiki/DES">DES</a> , <a href="http://ru.wikipedia.org/wiki/3DES">3-DES</a> , <a href="http://ru.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> , <a href="http://ru.wikipedia.org/wiki/Blowfish">Blowfish</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%259E%25D0%25A1%25D0%25A2_28147-89">GOST 28147-89</a> , etc. </li><li>  There are <b><a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D0%25BE%25D0%25B5_%25D1%2588%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">asymmetric encryption systems</a></b> .  Here each side has a secret key and a public key.  The open is known to everyone (including cryptanalysts who want to hack the system), the secret one is for only one side.  Anyone can use the public key of side A to encrypt a message FOR side A. However, only the owner of the secret key, that is, A. This standard can be decrypted, that is, A. Example standard: <a href="http://ru.wikipedia.org/wiki/RSA">RSA</a> . </li><li>  As a rule, the public key is distributed in the form of so-called.  <b><a href="http://ru.wikipedia.org/wiki/X.509">certificates</a></b> .  Generally speaking, the public key is only part of the certificate, but in the future I will use these terms as synonyms. </li><li>  The same pair, the secret and the public key, as a rule, can be used to form a <b><a href="http://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B8%25D1%2584%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">digital signature</a></b> (CPU).  In this case, just as a person‚Äôs signature is present in a paper document, a digital signature generated on the basis of the message and the private key is included in the body of the electronic message.  The signature cannot be generated without using the secret key, but everyone can check it using the corresponding public key.  In this way, we can make sure that the message was sent by the server or person we need, and was not a ‚Äúfake‚Äù.  Protocols: <a href="http://ru.wikipedia.org/wiki/RSA">RSA</a> , <a href="http://ru.wikipedia.org/wiki/DSA">DSA</a> , <a href="http://ru.wikipedia.org/wiki/ECDSA">ECDSA</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%259E%25D0%25A1%25D0%25A2_%25D0%25A0_34.10-2001">GOST R 34.10-2001</a> . </li><li>  There are protocols that allow two parties to <b>generate a shared key K, without transferring it through the channel</b> .  Examples of protocols are the <a href="http://en.wikipedia.org/wiki/Diffie%25E2%2580%2593Hellman_key_exchange">Diffie-Hellman Key Exchange Protocol</a> (hereinafter, for brevity, simply Diffie-Hellman), <a href="http://ru.wikipedia.org/wiki/SRP">SRP</a> .  The first, for example, is used in the popular <a href="http://ru.wikipedia.org/wiki/OpenID">OpenID</a> system today. </li><li>  There are <a href="http://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">hash functions</a> that map a set of bits of fixed length to the text.  It is believed that the task of finding two texts that have the same hash is "very difficult."  Examples: <a href="http://ru.wikipedia.org/wiki/MD5">MD5</a> (which is already ‚Äúbroken‚Äù), <a href="http://ru.wikipedia.org/wiki/SHA-1">SHA-1</a> , <a href="http://ru.wikipedia.org/wiki/SHA-2">SHA-256</a> , <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D0%259E%25D0%25A1%25D0%25A2_%25D0%25A0_34.11-94">GOST 34.11-94</a> . </li><li>  There are <b><a href="http://ru.wikipedia.org/wiki/HMAC">Hash Message Authentication Code</a></b> (HMAC) codes.  This is a function of the message and some key, which also gives a fixed-length hash string at the output.  If both parties have a secret key K, then you can use the HMAC function as a method of generating a digital signature in a symmetric cryptosystem, since only 2 parties with a key can generate and verify a message signature. </li></ul><br><h4>  SSL / TLS and HTTPS </h4><br>  Speaking about ‚Äúsecurity of interaction‚Äù, you can ask a reasonable (in some way) question: all this: authentication, integrity support, encryption, is in SSL / TLS (HTTPS).  <b>Why do you need something else?</b> <br><br>  Therefore, the second insight into the theory will be a brief reminder of <b>what SSL / TLS and HTTPS are</b> . <br><br>  The <b>SSL protocol</b> ( <a href="http://ru.wikipedia.org/wiki/SSL">Secure Socket Layer</a> ) and its ‚Äúdescendant¬ª <b>TLS</b> ( <a href="http://ru.wikipedia.org/wiki/TLS">Transport Layer Security</a> ) was developed in response to the need for secure client-server communication.  The protocol works at the transport level of <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D0%25B5%25D0%25B2%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25BE%25D0%25B4%25D0%25B5%25D0%25BB%25D1%258C_OSI">the OSI model</a> .  With proper use, it allows you to establish an encrypted connection between the client and the server.  The protocol is protected from modification and reading of messages sent in both directions.  The protocol also allows the client (I repeat: with proper use) to make sure that he has established a connection with the correct server, and not with the rogue server (in other words, the client can authenticate the server).  There are modifications that allow authentication to the client, i.e., provide two-way authentication. <br><br>  <b>HTTPS</b> ( <a href="http://ru.wikipedia.org/wiki/HTTPS">HTTP Secure</a> ) is the same HTTP, but sent over a channel protected by SSL / TLS. <br><br>  It is very important to understand that having an SSL / TLS channel in an incomplete implementation means only that the connection between your point and the remote server goes through a protocol that is well protected from the point of view of listening and changing information.  But it doesn‚Äôt mean anything until you are convinced that the remote side is the one you wanted to contact.  You can make sure of this only if you know the certificate of the remote side in advance, and you trust it, or if you receive the same certificate via an unprotected channel, but signed by a ‚Äúthird party‚Äù, the so-called  Certification Authority (CA).  At the same time, the public key of the CA used to verify the signature must again be known to you in advance so that you do not have to transmit it over an unprotected channel.  For example, how is this security ensured in browsers?  Certificates of major CA (the most famous - COMODO, VeriSign, Go Daddy, Thawte, etc., there are only a few dozen of them), are embedded in your browser in advance. <br><br>  How to verify the certificate in the code of your service?  If you have a certificate in advance, it is quite simple to do this (for example, PHP programmers can look in the direction of <a href="http://ru2.php.net/curl_setopt">curl_setopt</a> (), options CURLOPT_CAINFO and CURLOPT_CAPATH).  In this way, the security of the connection is ensured in the code of interaction with the WebMoney server.  If you don‚Äôt know the CA server in advance, it‚Äôs somewhat harder to do such a check in practice, because you‚Äôll have to select and maintain a collection of certificates from various CAs yourself. <br><br>  In practice, certificate verification in code is often not performed, which can lead to one of <b>two attacks</b> : <b>server substitution</b> or Man in the Middle (MITM) attack.  The latter means that there is another server (M) between you (A) and the destination server (B).  You (A) establish an absolutely secure connection with M, thinking that you have established a connection with B. After that, M establishes a secure connection with B and starts transmitting your requests to him, and you - his answers.  Thus, M can listen to the interaction A - B and even modify the transmitted messages. <br><br>  The logical question is whether the server substitution and Man-in-the-middle attacks are feasible in practice. <br><br>  Most likely, if both interacting servers are located in serious data centers (and if the servers themselves, of course, are not hacked), then the implementation of such an attack is very difficult.  If the server is located in your corporate, university or home network (not designed in the best way), then, say, an <a href="http://ru.wikipedia.org/wiki/ARP-spoofing">ARP attack</a> will completely allow an attacker to send all the traffic entering and leaving the network through himself, and then all these attacks become very just feasible. <br><br>  <b>So why we are not always satisfied with SSL / TLS.</b> <br><ul><li> The complexity of authentication of an arbitrary server in the application code.  As a result, a partial use of the protocol, without protection against the Man in the Middle attack. </li><li>  One-way authentication (yes, there are protocol modifications for two-way authentication, but this is used less frequently, and not all programming languages ‚Äã‚Äãcan easily find a ready-made solution). </li><li>  In addition, the SSL / TLS architecture does not allow the message to be saved with the digital signature of the sender so that it can be used later to prove that the message was actually sent by the author (i.e., the protection against repudiation does not work). </li></ul><br><h4>  Implementing safety in practice </h4><br>  So now let us briefly return to the ‚Äú <b>safe interaction</b> ‚Äù and see how the points we have identified are implemented in practice. <br><br>  1. For <b>authentication</b> , they usually use either a ‚Äúlogin-password‚Äù pair or a digital signature generated by one or another method. <br><br>  2. To verify the <b>integrity of the data</b> using SSL / TLS and generated by the application digital signatures. <br><br>  3. To <b>encrypt</b> data, that is, to <b>ensure confidentiality,</b> most systems use SSL / TLS (there are examples of self-encrypting keys, however, data is encrypted with ‚Äúits own‚Äù methods relatively rarely). <br><br>  Speaking of web services, SSL / TLS is most often used as HTTPS. <br><br><h4>  Types of protected applications </h4><br>  Before finally moving on to attacks on protocols, it is necessary to say about the limitations in which the designed system works.  I would like to mention three main types of applications for which you can consider secure communication issues. <br><br>  1. <b>Two interacting parties have the opportunity to exchange in advance a guaranteed channel with the necessary information</b> : a public key, certificates, passwords, and so on.  Such a channel can be the internal transfer of necessary information between people (best of all), an alternative communication channel (cellular, telephone) or even the Internet - if both parties are sure that there is no ‚ÄúMan in the middle‚Äù or another way to intercept or modify the message. <br><br>  2. <b>Centralized architecture</b> .  Every 2 parties do not have the opportunity to agree with each other in advance, but any network participant trusts some <b>third party</b> who signs the certificates of the interacting parties and ensures their validity.  An example is <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D1%2580%25D0%25B0%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25B9">the public key infrastructure</a> (Public Key Infrastructure, PKI) or, with some reservations, the same Internet in which browsers trust a finite number of certification authorities (CA), and on the basis of this can make sure that they interact with the desired site . <br><br>  3. <b>Decentralized architecture</b> .  In such applications there is no single third party.  It is important to understand that in such architectures the main task is to make sure that <b>the second time</b> the same person came to you that came earlier.  That is, the first time you allow anyone to authenticate (for example, on sites that support OpenID, anyone can authenticate).  Suppose further that you have made some <b>contribution to the system</b> : for example, you wrote a message.  The next time you come here, the site will have to give you (and only you) access to editing this message.  Examples of infusions: OpenID, OAuth, Peer-to-Peer protocols. <br><br><h4>  Attacks and methods of protection </h4><br>  And finally, let's consider the main types of attacks carried out on protocols - and how they are protected from them. <br><br>  <b>1. Lack of verification of the authorship or authenticity of the message</b> <br><br>  Let me remember the old joke.  In programming, there are two types of errors: the lack of validation of input data - and all other errors. <br><br>  If you received a message M from side A, then you need to make sure that: a) the message really came from A;  b) that A sent exactly the message M, and it was not changed along the way. <br><br>  An example of an illiterately designed protocol is the <a href="http://assist.ru/files/manual_new.pdf">protocol for the interaction of the</a> payment system <a href="http://assist.ru/">Assist</a> with an online store.  After paying for the purchase on the Assist server, the user returns to some URL_RETURN_OK address, which is transmitted in the clear and can be modified by the user-buyer himself.  That is, the user returns after paying for the purchase to our online store, they say to him: ‚ÄúThank you, you have just paid a payment of $ 1000,‚Äù but the store has absolutely no way to make sure that this is true.  Only later, with the hands of a manager or automated (but not more often than once in 10 minutes!), You can check that the payment has really passed.  The Assist protocol, by the way, has not been modified for more than 4 years.  All you need is to add a digital signature. <br><br>  So, how to verify the authorship and integrity of the message. <br><ul><li>  Use digital signatures on the basis of a pair of a secret and public key.  This is probably the most reliable and versatile (i.e., operating in any conditions) method.  The public key can be transmitted to the receiving party in advance ( <a href="http://webmoney.ru/">WebMoney</a> , <a href="http://www.cyberplat.ru/">Cyberplat</a> , <a href="http://oauth.net/">OAuth,</a> and many others use this method today).  Also, the public key can be obtained later via an unsecured connection and verified using a Certification Authority (CA) certificate.  This method underlies the operation of <a href="http://ru.wikipedia.org/wiki/%25D0%2598%25D0%25BD%25D1%2584%25D1%2580%25D0%25B0%25D1%2581%25D1%2582%25D1%2580%25D1%2583%25D0%25BA%25D1%2582%25D1%2583%25D1%2580%25D0%25B0_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D1%258B%25D1%2585_%25D0%25BA%25D0%25BB%25D1%258E%25D1%2587%25D0%25B5%25D0%25B9">the public key infrastructure</a> (Public Key Infrastructure, PKI) used in large companies. </li><li>  Form a common key K - for example, based on the <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B8%25D1%2584%25D1%2584%25D0%25B8_%25E2%2580%2594_%25D0%25A5%25D0%25B5%25D0%25BB%25D0%25BB%25D0%25BC%25D0%25B0%25D0%25BD%25D0%25B0">Diffie-Hellman</a> or similar protocol and use it to sign messages (for example, using <a href="http://ru.wikipedia.org/wiki/HMAC">HMAC-SHA1</a> ).  Used in <a href="http://openid.net/">OpenID</a> . </li><li>  If the integrity of the message is not important to us, but only confirmation of authorship is important, sometimes a pair of ‚Äúlogin - password‚Äù or a secret string is used to access a protected resource.  For example, <a href="http://www.flickr.com/">Flickr</a> gives photos using the XML-RPC protocol in response to a request containing a login and password.  The <a href="http://recaptcha.net/">reCAPTCHA</a> system allows you to check the CAPTCHA code entered by the user, authenticating the verifier with a secret string.  It is necessary to understand that this method, although simple, is extremely bad because intercepting a message reveals your password, and the attacker can later send requests on your behalf.  In the case of using a digital signature, intercepting the message will not allow the attacker to do anything. </li><li>  There is a simpler (albeit unprotected from server spoofing attacks and Man in the Middle) method of authenticating a message.  For example, <a href="https://www.x.com/">PayPal,</a> in its <a href="https://www.x.com/docs/DOC-1084">Instant Payment Notification</a> (IPN) protocol, requires the server accepting payment confirmation to send a copy of the message back to the server with the question ‚Äú <b>did you really send it to me</b> ?‚Äù  The same method is used in the OpenID protocol (although when working in non-recommended mode), only the message is sent back, but the message with a digital signature, and the request already looks like ‚Äú <b>check if you‚Äôve put this digital signature</b> ‚Äù.  A similar scheme works in <a href="http://dev.aol.com/api/openauth">OpenAuth</a> .  The advantage of the approach can be considered the lack of the need to implement cryptographic algorithms from one or both sides. </li><li>  <a href="http://www.robokassa.ru/">Robokassa has</a> <a href="http://www.robokassa.ru/Doc/Ru/Interface.aspx">come up with</a> its original way of generating a digital signature: a digital signature is formed as an MD5 hash function of the message and the secret password.  This method must be treated with caution, if only because the password must be sufficiently strong.  If the password is short and, moreover, if it is chosen by a person, deciphering your password can be an easy task for a hacker. </li></ul><br>  <b>2. Hope for HTTPS reliability.</b> <br><br>  As mentioned above, the implementation within the HTTPS protocol of authenticating an arbitrary server to which your application connects is a rather complicated task.  Above, we looked at the details, the brief conclusion of which is simple: without authentication of the server certificate, the meaning of HTTPS can be reduced to zero. <br><br>  None of the decentralized authentication protocols, be it OpenID, OpenAuth, OAuth, is protected from server spoofing or Man-in-the-Middle.  In some cases, payment systems (PayPal, Assist) can be attacked in a similar way.  In the end, you can convince the online store application that payment occurred, although in fact it was not. <br><br>  I emphasize once again that you can defend against this attack if the server that establishes an HTTPS connection has a sufficient number of certificates from the main CA of the Internet (VeriSign, COMODO, etc.), but in practice it is sometimes difficult to implement. <br><br>  And I stress that for <b>decentralized systems</b> this is a <b>fundamentally unsolvable problem</b> .  While for commercial payment systems belonging to our classification (see above) to systems whose parties can ‚Äú <b>agree in advance,</b> ‚Äù this attack is <b>warned by</b> competent protocol design.  An example of such an implementation is <a href="http://webmoney.ru/">WebMoney</a> , which provides a certificate for authenticating an HTTPS connection.  ( <a href="http://www.chronopay.com/">Chronopay</a> seems to do that too - correct me). <br><br>  <b>3. Attack "Man in the middle" (Man in the Middle, MITM).</b> <br><br>  We looked at the MITM attack for the HTTPS protocol.  However, other protocols may also be vulnerable to this type of attack. <br><br>  An example of this is <a href="http://ru.wikipedia.org/wiki/Diffie-Hellman">Diffie-Hellman</a> , used in OpenID.  As mentioned above, its essence is in generating a shared key K by two parties: A and B. But if we have someone ‚Äúin the middle‚Äù (M) who can change traffic, then it may turn out that A generated a common key with M K1, and B - common with M key K2.  As a result, ‚ÄúMan in the Middle‚Äù M can sign and read any data going in any direction. <br><br>  Of course, such an attack will not work in OpenID if the client and the server (OpenID Provider and Relying Party) interact via HTTPS with full certificate validation. <br><br>  <b>4. The transfer of the secret key over an open channel.</b> <br><br>  Many developers do not understand the essence of the secret key.  All security in the infrastructure using the public key is based on the fact that the interacting parties can unconditionally trust someone.  The second server, the third party is not important.  As a rule, the question of "trust" rests on the verification of a digital signature using the public key of the message subscriber.  All security can fail if this public key (certificate) is transmitted over an insecure channel and can be modified along the way. <br><br>  In the "serious" companies there are special people responsible for the transfer, storage, updating of this key.  Transmission usually occurs offline through reliable couriers. <br><br>  If you are creating a protocol for the payment system, it is ideal to transfer the public key of your server personally to the owner of an online store (on a floppy disk or flash drive) when signing a contract in the office.  Yes, for one reason or another, this is not always realistic.  Therefore, the certificate is often distributed via the Internet.  But in this case it is necessary to take all possible measures to prevent the substitution of the key.  You can not send the key by e-mail.  You can not give it to download via HTTP - only HTTPS.  The site should contain information on verification of downloaded information (for example, a hash from the key to verify its authenticity). <br><br>  <b>5. Re-send the request.</b> <br><br>  This type of attack we will look at two examples. <br><br>  Example 1: payment system.  Let me, a respectable server, want to send $ 10 through the payment system.  At the same time, I use HTTP or ‚Äúbad‚Äù HTTPS (without checking the certificate) to connect to the server of the payment system.  I honestly form a request and sign it with my certificate.  The other side receives the request, and my $ 10 leaves to the addressee.  But since I used an open protocol, the attacker was able to read my request to the server.  If this intruder wants to ruin me, he takes and sends the same request to the server of the payment system again.  The server verifies the signature (it is correct, since it is formed by the ‚Äúcorrect‚Äù server), and the other $ 10 is debited from my account. <br><br>  Example 2: OpenID protocol.  The <a href="http://openid.net/specs/openid-authentication-1_1.html">OpenID Authentication 1.1</a> protocol had the following vulnerability.  If an attacker tapped an interaction between an OpenID client (Relying Party) and an end user, he could, after some time, initiate the re-authentication of that user to the Relying Party using his OpenID.  In this case in the logs of the Relying Party would appear a record that the person went to the site.  In particularly mindless cases of implementation, the attacker could even authenticate as this user.  Yes, there are ways to protect this, but they were not stated as mandatory in the protocol. <br><br>  This vulnerability was eliminated in the <a href="http://openid.net/specs/openid-authentication-2_0.html">OpenID Authentication 2.0</a> version by introducing changes in the behavior of both the server (OpenID Provider) and the client (Relying Party).  Readers familiar with the protocol OpenID Authentication, I offer a puzzle to understand: how to implement such protection in the client OpenID version 1.1, if the server can not be modified? <br><br>  To protect against this type of attack, there are several ways. <br><ul><li>  <a href="http://www.cyberplat.ru/">Cyberplat</a> , for example, obliges its customers to insert a unique session number into each request.  This unique number is also called the word <a href="http://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a> (Number used ONCE).  Two requests with the same session number will simply refuse to process the payment system.  And the attacker will not be able to change the session number, since he is not able to generate the correct digital signature for the modified message. </li><li>  You can also use time protection by inserting a label with the current time in the request.  "Old" requests are cut off. </li><li>  OpenID 2.0 uses both of these methods to protect against this type of attack: nonce includes the current time and (optionally) a random string. </li></ul><br>  <b>6.</b> For completeness of description (and also because it is sometimes forgotten), it is worth mentioning platitudes as well.  If the system is built on the secrecy of a password or key, then this data must be reliably protected.  Setting UNIX privileges 07 to access all files on a shared hosting may result in the fact that the certificate file or password to the database where the ‚Äúsecrets‚Äù are stored reads the ‚Äúserver neighbor‚Äù.  Do not forget to set passwords, privileges, to restrict access.  However, I will not be spread for a long time, since everyone knows this (although not everyone does). <br><br>  <b>7.</b> Another type of vulnerabilities are those created by programmers when implementing a protocol.  Let me give you one simple example (fortunately, not being a serious vulnerability): 2 years ago, in two of the five most popular implementations of the OpenID server, developers confused the concepts of life_time (key lifetime in seconds) and expires_time (key expiration time in seconds from January 1, 1970).  Particularly critical parts of the code should be viewed by other participants of the project (OK, is this also a commonplace? - then we move on to the conclusion). <br><br><h4>  findings </h4><br>  The main idea that I wanted to convey in the article is that you shouldn‚Äôt rely on the developers of this or that protocol, even if the authors are companies with a big name.  Think for yourself, decide for yourself. <br><br>  A little about the practice, as well as what went beyond the article. <br><ul><li>  Public Key Infrastructure (PKI) is a solution that is striking in its scale (and, in particular, in the number of protocols).  This is probably not something worth exploring to write an automatic cross-posting service for blog headers on Twitter.  Also, you probably do not come here if we are talking about decentralized systems.  But even in this case, to familiarize yourself in general terms is useful.  You can start with <a href="http://tools.ietf.org/html/draft-ietf-pkix-roadmap-09">Internet X.509 Public Key Infrastructure: Roadmap</a> . </li><li>  Also today, a large number of standards have been developed to ensure the security of web services (primarily based on SOAP).  A lot of articles are devoted to this.  (For example, in the <a href="http://webservices.xml.com/pub/a/ws/2003/01/15/ends.html">Securing Web Services</a> note, a number of links are collected on the topic.) Therefore, before developing your solution, it may be worthwhile to get acquainted with already existing developments. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/77689/">https://habr.com/ru/post/77689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../77682/index.html">Dynamic web presentations without using Flash</a></li>
<li><a href="../77683/index.html">We build StartUp. Part 1</a></li>
<li><a href="../77684/index.html">We build StartUp. Part 2</a></li>
<li><a href="../77685/index.html">Binary upgrade from FreeBSD 6.2 to 8.0</a></li>
<li><a href="../77686/index.html">We build StartUp. Part 3</a></li>
<li><a href="../77690/index.html">ISPmanager Cluster</a></li>
<li><a href="../77693/index.html">Russian equipment. Part 1. MLink</a></li>
<li><a href="../77694/index.html">Yandex and Google: contextual advertising exchange</a></li>
<li><a href="../77695/index.html">Honeywell Users Group 2010</a></li>
<li><a href="../77697/index.html">Gameplay and psychological foundations of discomfort - part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>