<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development under WebAssembly: real rake and examples</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The WebAssembly announcement was held in 2015 - but now, after years, still few can boast of it in production. The more valuable materials about such ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development under WebAssembly: real rake and examples</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/e5/pu/-s/e5pu-s7yjpdm8dddc42_nxa1uve.jpeg"><br><br>  The WebAssembly announcement was held in 2015 - but now, after years, still few can boast of it in production.  The more valuable materials about such experience: first-hand information about what it is like to live with it in practice, is still in short supply. <br><br>  At the HolyJS conference, a report on the experience of using WebAssembly received high ratings from viewers, and now a text version of this report has been prepared specifically for Habr (the video is also attached). <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uqG9DiT80UE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      My name is Andrew, I will tell you about WebAssembly.  We can say that I started working on the web in the last century, but I am modest, so I will not say so.  During this time I managed to work on the backend, and on the front-end, and even drew a little design.  Today I am interested in things like WebAssembly, C ++ and other native things.  I also love typography and collect old equipment. <br><br>  First, I will talk about how we and the team implemented WebAssembly in our project, then we will discuss whether you need something from WebAssembly, and finish with a few tips in case you want to implement it in yourself. <br><br><h2>  How we implemented webasse assembly </h2><br>  I work for Inetra, we are in Novosibirsk and we are doing several projects of our own.  One of them is ByteFog.  This is a peer-to-peer video delivery technology for users.  Our clients are services that distribute a huge amount of video.  They have a problem: when a popular event happens, for example, someone‚Äôs press conference or a sporting event, you don‚Äôt get ready for it, a lot of clients come, rush into the server, and the server is sad.  Customers at this time receive very poor video quality. <br><br>  But everyone watches the same content.  Let's ask neighboring devices of users to share pieces of video, and then we will unload the server, save the band, and users will receive the video in better quality.  These clouds are our technology, our proxy ByteFog. <br><br><img src="https://habrastorage.org/webt/ir/yw/xl/irywxlozwzz4kbedspsf14lx4ie.png"><br><br>  We must be installed in every device that can display video, so we support a very wide range of platforms: Windows, Linux, Android, iOS, Web, Tizen.  Which language to choose in order to have a single code base on all these platforms?  We chose C ++, because it turned out to have the most advantages :-D More seriously, we have a good expertise in C ++, this is really a quick language, and in portability it is probably less than S. <br><br>  We got a pretty large application (900 classes), but it works fine.  Under Windows and Linux, we compile into native code.  Under Android and iOS, we build the library that we connect to the application.  We'll talk about Tizen another time, but on the Web we used to work as a browser plug-in. <br><br>  This is the technology of the Netscape Plugin API.  As the name implies, it is quite old and also has a drawback: it gives very wide access to the system, so user code can cause a security problem.  Perhaps that is why in 2015, Chrome turned off support for this technology, and then all browsers joined this flashmob.  So we were left without a web version for almost two years. <br><br>  In 2017, a new hope has dawned.  As you might guess, this is WebAssembly.  As a result, we set ourselves the task of porting our application to the browser.  Since the spring has already appeared support for Firefox and Chrome, and by the fall of 2017, Edge and Safari were pulled up. <br><br>  It was important for us to use ready-made code, since we have a lot of business logic, which we didn‚Äôt want to double, in order not to double the number of bugs.  We take the Emscripten compiler.  It does what we need - it compiles the positive application into the browser and recreates the environment familiar to the native application in the browser.  We can say that Emscripten is such a Browserify for C ++ code.  It also allows you to forward objects from C ++ to JavaScript and vice versa.  Our first thought was: now we take Emscripten, just compile, and it will work.  Of course, it didn't.  With this, our path began on a rake. <br><br>  The first thing we encountered was dependencies.  There were several libraries in our codebase.  Now it makes no sense to list them, but for those who understand, we have Boost.  This is a large library that allows you to write cross-platform code, but with it it is very difficult to customize the compilation.  I wanted to drag as little code as possible into the browser. <br><br><h3>  Architecture bytefog </h3><br>  As a result, we have identified the core: we can say that this is a proxy server, which contains the main business logic.  This proxy server takes data from two sources.  The first and the main one is HTTP, that is, the channel to the video distribution server, the second is our P2P network, that is, the channel to another similar proxy from some other user.  We give the data first to the player, since our task is to show quality content to the user.  If resources remain, we distribute content to the P2P network so that other users can download it.  Inside is a smart cache that does all the magic. <br><br><img src="https://habrastorage.org/webt/vi/id/zt/viidzt9cctzun2_em3ka8jfm8pu.png"><br><br>  Compiling this all, we are faced with the fact that WebAssembly is performed in the sandbox of the browser.  So, can not more than gives JavaScript.  While native applications use many platform-specific things, such as the file system, the network, or random numbers.  All these features will have to be implemented in JavaScript using what the browser gives us.  In this tablet listed fairly obvious replacements. <br><br><img src="https://habrastorage.org/webt/ii/uv/bf/iiuvbfvwjvul6pbnkuptqku8amo.png"><br><br>  To make this possible, it is necessary in the native application to saw off the implementation of the native capabilities and insert an interface there, that is, to draw a certain border.  Then you implement it in JavaScript and leave the native implementation, and then when you build it, you choose the right one.  So, we looked at our architecture and found all the places where you can draw this border.  Coincidentally, this is a transport subsystem. <br><br><img src="https://habrastorage.org/webt/ok/eq/w-/okeqw-dc-weuwlqxed4iy2x5nn4.png"><br><br>  For each such place we defined the specification, that is, we fixed the contract: what would be the methods, what parameters would they have, what types of data.  Once you have done this, you can work in parallel, each developer on his side. <br><br>  What was the result?  We replaced the main delivery channel of the video from the provider with the usual AJAX.  We provide data to the player through the popular HLS.js library, but there is a fundamental opportunity to integrate with other players, if necessary.  We replaced the whole P2P layer with WebRTC. <br><br><img src="https://habrastorage.org/webt/g8/dc/mt/g8dcmtbxfugjxpycyzpabtb6nto.png"><br><br>  Compiling results in multiple files.  The most important is the binary .wasm.  It contains a compiled bytecode that the browser will execute and which contains all of your C ++ legacy.  But by itself it does not work, the so-called ‚Äúglue code‚Äù is necessary, it is also generated by the compiler.  The glue code is loading a binary file, and you upload both of these files to production.  For debugging purposes, you can generate a textual representation of the assembler ‚Äî the .wast file and the sourcemap.  You need to understand that they can be very large.  In our case, reached 100 megabytes or more. <br><br><h3>  We are going to bundle </h3><br>  Consider the glue code closer.  This is the usual good old ES5, collected in one file.  When we connect it to a web page, we have a global variable, which contains all our instantiated wasm-module, which is ready to accept requests to its API. <br><br>  But connecting a separate file is quite a serious complication for the library that users will use.  We would like to collect everything in a single bundle.  For this we use a Webpack and a special compilation option MODULARIZE. <br><br>  It wraps the glue code into the ‚ÄúModule‚Äù pattern, and we can pick it up: import or use require, if we write to ES5, - Webpack easily understands this dependency.  There was a problem with Babel, - he didn‚Äôt like the large amount of code, but this is an ES5-code, it doesn‚Äôt need to be translated, we just add it to the ignore list. <br><br>  In pursuit of the number of files, I decided to use the SINGLE_FILE option.  All the binaries that came out when compiled, it translates into Base64-view and pushes the glue code as a string.  It sounds like a great idea, but after that the bundle with us became 100 megabytes.  Neither Webpack, nor Babel, nor even the browser work on such a volume.  And in general, we will not force the user to load 100 megabytes? <br><br>  If you think about it, then this option is not needed.  Glue code downloads binary files.  It does this via HTTP, which means we get caching out of the box, we can set any headers we want, for example, enable compression, and WebAssembly files are perfectly compressed. <br><br>  But the coolest technology is stream compilation.  That is, the WebAssembly file, while being downloaded from the server, may already be compiled in the browser as data is received, and this greatly speeds up the loading of your application.  In general, the whole WebAssembly technology has a focus on the quick start of a large code base. <br><br><h3>  Thenable </h3><br>  Another problem with the module is that it is a Thenable object, that is, it has a .then () method.  This function allows you to hang a callback at the time of the start of the module, and it is very convenient.  But I would like the interface to match Promise.  Thenable is not a Promise, but do not worry, we wrap ourselves.  Let's write this simple code: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> { Module(config).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">module</span></span></span></span></span><span class="hljs-function">) =&gt;</span></span> { resolve(<span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); }); });</code> </pre> <br>  We create a Promise, we start our module, and as a callback we call the function resolve and pass there the module that we instantiated.  Everything seems to be obvious, everything is fine, we are launching - something is wrong, our browser is hanging, DevTools are hanging, and the computer is warming up the processor.  We understand nothing - some kind of recursion or an infinite loop.  Debugging is quite difficult, and when we interrupted JavaScript, we found ourselves in the Then function in the Emscripten module. <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'then'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); }; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Module; };</code> </pre><br>  Let's look at it in more detail.  Plot <br><br><pre> <code class="javascript hljs">Module[<span class="hljs-string"><span class="hljs-string">'onRuntimeInitialized'</span></span>] = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ func(Module); };</code> </pre><br>  responsible for hanging callback.  Everything is clear here: an asynchronous function that calls our callback.  Everything we want.  There is another part of this function. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Module[<span class="hljs-string"><span class="hljs-string">'calledRun'</span></span>]) { func(Module);</code> </pre><br>  It is called when the module has already started.  Then the callback is synchronously called immediately, and the module is passed to the parameter.  This simulates the behavior of Promise, and seems to be what we expect.  But what then is wrong? <br><br>  If you carefully read the documentation, it turns out that there is a very subtle point about Promise.  When we resolve a Promise using a Thenable object, the browser will expand the values ‚Äã‚Äãfrom this Thenable object, and for this it will call the .then () method.  As a result, we rezolvim Promise, pass him a module.  The browser asks: Is this objectable?  Yes, this is the Thenable object.  Then the module calls the .then () function, and the function itself is passed as the callback. <br><br>  The module checks if it is running.  It is already running, so the callback is called immediately, and the same module is transmitted to it again.  As a callback, we have the function resolve, and the browser asks: is this a Thenable object?  Yes, this is the Thenable object.  And it all starts again.  As a result, we fall into an infinite loop from which the browser never returns. <br><br><img src="https://habrastorage.org/webt/ks/rr/c-/ksrrc-zeix0ffh_uott4ahpt3qc.png"><br><br>  I did not find an elegant solution to this problem.  As a result, I simply delete the .then () method in front of the resolve, and it works. <br><br><h3>  Emscripten </h3><br>  So, we compiled the module, compiled JS, but something is missing.  Perhaps we need to do some useful work.  To do this, you need to transfer data and link the two worlds - JS and C ++.  How to do it?  Emscripten provides three options: <br><br><ul><li>  The first is the ccall and cwrap functions.  Most often you will meet them in some tutorials on WebAssembly, but they are not suitable for real work, as they do not support the C ++ features. </li><li>  The second is WebIDL Binder.  It already supports C ++ functions, it is already possible to work with it.  This is a serious interface description language used, for example, by the W3C for its documentation.  But we did not want to carry it into our project and used the third option. </li><li>  Embind.  We can say that this is a native way of connecting objects for Emscripten, it is based on C ++ templates and allows you to do a lot of things by forwarding different entities from C ++ to JS and back. </li></ul><br><br>  Embind allows you to: <br><br><ul><li>  Call C ++ functions from JavaScript </li><li>  Create JS objects from C ++ class </li><li>  From C ++ code, you can access the browser's API (if for some reason you want this, you can, for example, write a front-end framework entirely in C ++). </li><li>  The main thing for us is to implement the JavaScript interface described in C ++. </li></ul><br><br><h3>  Data exchange </h3><br>  The last point is important, since this is exactly the action that you will constantly do when porting the application.  Therefore, I would like to dwell on it in more detail.  There will now be C ++ code, but don't be scared, it's almost like TypeScript :-D <br><br>  The scheme is as follows: <br><br><img src="https://habrastorage.org/webt/y8/b9/w7/y8b9w7ztnudrlcv5p0zzsezuzkm.png"><br><br>  On the C ++ side, there is a kernel to which we want to give access, for example, to an external network ‚Äî to shake a video.  Previously, it did this using native sockets, there was some HTTP client that did this, but there are no native sockets in WebAssembly.  We need to somehow get out, so we cut off the old HTTP client, insert the interface into this place, and implement the implementation of this interface in JavaScript using ordinary AJAX, in any way.  After that, we will pass the received object back to C ++, where the kernel will use it. <br><br>  Let's make the simplest HTTP client that can only get get requests: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTTPClient</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre><br>  At the input, it takes a string with the URL to download, and at the output <br>  string with the result of the query.  In C ++, strings may have binary data, so this is appropriate for video.  Emscripten makes us write here <br>  such a terrible wrapper: <br><br><img src="https://habrastorage.org/webt/m_/dz/hg/m_dzhg7a0xrywq8rirnyeh1rswa.png"><br><br>  The main thing in it is two things - the name of the function on the C ++ side (I marked them in green), and the corresponding names on the JavaScript side, (marked them in blue).  As a result, we write a communication declaration: <br><br><img src="https://habrastorage.org/webt/am/ob/qz/amobqzp-sx-3w12rnljcxlfh-fk.png"><br><br>  It works like Lego cubes, from which we assemble it.  We have a class, this class has a method, and we want to inherit from this class to implement the interface.  It's all.  We go to javascript and inherit.  This can be done in two ways.  The first is extend.  This is very similar to the good old extend from Backbone. <br><br><img src="https://habrastorage.org/webt/rt/6p/fi/rt6pfi7s3sfipms3y8lfusrqgy8.png"><br><br>  The module contains everything compiled with Emscripten, and it has a property with an exported interface.  We call the extend method and pass an object there with the implementation of this method, that is, some method will be implemented in the get function <br>  getting information using AJAX. <br><br>  At the output, extend gives us the usual JavaScript constructor.  We can call it as many times as necessary and generate objects in the quantity we need.  But there is a situation when we have one object, and we want to simply transfer it to the C ++ side. <br><br><img src="https://habrastorage.org/webt/ky/ct/es/kycteslqo9rkbq5nyj1ilflq7g0.png"><br><br>  To do this, you must somehow bind this object to a type that C ++ understands.  This is what the implement function does.  At the output, it gives not a constructor, but an object already ready for use, our client, which we can give back to C ++.  You can do this, for example, like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> app = Module.makeApp(client, ‚Ä¶)</code> </pre><br>  Suppose we have a factory that creates our application, and it accepts its dependencies in the parameters, for example, client and something else.  When this function runs, we get the object of our application, which already contains the API that we need.  You can do the opposite: <br><br><pre> <code class="cpp hljs">val client = val::global(‚Ä≥client‚Ä≥); client.call&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;(‚Ä≥get‚Ä≥, val(...) );</code> </pre><br>  Directly from C ++ take our client from the browser global scope.  And in place of the client, there can be any browser API, starting from the console, ending with the DOM API, WebRTC - whatever you want.  Next, we call the methods that this object has, and we wrap all the values ‚Äã‚Äãin the magic class val, which provides us with Emscripten. <br><br><h3>  Binding errors </h3><br>  In general, this is all, but when you start developing, you are confronted with binding errors.  They look something like this: <br><br><img src="https://habrastorage.org/webt/bi/jy/uj/bijyujpafhw1vljtsptpvuzxztw.png"><br><br>  Emscripten tries to help us and explain what is going wrong.  If this is all summed up, then you need to make sure that they match (it is easy to seal up and get a binding error): <br><br><ul><li>  Names </li><li>  Types </li><li>  Number of parameters </li></ul><br>  Embind syntax is unusual not only for front-end vendors, but also for people who deal with C ++.  This is a DSL, in which it is easy to make a mistake, you need to follow this.  Speaking of interfaces, when you implement some kind of interface in JavaScript, you need to match it exactly to what you described in your contract. <br><br>  We had an interesting case.  My colleague Jura, who was involved in the project on the part of C ++, used Extend to test its modules.  They worked well for him, so he committed them and gave them to me.  I used implement to integrate these modules into the JS project.  And they stopped working for me.  When we figured out, it turned out that when we binded the names of the functions, there was a typo. <br><br>  As we see from the name, Extend is an extension of the interface, so if you have sealed it somewhere, Extend will not give an error, it will decide that you just added a new method, and everything is fine. <br><br>  That is, it hides the binding errors until the method itself is called.  I suggest using Implement in all cases where it suits you, as it immediately checks the correctness of the interface that was thrown.  But if you need an Extend, you need to cover the challenge of each method with tests so as not to screw up. <br><br><h3>  Extend and ES6 </h3><br>  Another problem with Extend is that it does not support ES6 classes.  When you inherit an object spawned from an ES6 class, Extend expects all properties to be enumerated in it, but this is not the case with ES6.  Methods are in the prototype, and they have enumerable: false.  I use this crutch, in which I go over the prototype and turn on enumerable: true: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enumerateProto</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(obj.prototype) .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.defineProperty(obj.prototype, prop, {<span class="hljs-attr"><span class="hljs-attr">enumerable</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}) ) }</code> </pre><br>  I hope someday you can get rid of it, since there is talk in the Emscripten community about improving support for ES6. <br><br><h3>  RAM </h3><br>  Speaking of C ++, you can not affect the memory.  When we checked everything on SD-quality video, everything was perfect, it worked just perfect!  As soon as we did the FullHD test, a memory shortage error.  It does not matter, there is an option TOTAL_MEMORY, which sets the starting value of the memory for the module.  We made half a gigabyte, everything is fine, but somehow it is inhumane for users, because we reserve memory for everyone, but not everyone has a subscription to FullHD content. <br><br>  There is another option - ALLOW_MEMORY_GROWTH.  It allows you to grow memory <br>  gradually as needed.  It works like this: Emscripten by default gives the module 16 MB to work.  When you all use them, a new piece of memory is allocated.  All the old data is copied there, and you still have the same amount of space for the new ones.  This happens until you reach 4 GB. <br><br>  Suppose you allocated 256 megabytes of memory, but you know for sure that you thought that 192 is enough for your application. Then the remaining memory will be used inefficiently.  You have allocated it, taken away from the user, but do not do anything with it.  I would like to somehow avoid it.  There is a small trick: we begin work with memory increased by one and a half times.  Then in the third step we reach 192 megabytes, and this is exactly what we need.  We reduced the memory consumption for the remainder and saved the extra memory allocation, and the farther, the longer they take.  Therefore, I recommend using both of these options together. <br><br><h3>  Dependency Injection </h3><br>  It would seem that all, but then the rake went further.  There is a problem with Dependency Injection.  We write the simplest class in which dependency is needed. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient } }</code> </pre><br>  For example, we transfer our HTTP client to our application.  Save to class property.  It would seem that everything will work well. <br><br><pre> <code class="javascript hljs">Module.App.extend( ‚Ä≥App‚Ä≥, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App(client) )</code> </pre><br>  We inherit from the interface in C ++, first create our object, pass it a dependency, and then inheritance.  At the time of inheritance, Emscripten does something incredible with the object.  The easiest way to think is that he is killing an old object, creating a new one based on his template and dragging all public methods there.  But at the same time the state of the object is lost, and you get an object that is not formed and does not work correctly.  To solve this problem is quite simple.  It is necessary to use a constructor that works after the inheritance stage. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span></span>{ _construct(httpClient) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.httpClient = httpClient <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._parent._construct.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) } }</code> </pre><br>  We do almost the same thing: we keep the dependency in the field of the object, but this is the object that turned out after inheritance.  One should not forget to forward the constructor call to the parent object, which is on the C ++ side.  The last line is an analogue of the super () method in ES6.  This is how inheritance occurs in this case: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> appConstr = Module.App.extend( ‚Ä≥App‚Ä≥, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> App() ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> appConstr(client)</code> </pre><br>  At first, we inherit, then we create a new object, to which we are already passing the dependency, and it works. <br><br><h3>  Trick with pointer </h3><br>  Another problem is passing objects by pointer from C ++ to JavaScript.  We have already made an HTTP client.  To simplify, we missed one important detail. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url)</span></span></span></span></code> </pre><br>  The method returns the value immediately, that is, it turns out that the request must be synchronous.  But AJAX requests are for AJAX, that they are asynchronous, so in real life the method will return either nothing, or we can return the request ID.  But in order for someone to return the answer, we pass the second parameter to the listener, in which there will be a callback from C ++. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> url, Listener listener)</span></span></span></span></code> </pre><br>  In JS, it looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ fetch(url).then(result) =&gt; { listener.onResult(result) }) }</code> </pre><br>  We have a get function that accepts this listener object.  We start downloading the file and hang up the callback.  When the file is downloaded, we pull the listener to the desired function and pass the result to it. <br><br>  It would seem that the plan is good, but when the get function completes, all local variables will be destroyed, and with them the function parameters, that is, the pointer will be destroyed, and the runtime emscripten will destroy the object on the C ++ side. <br><br>  As a result, when it comes to calling the listener.onResult (result) line, the listener will no longer exist, and accessing it will result in a memory access error, which will cause the application to crash. <br><br>  I would like to avoid this, and there is a solution, but it took several weeks to find it. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, listener</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> listenerCopy = listener.clone() fetch(url).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { listenerCopy.onResult(result) listenerCopy.delete() }) }</code> </pre><br>  It turns out there is a pointer cloning method.  For some reason, it is not documented, but it works fine, and allows you to increase the reference count in the Emscripten index.  This allows you to hang it in the closure, and then when we start our callback, our listener will be accessible by this pointer and you can work as we need. <br><br>  The most important thing is to remember to delete this pointer, otherwise it will lead to a memory leak error, which is very bad. <br><br><h3>  Quick write to memory </h3><br>  When we download videos, these are relatively large amounts of information, and I would like to reduce the amount of data copying back and forth to save both memory and time.  There is one trick how to write a large amount of information directly to the WebAssembly's memory from JavaScript. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>(‚Ä¶); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> size = newData.byteLength; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ptr = Module._malloc(size); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> memory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Uint8Array</span></span>( Module.buffer, ptr, size ); memory.set(newData);</code> </pre><br>  newData is our data in the form of a typed array.  We can take its length and request the memory allocation of the size we need from the WebAssembly module.  The malloc function will return a pointer to us, which is simply an array index that contains all of the WebAssembly's memory.  From the JavaScript side, it just looks like an ArrayBuffer. <br><br>  With the next action, we will open a window into this ArrayBuffer of the required size from a certain place and copy our data there.  Despite the fact that the set operation has copy semantics, when I looked at this site in the profiler, I did not see a long process.  I think that the browser optimizes this operation with the help of move-semantics, that is, it transfers ownership of memory from one object to another. <br><br>  And in our application, we also rely on move-semantics to save copying memory. <br><br><h3>  Adblock </h3><br>  An interesting problem, rather, on change, with Adblock.  It turns out that all popular blockers in Russia receive a subscription to the RU Adlist list, and there is such an excellent rule in it that prohibits downloading WebAssembly from third-party sites.  For example, from CDN. <br><br><img src="https://habrastorage.org/webt/os/wt/kg/oswtkgtaeovfuk9r4d-gehdwdwe.png"><br><br>  The solution is not to use a CDN, but to store everything on your domain (this does not suit us).  Or rename the .wasm file so that it does not fit this rule.  You can still go to the forum of these comrades and try to convince them to remove this rule.  I think they justify themselves by the fact that they are struggling with miners in this way, however, I don‚Äôt know why miners cannot guess to rename the file. <br><br><h2>  Production </h2><br>  In the end, we went into production.  Yes, it was not easy, it took 8 months and I want to ask myself if it was worth it.  In my opinion - it was worth: <br><br><h3>  No need to install </h3><br>  We received that our code is delivered to the user without installing any programs.  When we had a browser plugin, the user had to download and install it, and this is a huge filter for disseminating technology.  Now the user just watches the video on the site and does not even understand that the whole machinery is working under the hood, and that everything is complicated there.  The browser simply downloads an additional file with a code, like a picture or .css. <br><br><h3>  Single code base and debugging across platforms </h3><br>  At the same time, we managed to maintain our single code base.  We can twist the same code on different platforms and it has repeatedly happened that bugs that were invisible on one of the platforms appeared on the other.  And, thus, we can reveal hidden bugs with different tools on different platforms. <br><br><h3>  Quick release </h3><br>  We received a quick release, since we can be released as a simple web application and update C ++ code with each new release.  It doesn‚Äôt compare with how to release new plugins, mobile app or SmartTV app.  The release depends only on us: when we want, then it will come out. <br><br><h3>  Fast feedback </h3><br>  And that means quick feedback: if something goes wrong, we can find out during the day that there is a problem and respond to it. <br><br>  I believe that all these problems were worth these advantages.  Not everyone has a C ++ application, but if you have one, and you want it to be in the browser, WebAssembly is one hundred percent use case for you. <br><br><h2>  Where to apply </h2><br>  Not everyone writes in C ++.  But not only C ++ is available for WebAssembly.  Yes, this is historically the very first platform that was available even in asm.js - the early Mozilla technology.  By the way, so she has pretty good tools, because  they are older than the technology itself. <br><br><h3>  Rusty </h3><br>  The new language Rust, which also develops Mozilla, is now catching up and surpasses C ++ in terms of tools.  Everything goes to the fact that they will make the coolest development process for WebAssembly. <br><br><h3>  Lua, Perl, Python, PHP, etc. </h3><br>  Almost all languages ‚Äã‚Äãthat are interpreted are already available in WebAssembly, since their interpreters are written in C ++, they were simply compiled into WebAssembly and now you can turn PHP into a browser. <br><br><h3>  Go </h3><br>  In version 1.11, they made a beta version of the compilation in WebAssembly, in 2.0 they promise release support.  They got support later, because WebAssembly does not support garbage collector, and Go does not have a memory-managed language.  Therefore, they had to drag their garbage collector under WebAssembly. <br><br><h3>  Kotlin / Native </h3><br>  About the same story with Kotlin.  Their compiler has experimental support, but they also have to do something with the garbage collector.  I do not know what the status is there. <br><br><h3>  3D graphics </h3><br>  What else can you think of?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing that turns in the language - 3D applications. </font><font style="vertical-align: inherit;">And, indeed, historically, asm.js and WebAssembly began with porting games to browsers. </font><font style="vertical-align: inherit;">And it is not surprising that now all popular engines have export to WebAssembly.</font></font><br><br><img src="https://habrastorage.org/webt/lt/u2/7q/ltu27qaab_yjbryhnm_ayf-edsa.png"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Processing data locally </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also come up with the processing of user data directly from him in the browser on his computer: take the downloaded image or from the camera, record sound, process the video. </font><font style="vertical-align: inherit;">Read the archive downloaded by the user, or compile it yourself from a pack of files and upload to the server in one request.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neural networks </font></font></h3><br><br><img src="https://habrastorage.org/webt/2u/mi/dz/2umidzjddihmiikdgktwjdk4hpe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This picture shows almost all neural network architectures. </font><font style="vertical-align: inherit;">And, indeed, you can take your neural network, train it and give it to the client so that it processes the live stream from a video camera or microphone. </font><font style="vertical-align: inherit;">Or, for example, track the movement of the user's mouse and control gestures; </font><font style="vertical-align: inherit;">face recognition - the possibilities are almost endless. </font></font><br><br><img src="https://habrastorage.org/webt/0q/-e/0s/0q-e0sqshcd_t-p4ioyhtoe0z-k.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, a piece of Google Chrome, which is responsible for determining the language of the text, is already available as a WebAssembly library. </font><font style="vertical-align: inherit;">It can be connected as an npm-module and that's it, you use Wasm, but you work with regular JS. </font><font style="vertical-align: inherit;">You do not connect with neural networks, C ++ or something else - everything is available out of the box. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a popular HunSpell spelling library - just install and use it as a Wasm module.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cryptography </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, the first rule of cryptography - "Do not write your cryptography." </font><font style="vertical-align: inherit;">If you want to sign user data, encrypt something and send it to the server in such a form, generate strong passwords or need GOST, connect OpenSSL. </font><font style="vertical-align: inherit;">There is already an instruction on how to compile for WebAssembly. </font><font style="vertical-align: inherit;">OpenSSL is a robust code, proven by thousands of applications, you don‚Äôt need to invent anything.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Removal of calculations from the server </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cool use case is on the site wotinspector.com. This is a service for players of World of Tanks. You can upload your replay, analyze it, collect statistics on the game, draw a beautiful map, in general, a very useful service for professional players. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One problem - the analysis of such replay takes a lot of resources. If this happened on the server, it would probably be a closed paid service, not available to everyone. But the author of this service, Andrei Karpushin, wrote business logic in C ++, compiled it into WebAssembly, and now the user can start processing directly in his browser (and send to the server so that other users can access them).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an interesting case in terms of monetizing the site. Instead of taking money from users, we use the resources of their computer. This is similar to monetization with the help of a miner. But unlike the miner, who simply burns electricity from users, and in return brings the authors of the site a penny, we make a service that does the work really necessary to the user. That is, the user agrees to share resources with us. Therefore, this scheme works.</font></font><br><br><h3>  Libraries </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also in the world there are a lot of libraries written over a long history in C, C ++. For example, the project FFmpeg, which is the leader in video processing. Many people use programs for video processing, where inside ffmpeg. And here it can be run in the browser and encode the video. It will be long and slow, yes, but if you make a service that generates avatars or three-second videos, then the browser resources will be enough.</font></font><br><br><img src="https://habrastorage.org/webt/aa/tu/u8/aatuu8b5uzbxmnhv_8mjb93jcxa.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same with audio - you can record in a compressed format and send already small files to the server. </font><font style="vertical-align: inherit;">And the OpenCV library is the leader in machine vision, available in WebAssembly, you can do face recognition and gesture control. </font><font style="vertical-align: inherit;">You can work with PDF. </font><font style="vertical-align: inherit;">You can use a SQLite file database that supports true SQL. </font><font style="vertical-align: inherit;">SQLite porting under WebAssembly was made by Emscripten, he probably tested the compiler on it.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Node.js </font></font></h3><br><br><img src="https://habrastorage.org/webt/dl/mf/tn/dlmftnxe8bjvt-ys-jyyy-aunde.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Not only does the browser receive bonuses from WebAssembly, you can also use Node.js. Probably everyone knows Sass - the preprocessor css. It was written in Ruby, and then rewritten in C ++ to speed up (the libsass project). But no one wants to run a separate program for processing source codes, I want to integrate into the build process of the bundle with Webpack, and for this you need a module for Node.js. The </font></font><a href="https://github.com/sass/node-sass"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">node-sass project</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solves this problem; it is a JS wrapper for this library. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The library is native, which means we must compile it under the platform under which the user will run it. And that brings us to the matrix of versions. These columns need to be multiplied:</font></font><br><br><img src="https://habrastorage.org/webt/bv/s0/rp/bvs0rpy6naa9-dhac6zingbv-cw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This leads to the fact that for a single release of node-sass you need to do about 100 compilations for each combination from the table. </font><font style="vertical-align: inherit;">Then all this needs to be stored, and these are dozens of megabytes of files for each (even minor) release. </font><font style="vertical-align: inherit;">How WebAssembly solves this problem: it collapses the entire table into one file, because the executable file WebAssembly does not depend on the platform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is enough to compile the code once and upload only one file to all platforms regardless of the architecture or version of Node. </font><font style="vertical-align: inherit;">Such a project is already there, porting for WebAssembly is already being done in the </font></font><a href="https://github.com/kwonoj/libsass-asm"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libsass-asm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The work is being done recently, and the project needs helpers to work. </font><font style="vertical-align: inherit;">This is a great chance to practice with WebAssembly on a real project ...</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Application acceleration </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a popular application Figma - graphics editor for web-designers. This is to some extent an analogue of Sketch, which works on all platforms, because it runs in a browser. It is written in C ++ (which few people know about), and asm.js was originally used there. The application is very large, so it did not start quickly. </font></font><br><br><img src="https://habrastorage.org/webt/ht/ad/2t/htad2t3hmsfx_txwjfhk-_qlh2w.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When WebAssembly appeared, the developers recompiled their sources, and the application launch accelerated 3 times. This is a major improvement for the editor, which should be ready to work as quickly as possible.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another familiar Visual Studio Code application, despite the fact that it works in Electron, uses native modules for the most critical sections of code, so they have the same problem with a huge number of versions, like Node-sass. </font><font style="vertical-align: inherit;">Perhaps, developers control only the Node version, but to support OS platforms and architectures, they have to rebuild these modules. </font><font style="vertical-align: inherit;">Therefore, I am sure that the day when they will also go to WebAssembly is not far off.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Porting applications to the browser </font></font></h3><br><br><img src="https://habrastorage.org/webt/tz/qg/2a/tzqg2a7sw01qlqnvwjcjzkxqkyw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But the coolest example of porting a code base is AutoCAD. The software is already 30 years old, it is written in C ++, and this is a huge code base. The product is very popular among designers whose habits have long been established, so the development team would have to do a lot of work on porting all the accumulated business logic to JavaScript, when porting to the browser, which made this idea almost hopeless. But now, thanks to WebAssembly, </font></font><a href="https://web.autocad.com/login"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AutoCAD is available as a web service</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where you can register and start using it in 5 minutes.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a cool demo that Fabrice Bellard made, a unique programmer, in my opinion, because he has done so many popular projects that an ordinary programmer does, perhaps, one in his life. I mentioned FFMpeg - this is his project, and his other development is QEMU. Perhaps few people have heard of it, but it is based on the KVM virtualization system, which is certainly a leader in its field. </font></font><br><br><img src="https://habrastorage.org/webt/zq/3c/aj/zq3cajq6z-ftdftt0a1bnveqj1m.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bellard has been supporting the </font></font><a href="https://bellard.org/jslinux/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QEMU browser port</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> since 2011 </font><font style="vertical-align: inherit;">. This means that you can run any system using the emulator directly in your browser. In general, </font></font><a href="https://bellard.org/jslinux/buildroot-x86.cfg"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux with a console</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a real Linux kernel running in a browser without a server, is some kind of additional connection.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can turn off the Internet, and it will work. </font><font style="vertical-align: inherit;">There is a bash, you can do everything that is in normal Linux. </font><font style="vertical-align: inherit;">There is </font></font><a href="https://bellard.org/jslinux/buildroot-x86-xwin.cfg%26graphic%3D1"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">another demo - with GUI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It is already possible to launch a real browser. </font><font style="vertical-align: inherit;">Unfortunately, there is no network in the demo, and you won‚Äôt be able to open yourself in it ... </font></font><br><br><img src="https://habrastorage.org/webt/jf/zc/bo/jfzcbori9ee4oah-1nmumj8ebqk.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, to convince you, I will show you something incredible. </font></font><a href="https://bellard.org/jslinux/win2k.cfg%26mem%3D192%26graphic%3D1%26w%3D1024%26h%3D768"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is Windows 2000</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the same one that was 18 years ago, only now it works in your browser. </font><font style="vertical-align: inherit;">Previously, a whole computer was needed, and now Chrome (or FireFox) is quite sufficient. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, there are lots of applications for WebAssembly, I just listed what I found myself, and you will have new ideas, and you can implement them.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How to implement it at home </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I want to give some tips for those who want to port their application to WebAssembly. The first thing to start with is with the team, of course. The minimum team is two people, one from the side of native technologies and a fronder. </font></font><br><br><img src="https://habrastorage.org/webt/ea/ls/ak/ealsak2klb2rgvobxmirs1rn0_s.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It happens that C ++ application programmers are not very well versed in web technologies. Therefore, our task as front-tenders, if we find ourselves in such a project is to take on this part of the work. But the ideal team is those people who are interested not only in their platform, but also want to understand the one on the other side of the compiler.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortunately, in our project it turned out that way. </font><font style="vertical-align: inherit;">My colleague Yura, a great C ++ specialist, as it turned out, had long wanted to learn JavaScript, and Flanagan's book helped him a lot. </font><font style="vertical-align: inherit;">I took a small volume of Straustrup, and with Yurina, I began to delve into the basics of C ++. </font><font style="vertical-align: inherit;">As a result, during the project, we talked a lot about our main languages ‚Äã‚Äãto each other, and found surprisingly much in common with JS and C ++, however strange it may seem. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if you pick up just such a team - it will be perfect.</font></font><br><br><img src="https://habrastorage.org/webt/fx/nj/wb/fxnjwbotpkneisrtmlze8-0afdy.png"><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CI Pipeline </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What did our daily development process look like? We brought all the JS artifacts to a separate repository, so that it would be more convenient to configure the assembly through the Webpack. When changes appear in the native code, we tighten them, compile them (sometimes it takes the most time), and the result of the compilation is copied to the JS project. Then it is picked up by the webpack in watch mode, it assembles a bundle, and we can launch the application in the browser or run the tests.</font></font><br><br><img src="https://habrastorage.org/webt/zv/s_/r4/zvs_r45efsroktebku2lrdmuv9e.png"><br><br><h2>  Debugging </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, debugging is important for us when developing. With this, unfortunately, is not very good. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is necessary to enable DevTools experiments in Chrome, and we will see the folder with wasm-units on the Sources tab. We see breakpoints (we can stop the browser in some place), but, unfortunately, we see the code in the textual representation of the assembler. </font></font><br><br><img src="https://habrastorage.org/webt/ea/ir/8u/eair8uahusoyylejgtccro0g1-a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Although our architect Kolya, when he looked at this picture for the first time, ran his eyes over the listing and said: ‚ÄúLook, this is a stack machine, here we are working with memory, here is arithmetic, everything is clear!‚Äù. In general, Kohl is able to write under the embedded-system, but we do not know how, and would like some kind of explicit binding to the source code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a small trick: at the maximum debug level -g4 additional comments appear in the wast-file, and it looks like this.</font></font><br><br><img src="https://habrastorage.org/webt/0k/6w/af/0k6wafnm3pp62o-a5t8dcoxivxy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You need an editor that can open a file of 100 megabytes in size (we chose FAR). </font><font style="vertical-align: inherit;">The numbers are the numbers of the modules that we have already seen in the Chrome console. </font><font style="vertical-align: inherit;">E: / _ work / bfg / bytefrog / ... - link to the source code. </font><font style="vertical-align: inherit;">You can live with this, but I would like to see the real C ++ code right in the browser debugger. </font><font style="vertical-align: inherit;">And that sounds like a task for SourceMap!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sourcemap </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unfortunately, there are problems with them. </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Works only in Firefox. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The --sourcemap-base = http: // localhost option specifies that we need to generate the SourceMap and the address of the web server where the sources will be stored. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Access to source code via HTTP. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Paths to source files must be relative. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On Windows, there is a problem with ":" in the paths. </font><font style="vertical-align: inherit;">All paths are truncated to colon.</font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last two points touched us. CMake in the assembly brings all the paths to an absolute form, as a result, the files can not be found at the URL on the web server. We decided it this way: we pre-process the wast-file and all the paths are reduced to a relative view, removing at the same time the colon. I think you will not come across this. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, it looks like this: </font></font><br><br><img src="https://habrastorage.org/webt/ev/hn/fo/evhnfovmbp4hdynewi_r6buhx_a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C code ++ in the browser debugger. Now we have seen everything! On the left, the source tree, there are breakpoints, we see the stack trace, which led to this point. Unfortunately, if we touch any wasm call in the stack trace, we fail into an assembler, this is an annoying bug that I think will be healthy.</font></font><br><br><img src="https://habrastorage.org/webt/ql/zi/x8/qlzix8vqcrbdziehrmmrmq4uz0a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unfortunately, another bug will not be fixed - SourceMap fundamentally does not support the connection of variables. </font><font style="vertical-align: inherit;">We see that local variables have lost not only their names, but also their types. </font><font style="vertical-align: inherit;">Their meanings are presented as a signed integer, and we will not know what was really there. </font></font><br><br><img src="https://habrastorage.org/webt/vk/e4/vk/vke4vkmnpcbp9gm8tuac-92xany.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we can bind them to a specific assembly location using the generated name ‚Äúvar0‚Äù. </font></font><br><br><img src="https://habrastorage.org/webt/yh/rc/xx/yhrcxxqcvj0upcy6negdcw0b9c0.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, I would just like to hover over the variable name and see the value. </font><font style="vertical-align: inherit;">Perhaps in the future they will invent a new format SourceMap, which will allow not only the code base, but also the variables.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Profiler </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also look at the profiler. </font><font style="vertical-align: inherit;">It works in both Chrome and Firefox. </font><font style="vertical-align: inherit;">Firefox is better - it "unwinds" the names, and they can be seen as they are in the source code. </font></font><br><br><img src="https://habrastorage.org/webt/bv/va/x1/bvvax1w0kvo4gsmx7ry0bgbekhe.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chrome encodes them a bit (for those who understand, these are Mangled function names), but if you squint, you can see what they are related to.</font></font><br><br><img src="https://habrastorage.org/webt/gv/jh/rp/gvjhrpyqjxyvsyq4xjigmdmwxa8.png"><br><br><h2>  Performance </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's talk about performance. </font><font style="vertical-align: inherit;">This is a complex and multifaceted topic, and this is why:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantaym </font><font style="vertical-align: inherit;">Performance measurement depends on the runtime you are using. </font><font style="vertical-align: inherit;">Measurements in C ++ will differ from measurements in Rust or Go.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Losses at the JS - Wasm border. </font><font style="vertical-align: inherit;">Measuring math does not make sense, because performance losses occur at the intersection of the JS and Wasm frontier. </font><font style="vertical-align: inherit;">The more calls you make back and forth, the more you move objects, the more the speed drops. </font><font style="vertical-align: inherit;">Browsers are now working on this problem, and gradually the situation is improving.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Technology is evolving. </font><font style="vertical-align: inherit;">Those measurements that were made today will not make sense tomorrow, and even more so in a couple of months.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wasm accelerates the launch of the application. </font><font style="vertical-align: inherit;">Wasm does not promise to speed up your code or replace JS. </font><font style="vertical-align: inherit;">The WebAssembly team is focused on speeding up the launch of large application code bases.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In synthetics, you get speed at JS level. </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We made a simple test: graphic filters for the image. </font></font><br><br><ul><li> <a href="https://github.com/andrnag/wasm_cpp_bench"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wasp_cpp_bench</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chrome 65.0.3325.181 (64-bit) </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Core i5-4690 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 24gb ram </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 measurements; </font><font style="vertical-align: inherit;">rejected max and min; </font><font style="vertical-align: inherit;">averaging</font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Got such results. </font><font style="vertical-align: inherit;">Here everything is normalized to the execution of a similar filter on JS - a yellow bar, in all cases exactly one. </font></font><br><br><img src="https://habrastorage.org/webt/sg/e7/to/sge7toujmxycrhznogviscz94dy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++, compiled without optimization, behaves in some strange way. </font><font style="vertical-align: inherit;">This is illustrated by the example of the Grayscale filter. </font><font style="vertical-align: inherit;">Even our C ++ developers could not explain why. </font><font style="vertical-align: inherit;">But when optimization is turned on (green bar), we get a time that almost coincides with JS. </font><font style="vertical-align: inherit;">And, running ahead, we get similar results in the native code, if we compile C ++, as a native application.</font></font><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crash and error collection </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use Sentry, and there is a problem with it - the wasm frames disappear from the stackrays. </font><font style="vertical-align: inherit;">It turned out that the traceKit library that the Sentry client uses - Raven - simply contains a regular expression that does not take into account that wasm exists. </font><font style="vertical-align: inherit;">We made a patch, and, probably, we will send it soon pull request, but for now we use it with npm install of our JS project. </font></font><br><br><img src="https://habrastorage.org/webt/rd/vm/-z/rdvm-zijheakjsktoubausmmyc8.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It looks like this. </font><font style="vertical-align: inherit;">This is the production version, there are no function names, only unit numbers. </font><font style="vertical-align: inherit;">And this is what a debug build looks like; you can already figure out what went wrong:</font></font><br><br><img src="https://habrastorage.org/webt/gn/e_/_t/gne__tfliahfwe1sfndiid2tmyq.png"><br><br><h2>  Total </h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> WebAssembly can already be used in combat, and our project has proven it. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Porting even a large application is real. </font><font style="vertical-align: inherit;">It took us 8 months, the lion's share of which we spent on refactoring our C ++ application to highlight boundaries, interfaces, and so on.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The tools are still weak, but work in this direction is underway, as WebAssembly is actually the future of the web. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The speed is at JS level. </font><font style="vertical-align: inherit;">Modern JS-machines optimize the program code to such an extent that it simply ‚Äúfalls‚Äù into machine instructions, and runs as fast as your processor can.</font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you take up work, I recommend: </font></font><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take Emscripten and Embind. </font><font style="vertical-align: inherit;">These are good and working technologies.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you need something weird in Emscripten - take a look at the tests. </font><font style="vertical-align: inherit;">The documentation is there, but not all covers, but the test file contains 3000 lines of all possible situations of using Emscripten.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sentry is suitable for collecting errors. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debug in Firefox. </font></font></li></ul><br><br>  Thanks for attention!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I am ready to answer your questions. </font></font><br><br><img src="https://habrastorage.org/webt/2h/qu/au/2hquauawvppoc-iu5un4wgevnvo.png"><br><br><blockquote>        HolyJS,  : <b>24-25   </b>   <b>HolyJS</b> .  <a href="http://holyjs-piter.ru/%3Futm_source%3Dhabr%26utm_medium%3D441140"> </a>      (,   Node.js Ryan Dahl!),      ‚Äî   1   . </blockquote></div><p>Source: <a href="https://habr.com/ru/post/441140/">https://habr.com/ru/post/441140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441128/index.html">The right choice: a practical study of the cognitive abilities of great apes</a></li>
<li><a href="../441130/index.html">Balanced site indicators. Part 1: Strategy</a></li>
<li><a href="../441132/index.html">That Roskomnadzor did not come suddenly</a></li>
<li><a href="../441134/index.html">Emotions, independent work</a></li>
<li><a href="../441136/index.html">Long-term storage of Prometheus metrics (Alexey Palazhchenko, Percona)</a></li>
<li><a href="../441142/index.html">12 points of growth conversion, or content that really sells</a></li>
<li><a href="../441146/index.html">Industrial wireless networks: which one to choose?</a></li>
<li><a href="../441148/index.html">How to handle errors correctly: silence is not always good</a></li>
<li><a href="../441150/index.html">The first acquaintance with the HTTP protocol by writing a simple Java Web server</a></li>
<li><a href="../441152/index.html">How to minimize errors when integrating with external services: the online broker experience</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>