<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to stop being afraid and fall in love with mbed [Part 2]</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue a series of publications devoted to the use of the ARM mbed environment for creating a prototype measuring device. 

 Let me remind you th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to stop being afraid and fall in love with mbed [Part 2]</h1><div class="post__text post__text-html js-mediator-article">  We continue a series of publications devoted to the use of the ARM mbed environment for creating a prototype measuring device. <br><br>  Let me remind you that we are talking about the development of a device with a touch screen, which serves for high-speed measurement of temperature and relative humidity.  The most interesting thing about this story is the approach to creating firmware.  The program is written using the online IDE mbed, which allows you to create iron-independent code that works equally well on debug boards from SiLabs, Atmel, Wiznet, STM32, NXP and other manufacturers. <br><br>  Today we are starting to work with displaying a picture on a TFT display. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/f82/a27/7aa/f82a277aa0cb491f9e1f841922659f0c.png" width="600"><br><br>  Content of the publication cycle: <br><br><ul><li>  <a href="https://habrahabr.ru/company/efo/blog/308440/">[Part 1] Overview of the used software and hardware solutions.</a> </li><li>  [ <b>Part 2] Getting Started with the FT800 Graphics Controller.</b>  <b>Use of ready mbed-libraries for peripheral devices.</b> </li><li>  <a href="https://habrahabr.ru/company/efo/blog/310058/">[Part 3] Connecting the sensor HYT-271.</a>  <a href="https://habrahabr.ru/company/efo/blog/310058/">Create and publish in mbed your own library for peripherals.</a> </li><li>  <a href="https://habrahabr.ru/company/efo/blog/310720/">[Part 4] Application development: Program structure, working with a touch screen.</a> </li><li>  <a href="https://habrahabr.ru/company/efo/blog/311816/">[Part 5] Application development: Display images, Russification problems.</a> </li><li>  <a href="https://habrahabr.ru/company/efo/blog/312484/">[Part 6] Printing Body Parts</a> </li></ul><br>  The second part is under the cut. <br><a name="habracut"></a><br>  In the <a href="https://habrahabr.ru/company/efo/blog/308440/">last article</a> , we gave a brief overview of the used hardware modules, including the TFT touchscreen display - a module from Riverdi, which consists of a display and an FTD00 integrated graphics controller from FTDI.  Today we will look at the general issues of working with such a module and ‚Äúmake friends‚Äù with a debugging board. <br><br>  Since for writing software is used exclusively online IDE mbed, the resulting program should run without problems on the debugging boards SLSTK3400A from SiLabs, ATSAMD21-XPRO from Atmel and WIZwiki-W7500P from Wiznet. <br><br><img src="https://habrastorage.org/files/217/d54/1d7/217d541d7aa046ba8ba126f16d9ed74c.png" width="600"><br><br><hr><a name="TFTcontrol"></a><br>  So, all the procedures related to graphics output, touch input and audio channel operation are hardware implemented on the FT800 series graphic controller.  The task of the developer is to control the FTDI chip from the main microcontroller - roughly speaking, reading and writing certain registers of the FT800 controller via the SPI or I2C * interface. <br>  <i>* we will further assume that the host controller is connected to the FT800 via the SPI interface.</i>  <i>Most often it is.</i> <br><br><img src="https://habrastorage.org/files/30e/350/f14/30e350f14541439d9798e661daebd89f.png"><br><br>  Three types of commands are used to control the graphics controller: <br><br><ul><li>  <b>Host command</b> to control the operation mode of the FT800, </li><li>  <b>Host Memory Read</b> to retrieve information from an FTDI controller (for example, to read a register of sensory input) </li><li>  <b>Host Memory Write</b> to send commands to perform graphic operations, to play sound, etc. </li></ul><br>  All functions for interacting with a TFT display consist of receiving and transmitting such commands.  FTDI provides a library that implements all operations supported by the graphics controller.  These are several dozens of functions of varying complexity, which, nevertheless, always consist of their basic functions ‚Äî receiving and transmitting via the SPI instructions the Host command, Host Memory Read, and Host Memory Write. <br><br>  In general, to begin working with the display, it is necessary to adapt the functions of the FTDI library that address the peripheral devices of the master controller to the host controller being used.  This is the setting of the SPI interface, as well as the functions of reading and writing SPI data of a given format.  After the iron-dependent functions are changed in accordance with the features of the host controller, you can begin to use all the features of the FTDI libraries and examples. <br><br>  You can find out where to download the library and examples for the FT800 modules, how to adapt the library for the target host microcontroller and how to use the available functions for practical tasks from materials from the manufacturer and from the articles of my colleague Sergey Dolgushin: <br><br><div class="spoiler">  <b class="spoiler_title">Materials from the manufacturer</b> <div class="spoiler_text">  On <a href="http://www.ftdichip.com/Products/ICs/FT800.html">the manufacturer's website is</a> available a full list of materials.  Personally, I recommend starting with AN_240 FT800 From the Ground Up, continue with the FT800 Series Programmers Guide, and then look for documents related directly to your task. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Selection of articles in Russian</b> <div class="spoiler_text"><ol><li>  <a href="http://mymcu.ru/storage/content/articles/FTDI/EVE.pdf">The FT800 graphics controller for TFT display control</a> is an overview article that introduces the main features of FTDI graphics controllers. </li><li>  <a href="http://mymcu.ru/articles/graficheskiy-kontroller-ft800-programmnie-sredstva-razrabotki-i-otladki.html">FT800 graphics controller.</a>  <a href="http://mymcu.ru/articles/graficheskiy-kontroller-ft800-programmnie-sredstva-razrabotki-i-otladki.html">Software development and debugging tools.</a>  - The article describes useful utilities and libraries that significantly simplify the stages of mastering, developing and testing graphical applications, as well as helping to get acquainted with the functional capabilities of the FT800 / 801 using a personal computer without using additional hardware. </li><li>  <a href="http://mymcu.ru/storage/content/articles/FTDI/ApN_EFO_FT800.pdf">Getting started with the FT800 FTDI graphics controller</a> - an example of using the FT800 graphics controller with Cypress microcontrollers.  Describes the main steps to adapt the manufacturer‚Äôs library for the selected MC. </li><li>  <a href="http://mymcu.ru/storage/content/articles/FTDI/ApNote_002_FT800.pdf">Graphic controller EVE FT800 FTDI.</a>  <a href="http://mymcu.ru/storage/content/articles/FTDI/ApNote_002_FT800.pdf">Work with custom fonts, buttons and touch screen.</a>  - continuation of the previous article, which discusses the basic principles of working with user interface elements and the touch screen.  In particular, it shows how the FT80x processes information from the touch screen and automatically links it to a given interface element. </li><li>  <a href="http://mymcu.ru/storage/content/devtools/FTDI/FT800_SAMD21.pdf">EVE FT800 FTDI graphic controller and SAMD21 Atmel microcontroller.</a>  <a href="http://mymcu.ru/storage/content/devtools/FTDI/FT800_SAMD21.pdf">We work with graphic images.</a>  - An example of the adaptation of the manufacturer's library for use with Atmel MK SAM D21 series and work with graphic objects. </li><li>  <a href="http://mymcu.ru/storage/content/files/ftdi/FT800_SAMD21_p2.pdf">EVE FT800 FTDI graphic controller and SAMD21 Atmel microcontroller.</a>  - continuation of the previous article, which describes the method of working with JPEG-images. </li><li>  <a href="http://mymcu.ru/storage/content/articles/FTDI/APP_EFO_FT800_Indikator.pdf">FT800 graphics controller.</a>  <a href="http://mymcu.ru/storage/content/articles/FTDI/APP_EFO_FT800_Indikator.pdf">Displaying the image of a dial gauge</a> - this example describes a technique that minimizes the exchange of data between the MC and the graphics controller by using the integrated FT80x RAM. </li></ol><br></div></div><br>  In the case of program development in mbed, the task is simplified even more - since the code written in mbed itself is iron-independent, even the basic functions of the FTDI library become universal.  Thus, to control the display from debug boards from different manufacturers, you can use the same mbed library without making any changes. <br><br><h1>  Inclusion scheme </h1><hr><br>  To connect a TFT module, eight signals are required: <br><br><ul><li>  Four <b>SPI</b> lines - mosi, miso, sck and ss </li><li>  <b>Intr</b> signal (interrupt from the FTD controller to the host controller), </li><li>  Signal <b>pd</b> - power down, </li><li>  Power supply (3.3 V) and ground. </li></ul><br>  The intr and pd signals can be implemented on any free digital lines of the host controller. <br><br><img src="https://habrastorage.org/files/aae/d88/c22/aaed88c22f7c46d5a8eea147f4d18c5d.png"><br><br>  For most Riverdi TFT modules, the module is connected to a control controller via a flat cable.  To connect the cable to the debug boards, a break-out adapter board 20 is proposed. When using it, you need to pay attention to the fact that in addition to the VDD power line, the board is powered separately for the display backlight - the signal BLVDD.  To work with the display, power must be supplied to both VDD and BLVDD, so it makes sense to immediately combine the lines and supply power only to VDD. <br><br><img src="https://habrastorage.org/files/030/93a/4bb/03093a4bb76742c0b1713df635dc4bd0.JPG"><br><br>  With GND and BLGND, this trick is not required. <br><br><h1>  TFT Module Initialization Procedure </h1><hr><br><img src="https://habrastorage.org/files/4d0/2b7/a46/4d02b7a46ad94e78a8413b81d58994dc.png" align="right">  The initialization procedure consists of three steps: setting up the SPI interface, initializing the FT800 graphics controller, and initializing the TFT display. <br><br>  The SPI interface of the host processor is always master and operates in ‚Äúmode 0‚Äù mode with the high bit transmitted first (MSB first).  The maximum operating frequency of the interface is 30 MHz, however, before the end of the initialization procedure, the frequency should not be set above 11 MHz. <br><br>  The initialization of the graphic controller consists in the sequential execution of the following operations. <br><br>  First, the PD signal translates to 20 ms at a low level, and then another 20 ms at a high level.  Thus, the graphics controller goes into standby mode.  After that, several commands of the Host command group are sent to the FTDI controller: the ACTIVE (0x00) command switches the controller to active mode, the CORERST command (0x68) resets all registers and logic circuits, then the CLKEXT command (0x44) selects clocking from an external source, and after This selects the operating frequency of the controller - 48 or 36 MHz using the CLK48M (0x62) or CLK36M (0x61) command, respectively. <br><br>  Of course, other scenarios for setting up the FT800 controller are possible, but most often the procedure looks like this. <br>  If the initialization of the graphic controller was successful, then in the REG_ID register of the graphic controller is set to 0x7C.  After verifying this reference value, you can increase the SPI speed. <br><br>  The last preparatory step is to configure the parameters of the TFT-display.  The essence of the procedure is to write to the specific registers of the graphic controller of the parameters of a specific TFT display.  We once explain the graphics controller to which particular display it is connected, and then use the universal library functions. <br><br><div class="spoiler">  <b class="spoiler_title">What is meant by display parameters</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/b47/cc1/ad4/b47cc1ad43d945368847109048a2fd8e.PNG"><br></div></div><br>  After setting, a blank screen is displayed.  Further, if necessary, the configuration of the touch input and the audio channel is carried out.  All these procedures are repeatedly described by the manufacturer, therefore, probably, they do not need explanations. <br><a name="display-list"></a><br><h1>  Display graphics primitives and widgets </h1><hr><br>  After initialization, working with the display is reduced to forming the next display list and loading it onto the graphics controller.  The display list is a list of commands that, as a result of execution of which, the FTDI controller displays a kind of image. <br><br>  The display list begins with writing the command CMD_DLSTART to the graphics controller and ends with writing the command DISPLAY ().  The display of the display list occurs by writing the standard value to the register REG_DLSWAP. <br><br>  The body of the display list can contain up to 2048 instructions.  All of them are simple commands like setting the color of objects and drawing graphic primitives - lines, rectangles, points, etc. <br><br>  The FTDI graphics controller consists of several nodes, including the main processor, an additional graphics co-processor, audio processor, etc.  The main processor of the FT800 is responsible for the execution of simple commands of the display list, but the FTDI chips allow working with more complex objects - widgets.  Widgets are buttons, sliders, scales, gradients, text strings, numbers, and so on.  Despite the fact that widgets are rendered by the coprocessor, simple basic functions and functions of widgets drawing can be interleaved while forming the display list. <br><br><h1>  Using the FT800 library in your own mbed project </h1><hr><br>  In the <a href="https://habrahabr.ru/company/efo/blog/308440/">last article</a> , a draft of the project was prepared - a short program that displays a seconds counter on a virtual COM port.  Today, we will connect the FT800 library to the project and will display the seconds counter on the TFT display. <br><br>  Among the mbed-developers, there is already a person who dealt with the FT800 graphics controller.  This same person, Peter Drescher, successfully adapted the FTDI library for mbed, provided it with an example of use and photographs.  Thanks, Peter! <br><br>  To use the library in your project, click on the Import library on the <a href="https://developer.mbed.org/components/EVE-FT800/">dedicated FT800 page</a> , get into your compiler and select the project to which the library will be connected.  Of course, for all these gestures, you must first register at developer.mbed.org. <br><br><img src="https://habrastorage.org/files/5fd/1c9/cf7/5fd1c9cf718f4abe84593f055638788f.png"><br><br>  To use the FT800 library, you need to connect the FT_Platform.h file to your main.cpp and declare a new FT800 TFT object, just like we declared a Serial class pc object in the program from the previous article.  Arguments when declaring an object are board outputs on which SPI interface lines and PD and INT signals are available.  Since I will run the program on three different boards, I immediately paint a pinout for all three cases: <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbed.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FT_Platform.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// SLSTK3400A FT800 TFT (PE10, PE11, PE12, PE13, PB11, PD4); // mosi, miso, sck, ss, int, pd // WIZwiki-W7500P //FT800 TFT (D11, D12, D13, D10, D9, D8); // mosi, miso, sck, ss, int, pd // ATSAMD21-XPRO //FT800 TFT (PA18, PA16, PA19, PA17, PA20, PA21); // mosi, miso, sck, ss, int, pd</span></span></span></span></code> </pre> <br>  The FT800 class constructor itself is in the <a href="">FT_Gpu_Hal.cpp</a> file <a href="">.</a> <br><br><pre> <code class="cpp hljs">FT800::FT800(PinName mosi, PinName miso, PinName sck, PinName ss, PinName intr, PinName pd): _spi(mosi, miso, sck), _ss(ss), _pd(pd), _f800_isr(InterruptIn(intr)) { _spi.format(<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 8 bit spi mode 0 _spi.frequency(2000000); // start with 10 Mhz SPI clock _ss = 1; // cs high _pd = 1; // PD high Bootup(); }</span></span></code> </pre><br>  The FT800 class designer already includes the entire TFT module initialization procedure ‚Äî setting up the SPI interface and calling the Bootup () function, which describes sending a 20-millisecond pulse to the PD line, sending the desired sequence of Host commands, checking the REG_ID of the graphics controller, further setting the SPI frequency at 20 MHz, as well as setting the parameters of the TFT-display. <br>  You can watch the code <a href="">on developer.mbed.org</a> (scroll to the bottom of the page). <br><br>  It is important to note that the defaults for the parameters of a TFT display are set in the file <a href="">FT_LCD_Type.h</a> , where by default the parameters of the display of the WQVGA standard with a resolution of 480 by 272 are specified. <br><br>  You will understand that the display is correctly connected and correctly initialized, if after the constructor has been tested the white screen is lit, in any other case you need to look for an error.  If everything is done correctly, you can begin to form the first display list. <br><br>  I will give an example of a simple program for displaying the counter of seconds, round hours and several more objects. <br><br><img src="https://habrastorage.org/files/053/a28/a1a/053a28a1a81c47f4b24eb61d92d8bb37"><br><br>  The only display list will consist of the following operations: <br><br>  <strong>1.</strong> Start of the display list, setting the white color as the default color: <br><br><pre> <code class="cpp hljs"> TFT.DLstart(); TFT.DL(CLEAR_COLOR_RGB(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>)); TFT.DL(CLEAR(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>));</code> </pre><br>  <strong>2.</strong> Set the black color, output two text lines: <br><br><pre> <code class="cpp hljs"> TFT.DL(COLOR_RGB(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); TFT.Text(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Demo-project for habrahabr.ru"</span></span>); TFT.Text(<span class="hljs-number"><span class="hljs-number">13</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Using FT800 library"</span></span>);</code> </pre><br>  <strong>3.</strong> Setting the dark green color, the output of the graphic primitive "Rectangle": <br><br><pre> <code class="cpp hljs"> TFT.DL(COLOR_RGB(<span class="hljs-number"><span class="hljs-number">9</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); TFT.DL(BEGIN(RECTS)); TFT.DL(VERTEX2II(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">105</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); TFT.DL(VERTEX2II(<span class="hljs-number"><span class="hljs-number">11</span></span> + <span class="hljs-number"><span class="hljs-number">275</span></span>, <span class="hljs-number"><span class="hljs-number">105</span></span> + <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><br>  <strong>4.</strong> Set the white color, text output and the number of seconds: <br><br><pre> <code class="cpp hljs"> TFT.DL(COLOR_RGB(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>)); TFT.Text(<span class="hljs-number"><span class="hljs-number">11</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">105</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">29</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"Number of seconds:"</span></span>); TFT.Number(<span class="hljs-number"><span class="hljs-number">11</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">105</span></span> + <span class="hljs-number"><span class="hljs-number">10</span></span> + <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, seconds);</code> </pre><br>  <strong>5.</strong> Output of one of the supported clock widgets on FT800: <br><br><pre> <code class="cpp hljs"> TFT.Clock(<span class="hljs-number"><span class="hljs-number">390</span></span>, <span class="hljs-number"><span class="hljs-number">105</span></span> + <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">70</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">20</span></span>, (seconds % <span class="hljs-number"><span class="hljs-number">60</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><br>  <strong>6.</strong> Set black color, text line output: <br><br><pre> <code class="cpp hljs"> TFT.DL(COLOR_RGB(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); TFT.Text(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>, <span class="hljs-number"><span class="hljs-number">28</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"e-mail: xk@efo.ru"</span></span>);</code> </pre><br>  <strong>7.</strong> Output of the ‚ÄúStraight Line‚Äù graphic primitive: <br><br><pre> <code class="cpp hljs"> TFT.DL(BEGIN(LINES)); TFT.DL(LINE_WIDTH(<span class="hljs-number"><span class="hljs-number">8</span></span>)); TFT.DL(VERTEX2II(<span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-number"><span class="hljs-number">40</span></span> + <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)); TFT.DL(VERTEX2II(<span class="hljs-number"><span class="hljs-number">460</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span> + <span class="hljs-number"><span class="hljs-number">40</span></span> + <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><br>  <strong>8.</strong> The end of the display list, loading pictures on the display: <br><br><pre> <code class="cpp hljs"> TFT.DL(DISPLAY()); TFT.Swap();</code> </pre><br>  I pay attention that the TFT.DL () commands are the simple display list commands described above, and the TFT.Text (), TFT.Number () and TFT.Clock () commands are coprocessor instructions. <br><br><hr><br>  <b>Important!</b> <br>  Two libraries of the same author, <a href="https://developer.mbed.org/users/dreschpe/code/FT800/">FT800</a> and <a href="https://developer.mbed.org/users/dreschpe/code/FT800_2/">FT800_2, are</a> available for mbed graphic controllers of the FT800 series.  They differ from each other only in the names of functions: in the first library the same names are used as in the materials from FTDI, and in the second all names are abbreviated: <br><table><tbody><tr><td>  TFT.Ft_Gpu_CoCmd_Dlstart (); <br>  TFT.Ft_App_WrCoCmd_Buffer (CLEAR_COLOR_RGB (255, 255, 255)); <br>  TFT.Ft_App_WrCoCmd_Buffer (CLEAR (1, 1, 1)); <br><br>  TFT.Ft_App_WrCoCmd_Buffer (BEGIN (LINES)); <br>  TFT.Ft_App_WrCoCmd_Buffer (VERTEX2II (11, 15 + 40 + 30, 0, 0)); <br>  TFT.Ft_App_WrCoCmd_Buffer (VERTEX2II (460, 15 + 40 + 30, 0, 0)); <br><br>  TFT.Ft_App_WrCoCmd_Buffer (DISPLAY ()); <br>  TFT.Ft_Gpu_CoCmd_Swap (); <br></td><td>  TFT.DLstart (); <br>  TFT.DL (CLEAR_COLOR_RGB (255, 255, 255)); <br>  TFT.DL (CLEAR (1, 1, 1)); <br><br>  TFT.DL (BEGIN (LINES)); <br>  TFT.DL (VERTEX2II (11, 15 + 40 + 30, 0, 0)); <br>  TFT.DL (VERTEX2II (460, 15 + 40 + 30, 0, 0)); <br><br>  TFT.DL (DISPLAY ()); <br>  TFT.Swap (); <br></td></tr></tbody></table>  I use the second option, however, the use of long function names has an undeniable advantage: having mastered these names, it will be much easier for you to use examples from the manufacturer and utilities for automatically generating code from FTDI. <br><br><hr><br>  We return to the example of working with the display, the program for displaying the seconds counter on the TFT.  We take as a basis the draft project from the previous article, in which, using the base library mbed, a seconds counter is displayed on the serial interface. <br><br><div class="spoiler">  <b class="spoiler_title">Output seconds counter to serial interface</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbed.h"</span></span></span><span class="hljs-meta"> Serial pc(USBTX, USBRX); Ticker timeKeeping; volatile uint64_t seconds = 0; void secondsCallback(void) { pc.printf(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Number of seconds: %x\r\n"</span></span></span><span class="hljs-meta">, seconds); seconds ++; } int main() { timeKeeping.attach(&amp;secondsCallback, 1.0f); while(1) {} }</span></span></code> </pre><br><br><img src="https://habrastorage.org/files/4ec/c31/6fe/4ecc316fec904a41a9aee760f174fcd3.png"><br></div></div><br>  We make the appropriate changes - we connect the FT800 library, declare an object of the class FT800 and you call an infinite loop to the function that forms the display list described above. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mbed.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FT_Platform.h"</span></span></span><span class="hljs-meta"> FT800 TFT (PE10, PE11, PE12, PE13, PB11, PD4); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// mosi, miso, sck, ss, int, pd [SLSTK3400A] //FT800 TFT (D11, D12, D13, D10, D9, D8); // mosi, miso, sck, ss, int, pd [WIZwiki-W7500P] //FT800 TFT (PA18, PA16, PA19, PA17, PA20, PA21); // mosi, miso, sck, ss, int, pd [ATSAMD21-XPRO] Ticker timeKeeping; volatile uint64_t seconds = 0; /***********************************************************************************************************************/ void secondsCallback(void) { seconds ++; } /***********************************************************************************************************************/ /* Construct the screen and downloasd it to the TFT */ void drawTimeScreen(void) { TFT.DLstart(); TFT.DL(CLEAR_COLOR_RGB(255, 255, 255)); TFT.DL(CLEAR(1, 1, 1)); TFT.DL(COLOR_RGB(0, 0, 0)); TFT.Text(11, 15, 30, 0, "Demo-project for habrahabr.ru"); TFT.Text(13, 15 + 40, 28, 0, "Using FT800 library"); TFT.DL(COLOR_RGB(9, 35, 5)); TFT.DL(BEGIN(RECTS)); TFT.DL(VERTEX2II(11, 105, 0, 0)); TFT.DL(VERTEX2II(11 + 275, 105 + 100, 0, 0)); TFT.DL(COLOR_RGB(255, 255, 255)); TFT.Text(11 + 10, 105 + 10, 29, 0, "Number of seconds:"); TFT.Number(11 + 10, 105 + 10 + 30, 31, 0, seconds); TFT.Clock(390, 105 + 70, 70, 0, 4, 20, (seconds % 60), 0); TFT.DL(COLOR_RGB(0, 0, 0)); TFT.Text(11, 240, 28, 0, "e-mail: xk@efo.ru"); TFT.DL(BEGIN(LINES)); TFT.DL(LINE_WIDTH(8)); TFT.DL(VERTEX2II(11, 15 + 40 + 30, 0, 0)); TFT.DL(VERTEX2II(460, 15 + 40 + 30, 0, 0)); TFT.DL(DISPLAY()); TFT.Swap(); } /***********************************************************************************************************************/ int main() { timeKeeping.attach(&amp;secondsCallback, 1.0f); while(1) { drawTimeScreen(); } }</span></span></span></span></code> </pre><br>  The project is available <a href="https://developer.mbed.org/users/Ksenia/code/FT800_demo_for_habr/">at developer.mbed.org</a> . <br><br>  To get the firmware file for three different debugging boards, you need, like <a href="https://habrahabr.ru/company/efo/blog/308440/">last time</a> , to change the target platform in the upper right corner of the compiler window, and also change the names of the I / O lines.  Voila - the program compiles and runs on all three boards. <br><br><img src="https://habrastorage.org/files/f82/a27/7aa/f82a277aa0cb491f9e1f841922659f0c.png"><br><br>  The next article will describe the process of creating and connecting to our project a library for the temperature and relative humidity sensor HYT-271.  We will slowly approach the full-fledged application, whose work is shown on video. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/nYildtT047Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1>  Conclusion </h1><hr><br>  In conclusion, I traditionally thank the reader for his attention and remind you that questions about the use of products, about which we write on Habr√©, can also be asked by email, specified in my profile. </div><p>Source: <a href="https://habr.com/ru/post/309918/">https://habr.com/ru/post/309918/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309906/index.html">Application of nonlinear dynamics and Chaos theory to the task of developing a new audio data compression algorithm</a></li>
<li><a href="../309908/index.html">IBM specialists want to stop the epidemic of Escherichia coli.</a></li>
<li><a href="../309910/index.html">Scala or not Scala? That is the question</a></li>
<li><a href="../309912/index.html">Poll. The current state of automated testing 2016</a></li>
<li><a href="../309914/index.html">The history of programming languages: how Fortran allowed users to communicate with the computer on "you"</a></li>
<li><a href="../309920/index.html">Fax in the City (T.38)</a></li>
<li><a href="../309922/index.html">Writing Hello World on FASM</a></li>
<li><a href="../309928/index.html">Customize Windows Store for Business</a></li>
<li><a href="../309930/index.html">Arguments for function tree</a></li>
<li><a href="../309934/index.html">How to get a lot of server for little money: options for the earth and the cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>