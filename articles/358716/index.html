<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Documentation Support in ASP.NET Web API</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When you provide your service as a Web API, the question arises of how to inform the user about its capabilities, the syntax of its requests, etc. Usu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Documentation Support in ASP.NET Web API</h1><div class="post__text post__text-html js-mediator-article">  When you provide your service as a Web API, the question arises of how to inform the user about its capabilities, the syntax of its requests, etc.  Usually you have to create separate Web pages where you open these topics.  But would it not be better if your Web API itself provided access to its documentation? <br><a name="habracut"></a><br>  If you open the page of some serious project on <a href="https://github.com/">GitHub</a> , you will see a well-designed <i>Readme.md</i> .  This <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a> document describes the purpose of the code stored in the repository, and often contains references to other documents.  GitHub automatically converts Markdown to an HTML representation and shows you the result in an easy-to-read form.  This makes Markdown files a convenient way to store documentation about your project.  First of all, this format provides quite rich possibilities for text formatting.  In addition, these files are stored in your version control system (VCS) along with your code.  This makes such documents equal with the code files themselves (first-class citizens).  You view them as part of the code and change them when you make modifications to the code.  At least it should be in theory.  Now you have all the documentation in your repository. <br><br>  If your repository is open, then everything is fine.  Users of your API can see the documentation there.  But I work for a company that provides some Web API to external clients.  These clients do not have access to our repositories.  How do we provide them with documentation on our services? <br><br>  You can create a separate website with documentation.  But then we will have 2 places where product information is stored: in Markdown files and on this site.  You can, of course, automate the process of creating a site with documentation, generating it from Markdown documents.  Or you can create a separate document (for example, PDF), which includes the contents of all these files. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There is nothing wrong with this approach.  But, I think that it is possible to make one more step in this direction.  Why do we separate the documentation from the API itself?  Is it possible to ship them together?  For example, our Web API is available at <i><a href="http://www.something.com/api/data">www.something.com/api/data</a></i> , and its documentation is available at <i><a href="">www.something.com/api/help.md</a></i> <br><br>  How hard is it to implement this approach in the ASP.NET Web API?  Let's get a look. <br><br>  Let's start with a simple web API based on OWIN.  Here is my <i>Startup</i> file: <br><br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: OwinStartup(typeof(OwinMarkdown.Startup))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">OwinMarkdown</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Startup</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAppBuilder app</span></span></span><span class="hljs-function">)</span></span> { HttpConfiguration config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpConfiguration(); config.Formatters.Clear(); config.Formatters.Add( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonMediaTypeFormatter { SerializerSettings = GetJsonSerializerSettings() }); config.Routes.MapHttpRoute( name: <span class="hljs-string"><span class="hljs-string">"DefaultApi"</span></span>, routeTemplate: <span class="hljs-string"><span class="hljs-string">"api/{controller}/{id}"</span></span>, defaults: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> {id = RouteParameter.Optional} ); app.UseWebApi(config); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonSerializerSettings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJsonSerializerSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonSerializerSettings(); settings.Converters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringEnumConverter { CamelCaseText = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); settings.ContractResolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CamelCasePropertyNamesContractResolver(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> settings; } } }</code> </pre> <br>  Let's add some markdown files to the project: <br><br><img src="https://habrastorage.org/webt/4n/-_/ui/4n-_ui-6vn-mko6iakegz9nnpu0.png"><br><br>  A few words should be said about the added files.  First of all, we can have a complex subfolder structure that stores various parts of our documentation.  In addition, we have other files, not just Markdown.  For example, our documentation may contain images that Markdown documents will refer to.  Therefore, our solution for providing documentation via the Web API must support both the folder structure and additional files. <br><br>  We will start the changes with the <i>Web.config</i> file.  It needs to make some modifications.  The fact is that Internet Information Services (IIS) can deliver static files to a user without the participation of our application.  For example, if a user requests <i><a href="">myhost / help / root.md</a></i> , IIS will understand that there is such a file on the disk and will return it himself.  This means that IIS will not pass the request to our application.  But this is not what we want.  We do not need to return the raw Markdown file, we want to first convert it to HTML.  That is why we need to make changes in <i>Web.config</i> .  You need to tell IIS that all requests should be sent to our application, without trying to execute them yourself.  This can be done by setting the <i>system.webServer</i> section: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.webServer</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">modules</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">runAllManagedModulesForAllRequests</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">handlers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">remove</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ExtensionlessUrlHandler-Integrated-4.0"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">remove</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"OPTIONSVerbHandler"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">remove</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"TRACEVerbHandler"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">add</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Owin"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">verb</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"*"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Microsoft.Owin.Host.SystemWeb.OwinHttpHandler, Microsoft.Owin.Host.SystemWeb"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">handlers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">system.webServer</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Now IIS will not process static files.  But we still have to supply them (for example, for pictures in our documentation).  Therefore, we will use the NuGet package <i>Microsoft.Owin.StaticFiles</i> .  So, if we want our documentation to be available at <i>/ api / doc</i> , we need to configure this package as follows: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: OwinStartup(typeof(OwinMarkdown.Startup))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">OwinMarkdown</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Startup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> HelpUrlPart = <span class="hljs-string"><span class="hljs-string">"/api/doc"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAppBuilder app</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> basePath = AppDomain.CurrentDomain.SetupInformation.ApplicationBase; app.UseStaticFiles(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticFileOptions { RequestPath = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PathString(HelpUrlPart), FileSystem = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PhysicalFileSystem(Path.Combine(basePath, <span class="hljs-string"><span class="hljs-string">"Help"</span></span>)) }); HttpConfiguration config = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpConfiguration(); config.Formatters.Clear(); config.Formatters.Add( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonMediaTypeFormatter { SerializerSettings = GetJsonSerializerSettings() }); config.Routes.MapHttpRoute( name: <span class="hljs-string"><span class="hljs-string">"DefaultApi"</span></span>, routeTemplate: <span class="hljs-string"><span class="hljs-string">"api/{controller}/{id}"</span></span>, defaults: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> {id = RouteParameter.Optional} ); app.UseWebApi(config); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> JsonSerializerSettings </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetJsonSerializerSettings</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settings = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JsonSerializerSettings(); settings.Converters.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringEnumConverter { CamelCaseText = <span class="hljs-literal"><span class="hljs-literal">false</span></span> }); settings.ContractResolver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CamelCasePropertyNamesContractResolver(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> settings; } } }</code> </pre><br>  Now we are returning static files from the <i>Help</i> folder of our application to the address <i>/ api / doc</i> .  But we still need to somehow convert the Markdown documents to HTML before returning them.  For this purpose, we will write our OWIN middleware.  This middleware will use the <i>Markdig</i> NuGet package. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">assembly: OwinStartup(typeof(OwinMarkdown.Startup))</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">OwinMarkdown</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Startup</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> HelpUrlPart = <span class="hljs-string"><span class="hljs-string">"/api/doc"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IAppBuilder app</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pipeline = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MarkdownPipelineBuilder().UseAdvancedExtensions().Build(); app.Use(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (context, next) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> markDownFile = GetMarkdownFile(context.Request.Path.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (markDownFile == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> next(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reader = markDownFile.OpenText()) { context.Response.ContentType = <span class="hljs-string"><span class="hljs-string">@"text/html"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileContent = reader.ReadToEnd(); fileContent = Markdown.ToHtml(fileContent, pipeline); <span class="hljs-comment"><span class="hljs-comment">// Send our modified content to the response body. await context.Response.WriteAsync(fileContent); } }); var basePath = AppDomain.CurrentDomain.SetupInformation.ApplicationBase; app.UseStaticFiles(new StaticFileOptions { RequestPath = new PathString(HelpUrlPart), FileSystem = new PhysicalFileSystem(Path.Combine(basePath, "Help")) }); HttpConfiguration config = new HttpConfiguration(); config.Formatters.Clear(); config.Formatters.Add( new JsonMediaTypeFormatter { SerializerSettings = GetJsonSerializerSettings() }); config.Routes.MapHttpRoute( name: "DefaultApi", routeTemplate: "api/{controller}/{id}", defaults: new {id = RouteParameter.Optional} ); app.UseWebApi(config); } private static JsonSerializerSettings GetJsonSerializerSettings() { var settings = new JsonSerializerSettings(); settings.Converters.Add(new StringEnumConverter { CamelCaseText = false }); settings.ContractResolver = new CamelCasePropertyNamesContractResolver(); return settings; } private static FileInfo GetMarkdownFile(string path) { if (Path.GetExtension(path) != ".md") return null; var basePath = AppDomain.CurrentDomain.SetupInformation.ApplicationBase; var helpPath = Path.Combine(basePath, "Help"); var helpPosition = path.IndexOf(HelpUrlPart + "/", StringComparison.OrdinalIgnoreCase); if (helpPosition &lt; 0) return null; var markDownPathPart = path.Substring(helpPosition + HelpUrlPart.Length + 1); var markDownFilePath = Path.Combine(helpPath, markDownPathPart); if (!File.Exists(markDownFilePath)) return null; return new FileInfo(markDownFilePath); } } }</span></span></code> </pre><br>  Let's see how this middleware works.  First of all, it checks whether the Markdown file was requested, or something else.  This is <i>what the GetMarkdownFile</i> function <i>does</i> .  It tries to find a Markdown file matching the request and returns it to <i>FileInfo</i> if the file is found, or null if it is not found.  The implementation is not the best, but it serves to test the idea.  It can be replaced with any other implementation. <br><br>  If the file was not found, the middleware passes the request processing further using <i>await next ()</i> .  But if the file is found, its contents are read, converted to HTML and returned in response. <br><br>  Now we have documentation that the user can see in several places.  It can be viewed in the VCS repository (for example, in GitHub).  It is also directly accessible through our Web API.  And besides, the documentation is part of our code, which we store under VCS. <br><br>  I think this is a very good result.  However, its disadvantages should be discussed. <br><br>  First of all, such a system is good if your product is already stable.  But in the early stages of development, it is not always clear what your API should look like, what format requests and responses should have, etc.  At this stage the documentation should be open for comments.  Therefore, you will need some tool that allows you to comment on the contents of Markdown-files.  GitHub has an Issues system where you can leave your comments about the code.  Since the documentation is now part of the code, Issues can be used to discuss its contents at the design stage.  But personally, I think this is not the best solution.  It would be much more convenient to write comments directly in the document, as it is possible to do in <a href="https://www.atlassian.com/software/confluence">Confluence</a> .  In short, I believe that a good tool is needed to discuss Markdown documents in the early stages of development. <br><br>  My colleagues at <a href="https://www.confirmit.com/">Confirmit</a> have pointed out several other shortcomings of the solution described, which I should mention.  Delivering documentation along with the API can adversely affect the speed of your service, since now one <i>ThreadPool</i> will be used both to serve requests to the Web API itself and to request documentation. <br><br>  In addition, adding an access point to the documentation extends the attack surface of your service.  You need to decide whether you provide access to documentation only to authorized users, or anyone.  In the latter case, the opportunity for DoS attacks on the access point to the documentation.  And since the documentation is supplied by the same service as the Web API, this may adversely affect the work of the API itself. <br><br>  This concludes the article.  I hope the idea presented in it will be useful at least as a starting point for further research. </div><p>Source: <a href="https://habr.com/ru/post/358716/">https://habr.com/ru/post/358716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358706/index.html">Applications for Tarantool. Part 3. Testing and launch</a></li>
<li><a href="../358708/index.html">Frontend 2018: the variety of frameworks and the lack of middles</a></li>
<li><a href="../358710/index.html">Q & A Explorer. April feature for Power BI Desktop</a></li>
<li><a href="../358712/index.html">7 common mistakes in English that we make when communicating with foreigners</a></li>
<li><a href="../358714/index.html">Two types of PHP extensions. Zend extension VS PHP module</a></li>
<li><a href="../358718/index.html">‚ÄúDig‚Äù into the user using in-depth interviews</a></li>
<li><a href="../358720/index.html">How I implemented graphQL for InterSystems platforms</a></li>
<li><a href="../358722/index.html">Welcome to .Net mitap in Raiffeisenbank UPD Broadcast</a></li>
<li><a href="../358724/index.html">Experience in building an integration platform based on ServiceMix (Camel) and RabbitMQ</a></li>
<li><a href="../358726/index.html">The devil is not so bad as it is described, or how I passed the CISSP exam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>