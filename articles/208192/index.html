<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unicode crash in Python3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: Armin Ronacher is a fairly well-known developer in the Python community (Flask, jinja2, werkzeug). 
 He started a peculiar crusad...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unicode crash in Python3</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: Armin Ronacher is a fairly well-known developer in the Python community (Flask, jinja2, werkzeug).</i> <i><br></i>  <i>He started a peculiar crusade against Python3 for quite a long time, but it is not so easy to accuse him of hysteria and retrograde: his objections are dictated by his serious experience of development, he argues his point of view in some detail.</i>  <i>A little about terminology:</i> <i><br></i>  <i>I translated coercion as a forced conversion of encodings, and byte string as byte strings, since the term ‚Äúraw‚Äù strings nevertheless means something else.</i> <i><br></i>  <i>‚ÄúHistorical‚Äù note: in 2012, Armin proposed PEP 414, which contained a number of measures to eliminate problems with Unicode, the PEP was confirmed quite quickly, but it is still there, since the text below was written on January 5, 2014</i> <br><br>  It is becoming more and more difficult to get a reasonable discussion about the differences between Python 2 and 3, since one language is already dead, <br>  and the second is actively developing.  When someone starts a discussion of Unicode support in two branches of Python, this is a very complex topic.  Instead of looking at Unicode support in two versions of the language, I‚Äôll consider the basic text and byte string processing model. <br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this post I will show on the example of the decisions of the developers of the language and the standard library, <br>  That Python 2 is better suited for working with text and byte strings. <br><br><br>  Since I had to accompany a large amount of code that worked directly with the conversion between byte strings and Unicode, the deterioration that occurred in Python3 caused me a lot of sadness.  I am particularly annoyed by the <a href="https://speakerdeck.com/pyconslides/python-3-dot-3-trust-me-its-better-than-python-2-dot-7-by-dr-brett-cannon">materials of the</a> main python development team, which urge me to believe that python 3 is better than 2.7. <br><br><h2>  Text presentation model </h2><br><br>  The main difference between Python 2 and Python 3 is the base types that exist for working with strings and byte strings.  In Python 3, we have one string type: <b>str</b> , which stores data in Unicode, and two byte types: <b>bytes</b> and <b>bytearray</b> . <br><br><br>  On the other hand, in Python 2 we have two string types: <b>str</b> , which is sufficient for any goals and tasks, limited to ASCII + strings with some undefined data that exceed the interval of 7 bits.  Together with the str type, Python2 has a <b>unicode</b> data type equivalent to the Pyr 3 <b>str</b> data type. To work with bytes in Python 2, there is one type: bytearray, taken from Python 3. Looking at the situation, you can see that from Python 3 something what was removed: support for string data is not in unicode. The sacrifice compensation was the hashed byte data type ( <b>bytes</b> ).  The data type <b>bytarray is</b> changeable, and therefore it cannot be hashed.  I very rarely use binary data as dictionary keys, and therefore the possibility or impossibility of hashing binary data does not seem to me very serious.  Especially in Python 2, since bytes can be put into a variable of type <b>str</b> without any problems. <br><br><h2>  Lost type </h2><br><br>  Python 3 excludes support for byte strings, which in the 2.x branch were of type <b>str</b> .  On paper, there is nothing wrong with this decision.  From an academic point of view, strings always represented in Unicode are wonderful.  And this is true if the whole world is your interpreter.  Unfortunately, in the real world, everything happens differently: you have to regularly work with different encodings, in this case, the Python 3 approach to working with strings is cracking at the seams. <br><br>  I‚Äôll be honest with you: how Python 2 handles Unicode errors, and I fully approve of the improvements in Unicode processing.  My position is that, as it is done in Python 3, is a step backwards and causes even more errors, and therefore I absolutely hate working with Python 3. <br><br><h2>  Errors when working with Unicode </h2><br><br>  Before I get into the details, we need to understand the difference between Unicode support in Python 2 and 3, <br>  as well as why the developers decided to change the mechanism of Unicode support. <br><br>  Initially, Python 2, like many other languages, was created before it without the support of processing a stream of different encodings. <br>  The string is the string, it contains bytes.  This required developers to work correctly with various <br>  encodings manually.  It was quite acceptable for many situations.  For many years, the Django web framework <br>  did not work with Unicode, but used only byte strings. <br><br>  Meanwhile, Python has been improving internal Unicode support for 2 years.  Improved Unicode Support <br>  allowed to use it for a uniform presentation of data in different encodings. <br><br>  The approach to handling strings that use a specific encoding in Python 2 is quite simple: <br>  you take a string (byte) that you could get from anywhere, and then convert <br>  its from the encoding that is typical for the source of the string (metadata, headers, and others) <br>  to unicode string.  By becoming a Unicode string, it supports all the same operations. <br>  which is byte, but now it can store a larger range of characters. <br>  When you need to pass a string to be processed elsewhere, then you are again <br>  convert it to the encoding used by the host, <br>  and before us again byte string <br><br>  What features are associated with this approach?  In order for this to work at the core language level, <br>  Python 2 should provide a way to go from a world without unicode to a beautiful world with unicode. <br>  This is possible due to the forced conversion of byte and non-byte strings.  When it happens <br>  and how does this mechanism work? <br><br>  The main point is that when a byte string participates in a single operation with a Unicode string, <br>  then the byte string is converted to a Unicode string using the implicit decoding process of the string, which uses the default encoding.  This encoding defaults to ASCII.  Python provided the ability to change the default encoding using a single module, but now the functions for changing the default encoding have been removed from the site.py module, it is installed in ASCII.  If you run the interpreter with the <b>-s</b> flag, then the <b>sys.setdefaultencoding</b> function will be available to you and you can experiment to find out what happens if you set the default encoding to UTF-8.  In some situations, problems may arise when working with the default encoding: <br><br>  1. implicit specification and conversion of encoding during concatenation: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">"Hello "</span></span> + <span class="hljs-string"><span class="hljs-string">u"World"</span></span> <span class="hljs-string"><span class="hljs-string">u'Hello World'</span></span></code> </pre> <br><br>  Here, the left string is converted, using the default encoding, to a Unicode string.  If the string contains non-ASCII characters, then under normal program execution conditions, the conversion stops with the exception UnicodeDecodeError, because the default encoding is ASCII <br><br>  2. Implicit specification and conversion of encoding when comparing strings <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">"Foo"</span></span> == <span class="hljs-string"><span class="hljs-string">u"Foo"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre><br><br>  It sounds more dangerous than it actually is.  The left side is converted to Unicode, and then a comparison is made.  If the left side cannot be converted, the interpreter issues a warning, and the lines are considered unequal (False is returned as the result of the comparison).  This is quite a sensible behavior, even if it does not seem that way when you first meet him. <br><br><br>  3. Explicit specification and conversion of the encoding, as part of a mechanism using codecs. <br><br>  This is one of the most sinister things and the most common source of all Unicode failures and misunderstandings in Python 2. To overcome problems in this area in Python 3, they took a crazy step by removing the .decode () method from the Unicode strings and the .encode () method from the byte strings This caused the greatest confusion and annoyance with me.  From my point of view, this is a very stupid decision, but I have been told many times that I don‚Äôt understand anything, there will be no going back. <br><br>  The explicit conversion of the encoding when working with codecs looks like this: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">"foo"</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'utf-8'</span></span>) <span class="hljs-string"><span class="hljs-string">'foo'</span></span></code> </pre><br><br>  This string is obviously a byte string.  We require it to be converted to UTF-8.  Eno in itself is meaningless, since UTF-8 codec converts a string from Unicode to a byte string with UTF-8 encoding.  How does this work?  The UTF-8 codec sees that the string is not a Unicode string, and therefore a forced conversion to Unicode is first performed.  As long as ‚Äúfoo‚Äù is only ASCII data and the default encoding is ASCII, the forced conversion is successful, and after this Unicode the string u ‚Äúfoo‚Äù is converted to UTF-8. <br><br><h2>  Codec mechanism </h2><br><br>  Now you know that Python 2 has two approaches to representing strings: bytes and Unicode.  Conversion between these representations is carried out using the codec mechanism.  This mechanism does not impose a Unicode-&gt; byte conversion scheme or a similar one.  A codec can convert byte-&gt; byte or Unicode-&gt; Unicode.  In fact, the codec system can implement conversion between any type of Python.  You can have a JSON codec that converts a string to a complex Python object based on it, if you consider that such conversion is necessary for you. <br><br>  This state of affairs can cause problems with understanding the mechanism, starting with its foundations.  An example of this might be a codec called 'undefined', which can be set as the default encoding.  In this case, any forced conversion of encoding strings will be disabled: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys &gt;&gt;&gt; sys.setdefaultencoding(<span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) &gt;&gt;&gt; <span class="hljs-string"><span class="hljs-string">"foo"</span></span> + <span class="hljs-string"><span class="hljs-string">u"bar"</span></span> Traceback (most recent call last): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> UnicodeError(<span class="hljs-string"><span class="hljs-string">"undefined encoding"</span></span>) UnicodeError: undefined encoding</code> </pre><br><br>  And how does Python 3 solve the problem with codecs?  Python 3 removes all codecs that do not perform transformations of the form: Unicode &lt;-&gt; byte, and in addition, the byte string method .encode () and the string method .decode () are no longer needed.  This is a very bad decision, as it was very <br>  many useful codecs.  For example, it is very common to use conversion with the hex codec in Python 2: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">"\x00\x01"</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'hex'</span></span>) <span class="hljs-string"><span class="hljs-string">'0001'</span></span></code> </pre><br>  While you can say that in this particular case, the problem can be solved with a module like binascii, but the problem is deeper, the modules with codecs are available separately.  For example, libraries that implement reading from sockets use codecs to partially convert data from zlib library data streams: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> codecs &gt;&gt;&gt; decoder = codecs.getincrementaldecoder(<span class="hljs-string"><span class="hljs-string">'zlib'</span></span>)(<span class="hljs-string"><span class="hljs-string">'strict'</span></span>) &gt;&gt;&gt; decoder.decode(<span class="hljs-string"><span class="hljs-string">'x\x9c\xf3H\xcd\xc9\xc9Wp'</span></span>) <span class="hljs-string"><span class="hljs-string">'Hello '</span></span> &gt;&gt;&gt; decoder.decode(<span class="hljs-string"><span class="hljs-string">'\xcdK\xceO\xc9\xccK/\x06\x00+\xad\x05\xaf'</span></span>) <span class="hljs-string"><span class="hljs-string">'Encodings'</span></span></code> </pre><br>  In the end, the problem was recognized and these codecs were restored in Python 3.3.  However, now we are re-introducing the user into confusion, since codecs do not provide meta-information about the type that they can process before calling the functions.  For this reason, Python can now throw the following exceptions: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">"Hello World"</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'zlib_codec'</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; TypeError: <span class="hljs-string"><span class="hljs-string">'str'</span></span> does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> support the buffer interface</code> </pre><br><br>  (Please note that the codec is now called zlib_codec instead of zlib, since Python 3.3 did not retain the old codec notation) <br><br>  And what happens if we return the .encode () method to byte strings, for example?  This is easy to check, even without the Python interpreter hacks.  Write a function with the same behavior: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> codecs <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s, name, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> codec = codecs.lookup(name) rv, length = codec.encode(s, *args, **kwargs) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> isinstance(rv, (str, bytes, bytearray)): <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> TypeError(<span class="hljs-string"><span class="hljs-string">'Not a string or byte codec'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv</code> </pre><br><br>  Now we can use this function as a replacement for the .encode () method of byte strings: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-string"><span class="hljs-string">b'Hello World'</span></span>.encode(<span class="hljs-string"><span class="hljs-string">'latin1'</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; AttributeError: <span class="hljs-string"><span class="hljs-string">'bytes'</span></span> object has no attribute <span class="hljs-string"><span class="hljs-string">'encode'</span></span> &gt;&gt;&gt; encode(<span class="hljs-string"><span class="hljs-string">b'Hello World'</span></span>, <span class="hljs-string"><span class="hljs-string">'latin1'</span></span>) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> encode TypeError: Can<span class="hljs-string"><span class="hljs-string">'t convert '</span></span>bytes<span class="hljs-string"><span class="hljs-string">' object to str implicitly</span></span></code> </pre><br><br>  Aha  Python 3 is already able to work with this situation.  We get a nice error notification.  I believe that even ‚ÄúCan't convert 'bytes' object to str implicitly‚Äù is much better and clearer than ‚Äú'bytes' object has no attribute 'encode'‚Äù. <br><br>  Why not return these encoding conversion methods (encode and decode) back?  I really do not know and do not think about it anymore.  I have already been repeatedly explained that I do not understand anything and I do not understand beginners, or the fact that the ‚Äútext model‚Äù has changed and my requirements for it are meaningless. <br><br><h2>  Byte strings lost </h2><br><br>  Now, following the regression of the codec system, string operations have also changed: they are defined only for Unicode strings.  At first glance, this looks quite reasonable, but in reality it is not.  The interpreter used to have implementations for byte and Unicode strings.  This approach was completely obvious for programmers, if the object needed to have a representation in the form of a byte or Unicode string, two methods were defined: __ str__ and __unicode__.  Yes, of course, a forced change of the encoding was used, which confused newbies, but we had a choice. <br><br>  Why is this useful?  Because, for example, if you are working with low-level protocols, you often need to deal with numbers in a specific format within a byte string. <br><br>  The native version control system used by Python developers does not work on Python 3, because over the years the Python development team has <a href="http://bugs.python.org/issue3982">not wanted to return the formatting capability for byte strings</a> . <br><br>  All of the above shows: Python 3's string data handling model does not work in the real world.  For example, in Python 3, some APIs were updated, making them work only with Unicode, and therefore they are completely unsuitable for use in real work situations.  For example, now you can no longer analyze bytes using the standard library, but only the URL.  The reason for this is in the implicit assumption that all URLs are represented only in Unicode (in this situation, you will no longer be able to work with email messages in non-Unicode encoding, unless you completely ignore the existence of binary attachments to the letter). <br><br>  Previously, this was fairly easy to fix, but since byte strings are now lost for developers, the URL processing library now has two implementations.  One for Unicode, and the second for byte objects.  Two implementations for the same function lead to the fact that the result of data processing can be very different: <br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> urllib.parse <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> urlparse &gt;&gt;&gt; urlparse(<span class="hljs-string"><span class="hljs-string">'http://www.google.com/'</span></span>) ParseResult(scheme=<span class="hljs-string"><span class="hljs-string">'http'</span></span>, netloc=<span class="hljs-string"><span class="hljs-string">'www.google.com'</span></span>, path=<span class="hljs-string"><span class="hljs-string">'/'</span></span>, params=<span class="hljs-string"><span class="hljs-string">''</span></span>, query=<span class="hljs-string"><span class="hljs-string">''</span></span>, fragment=<span class="hljs-string"><span class="hljs-string">''</span></span>) &gt;&gt;&gt; urlparse(<span class="hljs-string"><span class="hljs-string">b'http://www.google.com/'</span></span>) ParseResultBytes(scheme=<span class="hljs-string"><span class="hljs-string">b'http'</span></span>, netloc=<span class="hljs-string"><span class="hljs-string">b'www.google.com'</span></span>, path=<span class="hljs-string"><span class="hljs-string">b'/'</span></span>, params=<span class="hljs-string"><span class="hljs-string">b''</span></span>, query=<span class="hljs-string"><span class="hljs-string">b''</span></span>, fragment=<span class="hljs-string"><span class="hljs-string">b''</span></span>)</code> </pre><br>  Looks like enough?  Not at all, because as a result we have completely different data types for the result of the operation. <br>  One of them is a tuple of strings, the second is more like an array of integers.  I already wrote about this <a href="http://lucumr.pocoo.org/2013/7/2/the-updated-guide-to-unicode/">earlier</a> and this condition causes me suffering.  Now, writing Python code gives me serious discomfort or becomes extremely inefficient, since you now have to go through a large number of data encoding transformations.  Because of this, it becomes very difficult to write code that implements all the necessary functions.  The idea that all Unicode is very good in theory, but completely inapplicable in practice. <br><br>  Python 3 is riddled with a bunch of crutches to handle situations where it is impossible to handle Unicode, and for people like me who work a lot with such situations, all this causes terrible irritation. <br><br><h2>  Our crutches do not work </h2><br><br>  Unicode support in branch 2.x is imperfect and far from ideal.  These are missing API, problems coming from different sides, but we, as programmers, did all this work.  Many of the methods we used to do this can no longer be applied in Python 3, and some APIs will be modified to work well with Python 3. <br><br>  My favorite example is the processing of file streams, which could be either byte or text, but there was no reliable method to determine which type of stream we are in front of.  The trick I helped popularize is reading zero bytes from a stream to determine its type.  Now this trick <a href="http://bugs.python.org/issue20007">doesn't work</a> .  For example, passing a request object to the urllib library of the Flask function that processes JSON does not work in Python 3, but it works in Python 2: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> urllib.request <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> urlopen &gt;&gt;&gt; r = urlopen(<span class="hljs-string"><span class="hljs-string">'https://pypi.python.org/pypi/Flask/json'</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json &gt;&gt;&gt; json.load(r) Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"decoder.py"</span></span>, line <span class="hljs-number"><span class="hljs-number">368</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> raw_decode StopIteration</code> </pre><br><br>  During the processing of the thrown exception, another one is thrown: <br><pre> <code class="python hljs">Traceback (most recent call last): File <span class="hljs-string"><span class="hljs-string">"&lt;stdin&gt;"</span></span>, line <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> &lt;module&gt; ValueError: No JSON object could be decoded</code> </pre><br><br><h2>  And what? </h2><br><br>  In addition to the problems that I described above, Python 3 with Unicode support also has a bunch of other problems.  I started to unsubscribe from the Python developer twitter because I was tired of reading which Python 3 is wonderful, as it contradicts my experience.  Yes, in Python 3 there are a lot of goodies, but that‚Äôs what they did with processing byte strings and Unicode doesn‚Äôt apply to them. <br><br>  (Worst of all, many of the really cool features of Python 3 usually work just as well in Python 2. For example, yield from, nonlocal, SNI SSL support, etc.) <br><br>  In light of the fact <a href="http://alexgaynor.net/2014/jan/03/pypi-download-statistics/">that only 3% of Python developers are actively using Python 3</a> , and Python developers on Twitter loudly declare that migration to Python 3 is proceeding as planned, I feel disappointed because I described my experience with Python 3 in detail and how I want it to get rid of. <br><br>  I don‚Äôt want to do it now, but I want the Python 3 development team to listen to the community a bit more.  For 97% of us, Python 2, a cozy little world in which we worked for years, and therefore quite painful is the situation when they come to us and declare: Python 3 is beautiful and is not discussed.  This is simply not the case in the light of many regressions.  Together with those people who are starting to discuss Python 2.8 and Stackless Python 2.8, I don‚Äôt know what a failure is if it‚Äôs not him. </div><p>Source: <a href="https://habr.com/ru/post/208192/">https://habr.com/ru/post/208192/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208180/index.html">Do arduino be one. Part 1</a></li>
<li><a href="../208182/index.html">How to connect Yii Framework and Doctrine 2 ORM?</a></li>
<li><a href="../208184/index.html">Cheap organization of a second PC in the apartment</a></li>
<li><a href="../208186/index.html">Dynamic programming in templates</a></li>
<li><a href="../208188/index.html">Guided Acoustic Levitation: Another Example</a></li>
<li><a href="../208196/index.html">Hire people in DevOps and other bad ideas</a></li>
<li><a href="../208198/index.html">The creators of PirateBay figured out how to protect against blocking</a></li>
<li><a href="../208200/index.html">We leave users secret messages and play agents</a></li>
<li><a href="../208202/index.html">Cheat Sheet by Ethernet 802.3 Types and Standards</a></li>
<li><a href="../208206/index.html">Creating a simple REST application on Silex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>