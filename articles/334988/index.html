<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Struct, union, and enum types in Modern C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ has changed a lot in the last 10 years. Even the basic types have changed: struct, union and enum. Today we will briefly go through all the chang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Struct, union, and enum types in Modern C ++</h1><div class="post__text post__text-html js-mediator-article"><p>  C ++ has changed a lot in the last 10 years.  Even the basic types have changed: struct, union and enum.  Today we will briefly go through all the changes from C ++ 11 to C ++ 17, take a look at C ++ 20 and at the end draw up a list of good style rules. </p><a name="habracut"></a><br><h2 id="zachem-nuzhen-tip-struct">  Why do I need type struct </h2><br><p>  The type of struct is fundamental.  According to the C ++ Code Guidelines, it is better to use struct for storing values ‚Äã‚Äãthat are not related to the invariant.  Notable examples are RGBA-color, vectors from 2, 3, 4 elements or information about a book (name, number of pages, author, year of publication, etc.). </p><br><blockquote>  Rule <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C.2: Use class if the class has an invariant;</a>  <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">use if this data members can independently</a> </blockquote><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookStats</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> title; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; authors; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tags; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> pageCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> publishingYear = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  It looks like a class, but there are two minor differences: </p><br><ul><li>  by default, struct has a public visibility, and private in a class </li><li>  by default, the struct inherits the members of the base structures / classes as public members, and the class as private members </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  data  struct Base { std::string data; }; // Base  ,     `: public Base` struct Derived : Base { };</span></span></code> </pre> <br><p>  According to C ++ Core Guidelines, it is good to use struct to reduce the number of parameters of a function.  This refactoring technique is known as the "parameter object". </p><br><blockquote>  Rule <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C.1: Organize related data into structures (structs or classes)</a> </blockquote><p>  In addition, structures can make the code more concise.  For example, in 2D and 3D graphics it is more convenient to count in 2 and 3 component vectors than in numbers.  Below is the code that uses the GLM library ( <a href="http://glm.g-truc.net/0.9.8/index.html">Open <strong>GL</strong> <strong>M</strong> athematics</a> ) </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      // . https://en.wikipedia.org/wiki/Polar_coordinate_system glm::vec2 euclidean(float radius, float angle) { return { radius * cos(angle), radius * sin(angle) }; } //     , //     . std::vector&lt;VertexP2C4&gt; TesselateCircle(float radius, const glm::vec2&amp; center, IColorGenerator&amp; colorGen) { assert(radius &gt; 0); //     . //       2. constexpr float step = 2; //     ,     . const auto pointCount = static_cast&lt;unsigned&gt;(radius * 2 * M_PI / step); //  -  . std::vector&lt;glm::vec2&gt; points(pointCount); for (unsigned pi = 0; pi &lt; pointCount; ++pi) { const auto angleRadians = static_cast&lt;float&gt;(2.f * M_PI * pi / pointCount); points[pi] = center + euclidean(radius, angleRadians); } return TesselateConvexByCenter(center, points, colorGen); }</span></span></code> </pre> <br><h2 id="evolyuciya-struct">  Evolution struct </h2><br><p>  In C ++ 11, initialization of fields appeared during the declaration. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookStats</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> title; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; authors; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; tags; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> pageCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> publishingYear = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br><p>  Previously, for such purposes, you had to write your own constructor: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// !   ! struct BookStats { BookStats() : pageCount(0), publishingYear(0) {} std::string title; std::vector&lt;std::string&gt; authors; std::vector&lt;std::string&gt; tags; unsigned pageCount; unsigned publishingYear; };</span></span></code> </pre> <br><p>  Along with initialization, a problem came up during the declaration: we cannot use the structure literal if it uses field initialization during the declaration: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// C++11, C++14:    -  pageCount  publishingYear // C++17:   const auto book = BookStats{ u8"  ", { u8" " }, { u8"", u8"" }, 576, 1965 };</span></span></code> </pre> <br><p>  In C ++ 11 and C ++ 14, this was solved manually by writing a constructor with boilerplate code.  You do not need to add anything in C ++ 17 - the standard explicitly allows aggregate initialization for structures with field initializers. </p><br><p>  The example contains constructors that are needed only in C ++ 11 and C ++ 14: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BookStats</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// !  ! BookStats() = default; // !  ! BookStats( std::string title, std::vector&lt;std::string&gt; authors, std::vector&lt;std::string&gt; tags, unsigned pageCount, unsigned publishingYear) : title(std::move(title)) , authors(std::move(authors)) , tags(std::move(authors)) // ;) , pageCount(pageCount) , publishingYear(publishingYear) { } std::string title; std::vector&lt;std::string&gt; authors; std::vector&lt;std::string&gt; tags; unsigned pageCount = 0; unsigned publishingYear = 0; };</span></span></code> </pre> <br><p>  In C ++ 20, aggregate initialization promises to be even better!  To understand the problem, take a look at the example below and name each of the five initialized fields.  Is the initialization order confused?  What if someone during the refactoring will swap fields in the structure declaration? </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> book = BookStats{ <span class="hljs-string"><span class="hljs-string">u8"  "</span></span>, { <span class="hljs-string"><span class="hljs-string">u8" "</span></span> }, { <span class="hljs-string"><span class="hljs-string">u8""</span></span>, <span class="hljs-string"><span class="hljs-string">u8""</span></span> }, <span class="hljs-number"><span class="hljs-number">1965</span></span>, <span class="hljs-number"><span class="hljs-number">576</span></span> };</code> </pre> <br><p>  In C11, there was a convenient opportunity to specify field names when initializing a structure.  This opportunity is promised to be included in C ++ 20 under the name "designated initializer" ("designated initializer").  Read more about this in the article <a href="https://habrahabr.ru/post/333414/">Road to C ++ 20</a> . </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    C++20 const auto book = BookStats{ .title = u8"  ", .authors = { u8" " }, .tags = { u8"", u8"" }, .publishingYear = 1965, .pageCount = 576 };</span></span></code> </pre> <br><p>  In C ++ 17, structured binding, also known as "decomposition at <br>  declaration ". This mechanism works with structures with <code>std::pair</code> and <code>std::tuple</code> and complements aggregate initialization. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   const auto book = BookStats{ u8"  ", { u8" " }, { u8"", u8"" }, 576, 1965 }; //   const auto [title, authors, tags, pagesCount, publishingYear] = book;</span></span></code> </pre> <br><p>  In combination with the classes STL, this feature can make the code more elegant: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;map&gt; #include &lt;cassert&gt; #include &lt;iostream&gt; int main() { std::map&lt;std::string, int&gt; map = { { "hello", 1 }, { "world", 2 }, { "it's", 3 }, { "me", 4 }, }; //  ‚Ññ1 -   [iterator, bool] auto [helloIt, helloInserted] = map.insert_or_assign("hello", 5); auto [goodbyeIt, goodbyeInserted] = map.insert_or_assign("goodbye", 6); assert(helloInserted == false); assert(goodbyeInserted == true); //  ‚Ññ2 -   [key, value] for (auto&amp;&amp; [ key, value ] : map) std::cout &lt;&lt; "key=" &lt;&lt; key &lt;&lt; " value=" &lt;&lt; value &lt;&lt; '\n'; }</span></span></span></span></code> </pre> <br><h2 id="zachem-nuzhen-tip-union">  Why do we need a union type </h2><br><p>  In fact, in C ++ 17, it is not needed in everyday code.  C ++ Core Guidelines offer to build code on the principle of static type safety, which allows the compiler to give an error when frankly incorrect data processing.  Use std :: variant as a safe replacement for union. </p><br><p>  If you recall history, the union allows you to reuse the same area of ‚Äã‚Äãmemory to store different data fields.  The union type is often used in multimedia libraries.  The second union union is played in them: the identifiers of the fields of the anonymous union fall into the external scope. </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// !     ! // Event   : type, mouse, keyboard //  mouse  keyboard      struct Event { enum EventType { MOUSE_PRESS, MOUSE_RELEASE, KEYBOARD_PRESS, KEYBOARD_RELEASE, }; struct MouseEvent { unsigned x; unsigned y; }; struct KeyboardEvent { unsigned scancode; unsigned virtualKey; }; EventType type; union { MouseEvent mouse; KeyboardEvent keyboard; }; };</span></span></code> </pre> <br><h2 id="evolyuciya-union">  Evolution of union </h2><br><p>  In C ++ 11, you can add in data types that have their own constructors.  You can declare your constructor union.  However, the presence of a constructor does not yet mean correct initialization: in the example below, the field of type std :: string is filled with zeros and may well be invalid immediately after the construction of the union (in fact, it depends on the implementation of STL). </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// !     ! union U { unsigned a = 0; std::string b; U() { std::memset(this, 0, sizeof(U)); } }; //    -  b       U u; ub = "my value";</span></span></code> </pre> <br><p>  In C ++ 17, the code might look different using variant.  Inside, a variant uses unsafe constructs that are not much different from union, but this dangerous code is hidden inside a highly reliable, well-established and tested STL. </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;variant&gt; struct MouseEvent { unsigned x = 0; unsigned y = 0; }; struct KeyboardEvent { unsigned scancode = 0; unsigned virtualKey = 0; }; using Event = std::variant&lt; MouseEvent, KeyboardEvent&gt;;</span></span></span></span></code> </pre> <br><h2 id="zachem-nuzhen-tip-enum">  Why do I need the type of enum </h2><br><p>  The enum type is good to use wherever there are states.  Alas, many programmers do not see the states in the logic of the program and do not guess to use enum. </p><br><p>  Below is a sample code where logically related boolean fields are used instead of enum.  What do you think, will the class work correctly if m_threadShutdown is true and m_threadInitialized is false? </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// !   ! class ThreadWorker { public: // ... private: bool m_threadInitialized = false; bool m_threadShutdown = false; };</span></span></code> </pre> <br><p>  Not only is atomic not used here, which is most likely needed in a class called <code>Thread*</code> , but you can also replace boolean fields with enum. </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadWorker</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... private: enum class State { NotStarted, Working, Shutdown }; //   ATOMIC_VAR_INIT    atomic   . //     compare_and_exchange_strong! std::atomic&lt;State&gt; = ATOMIC_VAR_INIT(State::NotStarted); };</span></span></code> </pre> <br><p>  Another example is the magic numbers, without which, ostensibly, nothing.  Suppose you have a gallery of 4 slides, and the programmer decided to work hard on the content generation of these slides, so as not to write your own framework for slide galleries.  Such code appeared: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// !   ! void FillSlide(unsigned slideNo) { switch (slideNo) { case 1: setTitle("..."); setPictureAt(...); setTextAt(...); break; case 2: setTitle("..."); setPictureAt(...); setTextAt(...); break; // ... } }</span></span></code> </pre> <br><p>  Even if the hardcode slide is justified, nothing can justify the magic numbers.  They are easy to replace with enum, and this will at least increase readability. </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> SlideId { Slide1 = <span class="hljs-number"><span class="hljs-number">1</span></span>, Slide2, Slide3, Slide4 };</code> </pre> <br><p>  Sometimes enum is used as a set of flags.  This generates not very visual code: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// !   -  ! enum TextFormatFlags { TFO_ALIGN_CENTER = 1 &lt;&lt; 0, TFO_ITALIC = 1 &lt;&lt; 1, TFO_BOLD = 1 &lt;&lt; 2, }; unsigned flags = TFO_ALIGN_CENTER; if (useBold) { flags = flags | TFO_BOLD; } if (alignLeft) { flag = flags &amp; ~TFO_ALIGN_CENTER; } const bool isBoldCentered = (flags &amp; TFO_BOLD) &amp;&amp; (flags &amp; TFO_ALIGN_CENTER);</span></span></code> </pre> <br><p>  Perhaps you should use <code>std::bitset</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TextFormatBit { TextFormatAlignCenter = <span class="hljs-number"><span class="hljs-number">0</span></span>, TextFormatItalic, TextFormatBold, <span class="hljs-comment"><span class="hljs-comment">//      , //     0,    //     1  . TextFormatCount }; std::bitset&lt;TextFormatCount&gt; flags; flags.set(TextFormatAlignCenter, true); if (useBold) { flags.set(TextFormatBold, true); } if (alignLeft) { flags.set(TextFormatAlignCenter, false); } const bool isBoldCentered = flags.test(TextFormatBold) || flags.test(TextFormatAlignCenter);</span></span></code> </pre> <br><p>  Sometimes programmers write constants in the form of macros.  Such macros are easy to replace with enum or constexpr. </p><br><blockquote>  <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html">Enum.1</a> rule <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html">: prefer enumerated types to macros</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// !   -   C99     ! #define RED 0xFF0000 #define GREEN 0x00FF00 #define BLUE 0x0000FF #define CYAN 0x00FFFF // ,   C99,      enum ColorId : unsigned { RED = 0xFF0000, GREEN = 0x00FF00, BLUE = 0x0000FF, CYAN = 0x00FFFF, }; //  Modern C++ enum class WebColorRGB { Red = 0xFF0000, Green = 0x00FF00, Blue = 0x0000FF, Cyan = 0x00FFFF, };</span></span></code> </pre> <br><h2 id="evolyuciya-enum">  Evolution of enum </h2><br><p>  In C ++ 11, a scoped enum appeared, aka the <code>enum class</code> or <code>enum struct</code> .  This modification of enum solves two problems: </p><br><ul><li>  The scope of the constants enum class is the enum class itself, i.e.  outside instead of <code>Enum e = EnumValue1</code> you will have to write <code>Enum e = Enum::Value1</code> , which is much clearer </li><li>  The enum is converted to an integer without any restrictions, and in the enum class this will require a static cast: <code>const auto value = static_cast&lt;unsigned&gt;(Enum::Value1)</code> </li></ul><br><p>  In addition, for enum and scoped enum, it was possible to explicitly select the type used to represent the enumeration in the code generated by the compiler: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Flags</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... };</span></span></code> </pre> <br><p>  In some new languages, such as Swift or Rust, the enum type is strict by default in type conversions, and the constants are nested within an enum type scope.  In addition, enum fields may carry additional data, as in the example below. </p><br><pre> <code class="hljs pgsql">// enum   Swift enum Barcode { //    upc  <span class="hljs-number"><span class="hljs-number">4</span></span>   <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> upc(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) //    qrCode    String <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> qrCode(String) }</code> </pre> <br><p>  Such an enum is equivalent to the type <code>std::variant</code> , included in C ++ in the standard C ++ 2017. Thus, <code>std::variant</code> replaces the enum in the structure and class field, if this enum essentially represents a state.  You get guaranteed observance of the stored data invariant without additional efforts and checks.  Example: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnonymousAccount</span></span></span><span class="hljs-class"> {</span></span> }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserAccount</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> nickname; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> email; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> password; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OAuthAccount</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> nickname; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> openId; }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Account = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::variant&lt;AnonymousAccount, UserAccount, OAuthAccount&gt;;</code> </pre> <br><h2 id="pravila-horoshego-stilya">  Good style rules </h2><br><p>  Let's summarize in the form of a list of rules: </p><br><ul><li>  <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C.1: organize logically related data into structures or classes</a> </li><li>  <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C.2: use class if data is bound by an invariant;</a>  <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">use struct if data can change independently</a> <br><ul><li>  <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines.html">C.8: use class instead of struct if at least one field is not public</a> </li></ul></li><li>  use decomposition when declaring variables with structures, <code>std::pair</code> and <code>std::tuple</code> : <code>auto [a, b, c] = std::tuple(32, "hello"s, 13.9)</code> <br><ul><li>  instead of out-parameters, return a structure or a tuple from a function </li></ul></li><li>  specify field initializers, without them you will get uninitialized garbage fields <br><ul><li>  do not initialize fields with zeros in constructors, rely on field initializers </li></ul></li><li>  In general, do not write structure constructors, use aggregate initialization. </li><li>  use <code>std::variant</code> as a safe replacement for union instead of structure or class if the data is strictly in one of several states, and in some states some fields lose their meaning </li><li>  use <code>enum class</code> or <code>std::variant</code> to represent the internal state of objects <br><ul><li>  prefer <code>std::variant</code> , if in different states the class is able to store different data fields </li></ul></li><li>  use <code>enum class</code> instead of <code>enum</code> in most cases <br><ul><li>  use old <code>enum</code> if implicit conversion of enum to integer is extremely important to you </li><li>  use <code>enum class</code> or <code>enum</code> instead of magic numbers </li><li>  use <code>enum class</code> , <code>enum</code> or <code>constexpr</code> instead of constant macros </li></ul></li></ul><br><p>  From such trifles, the beauty and conciseness of the code in the function bodies is built.  Laconic functions are easy to review for Code Review and easy to maintain.  They build good classes, and then good software modules.  As a result, programmers are happy, smiles are blooming on their faces. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/334988/">https://habr.com/ru/post/334988/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334978/index.html">Shops / developers / buyers / publishers</a></li>
<li><a href="../334980/index.html">Hidden messages in JavaScript property names</a></li>
<li><a href="../334982/index.html">Application availability for visually impaired users</a></li>
<li><a href="../334984/index.html">Resource planning. Part 1. What is it all about?</a></li>
<li><a href="../334986/index.html">Comedy. Actors in Node.JS for flexible scaling</a></li>
<li><a href="../334990/index.html">Introduction to octree</a></li>
<li><a href="../334992/index.html">How to view 20 million domain names and be satisfied</a></li>
<li><a href="../334994/index.html">I want to like YouTube</a></li>
<li><a href="../334996/index.html">Usability card product. Scenario profitable for business</a></li>
<li><a href="../334998/index.html">Protection of the site against attacks using Nemesida WAF: from signatures to artificial intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>