<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We optimize Boid's on Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Did you know that grasshoppers, being thrown into a bucket, begin to march in a circle as in the picture above? True, the top is not grasshoppers, and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We optimize Boid's on Unity</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/fee/73a/037/fee73a0373017f4b2a0e50fe73e9308b.jpg"><br><br>  Did you know that grasshoppers, being thrown into a bucket, begin to march in a circle as in the picture above?  True, the top is not grasshoppers, and the <a href="http://www.red3d.com/cwr/boids/">Boids</a> are a model of the collective behavior of birds, bees, fish and other living creatures.  Despite the simplicity of the model, it demonstrates the emergent properties: boids gather in a heap, fly in flocks in a circle, attack people. <br><br>  This is the second part of the article, devoted to various tricks of Unity and C # optimization, which increase the performance of the algorithm from the <a href="http://habrahabr.ru/post/182382/">first part</a> a couple of dozen times. <br><a name="habracut"></a><br><h4>  A couple of modifications </h4><br><div class="spoiler">  <b class="spoiler_title">Let me remind you of what we stopped.</b>  <b class="spoiler_title">Boid.cs from the previous part without optimizations</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Boid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 velocity; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionRadius = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> separationDistance = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Collider[] boids; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 cohesion; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 separation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> separationCount; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 alignment; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxSpeed = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateVelocity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { velocity = Vector3.zero; cohesion = Vector3.zero; separation = Vector3.zero; separationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; alignment = Vector3.zero; boids = Physics.OverlapSphere(transform.position, cohesionRadius); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> boids) { cohesion += boid.transform.position; alignment += boid.GetComponent&lt;Boid&gt;().velocity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boid != collider &amp;&amp; (transform.position - boid.transform.position).magnitude &lt; separationDistance) { separation += (transform.position - boid.transform.position) / (transform.position - boid.transform.position).magnitude; separationCount++; } } cohesion = cohesion / boids.Length; cohesion = cohesion - transform.position; cohesion = Vector3.ClampMagnitude(cohesion, maxSpeed); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (separationCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { separation = separation / separationCount; separation = Vector3.ClampMagnitude(separation, maxSpeed); } alignment = alignment / boids.Length; alignment = Vector3.ClampMagnitude(alignment, maxSpeed); velocity += cohesion + separation * <span class="hljs-number"><span class="hljs-number">10</span></span> + alignment * <span class="hljs-number"><span class="hljs-number">1.5f</span></span>; velocity = Vector3.ClampMagnitude(velocity, maxSpeed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.position.magnitude &gt; <span class="hljs-number"><span class="hljs-number">25</span></span>) { velocity += -transform.position.normalized; } transform.position += velocity * Time.deltaTime; Debug.DrawRay(transform.position, separation, Color.green); Debug.DrawRay(transform.position, cohesion, Color.magenta); Debug.DrawRay(transform.position, alignment, Color.blue); } }</code> </pre> </div></div><br>  Let's start with a few cosmetic changes that will simplify further work and bring the code closer to what can be found in real life.  Let's change the model of the boat so that it looks more like a bird and at the same time contains fewer triangles.  A simple Blender pyramid will be enough.  We throw the .blend file into the project daddy, select it in the inspector and disable the extra in the import settings.  We copy the old prefab and make a new one, on which we will conduct experiments. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/b91/b79/0df/b91b790df283c1f2fc018fb5a9e8211a.jpg"><br><br>  Since the prefab now has a direction, you should add a rotation to the Update script.  There are a <a href="http://docs.unity3d.com/Documentation/ScriptReference/Quaternion.RotateTowards.html">huge</a> <a href="http://docs.unity3d.com/Documentation/ScriptReference/Quaternion.Slerp.html">number of</a> <a href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.Slerp.html">options</a> for turning objects, but we‚Äôll take <a href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3.RotateTowards.html">Vector3.RotateTowards</a> , because it‚Äôs simple and we don‚Äôt care.  First, we check whether we need to do something at all, then turn it smoothly. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (velocity != Vector3.zero &amp;&amp; transform.forward != velocity.normalized) { transform.forward = Vector3.RotateTowards(transform.forward, velocity, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  At the same time we will alter the code that puts boids on the stage.  Junk hierarchy is bad practice, so we‚Äôll hide all the boids with <a href="http://docs.unity3d.com/Documentation/ScriptReference/Transform-parent.html">Transform.parent</a> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boid = Instantiate(boidPrefab, Random.insideUnitSphere * <span class="hljs-number"><span class="hljs-number">25</span></span>, Quaternion.identity) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Transform; boid.parent = transform;</code> </pre><br><h4>  Getting down to business </h4><br>  Let's start with the banal.  In our cycle, we subtract transform.position three times - boid.transform.position.  This is bad, better shove the result into a variable.  On a hundred Boids, this may not matter, but on a couple of thousands in a cycle, and even a few times a second, the difference will already be. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vector = transform.position - boid.transform.position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boid != collider &amp;&amp; vector.magnitude &lt; separationDistance) { separation += vector / vector.magnitude; separationCount++; }</code> </pre><br>  In the same <a href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3-magnitude.html">place</a> , there is <a href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3-magnitude.html">Vector3.magnitude</a> , which requires square root calculations.  To compare distances, you can replace <a href="http://docs.unity3d.com/Documentation/ScriptReference/Vector3-sqrMagnitude.html">Vector3.sqrMagnitude</a> .  At the same time, we will change the magnitude in the formula for calculating the weighted vector, this will not greatly affect the result. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boid != collider &amp;&amp; vector.sqrMagnitude &lt; separationDistance * separationDistance) { separation += vector / vector.sqrMagnitude; separationCount++; } ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (transform.position.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">25</span></span> * <span class="hljs-number"><span class="hljs-number">25</span></span>) { velocity += -transform.position.normalized; }</code> </pre><br><h4>  Transform and GetComponent </h4><br>  In our code, the <a href="http://docs.unity3d.com/Documentation/ScriptReference/GameObject-transform.html">transform</a> call occurs more than a dozen times and often occurs in a loop.  We multiply this by the number of boids and we get a sad picture.  Behind the access to transform is actually an expensive component search.  To avoid this, we cache it in a separate variable during an <a href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.Awake.html">awake</a> .  This event is fired before the game starts at boot time.  At the same time, you can change the transform call from the collider to a call to a public script variable, and compare with your own collider to a condition with a square of distance. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform tr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { tr = transform; }</code> </pre><br>  Replace all transform references with tr. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> boid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> boids) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = boid.GetComponent&lt;Boid&gt;(); cohesion += b.tr.position; alignment += b.velocity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vector.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; (tr.position - b.tr.position).magnitude &lt; separationDistance) { separation += (tr.position - b.tr.position) / (tr.position - b.tr.position).magnitude; separationCount++; } }</code> </pre><br><h4>  Optimize further </h4><br>  Well, already much better, but the FPS still sags when the boids get very close.  And all because <a href="http://docs.unity3d.com/Documentation/ScriptReference/Physics.OverlapSphere.html">Physics.OverlapSphere</a> begins to capture an increasing number of colliders and we get almost the same quadratic complexity of a simple search through all boids. <br><br>  <a href="http://en.wikipedia.org/wiki/Flocking_(behavior)">According to the Internet</a> , swallows in flocks are oriented in just half a dozen neighbors.  Than boida worse?  We take and tritely limit the cycle to one more condition.  For two conditions, the for loop is better suited.  In addition, it makes sense to limit not only the maximum number of neighbors, but also the minimum.  Add an exit condition if there are no neighbors nearby.  In addition, we will have to change the denominator in the calculation of vectors, otherwise, with a large crowding of neighbors, the Boids will not have a chance to get out. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxBoids = <span class="hljs-number"><span class="hljs-number">5</span></span>; ‚Ä¶ boids = Physics.OverlapSphere(tr.position, cohesionRadius); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boids.Length &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; boids.Length &amp;&amp; i &lt; maxBoids; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = boids[i].GetComponent&lt;Boid&gt;(); cohesion += b.tr.position; alignment += b.velocity; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vector = tr.position - b.tr.position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vector.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; vector.sqrMagnitude &lt; separationDistance * separationDistance) { separation += vector / vector.magnitude; separationCount++; } } cohesion = cohesion / (boids.Length &gt; maxBoids ? maxBoids : boids.Length);</code> </pre><br>  Now the main problem is that we update the velocity vector too often.  Let's step aside a bit and put things in order in the inspector to make it easier to tweak the algorithm.  Let's make all important variables public, but hide some with the <a href="http://docs.unity3d.com/Documentation/ScriptReference/HideInInspector.html">HideInInspector</a> attribute and add a couple of new ones.  We add the tick parameter, we substitute it in a timer on the timer. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turnSpeed = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxSpeed = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionRadius = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxBoids = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> separationDistance = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionCoefficient = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alignmentCoefficient = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> separationCoefficient = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tick = <span class="hljs-number"><span class="hljs-number">2</span></span>; [HideInInspector] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 velocity; [HideInInspector] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform tr; ‚Ä¶ InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, tick);</code> </pre><br>  Next, do the feint ears and set the update rate of 2 seconds.  Yes, yes, you heard right, twenty times less often than we had.  At the same time adjust the factors.  Now, instead of hundreds of boids, we can create a thousand. <br><br><img src="http://habrastorage.org/storage2/7b7/04d/f2c/7b704df2c02bc4cc957d3409b749e36e.jpg"><br><br><h4>  Optimized, optimized, but not optimized </h4><br>  New problem.  Every two seconds, all boids start the calculation of new vectors and there is a noticeable ripple.  The effect is, of course, interesting, but the birds do not know how.  We do one more simple optimization - we distribute calculations on time with the help of <a href="http://docs.unity3d.com/Documentation/ScriptReference/Random-value.html">Random.value</a> . <br><br><pre> <code class="cs hljs">InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * tick, tick);</code> </pre><br>  Well, so that the start of the simulation does not look too strange, in Awake we also add an element of randomness from <a href="http://docs.unity3d.com/Documentation/ScriptReference/Random-onUnitSphere.html">Random.onUnitSphere</a> . <br><br><pre> <code class="cs hljs">velocity = Random.onUnitSphere * maxSpeed;</code> </pre><br>  We look at our code more closely. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = boids[i].GetComponent&lt;Boid&gt;(); ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vector = tr.position - b.tr.position;</code> </pre><br>  For the creation of temporary variables in the cycle, the evil garbage collector will sooner or later eat off our processor.  If we know that we regularly do the same actions, then we can create permanent variables. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Boid b; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 vector; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i;</code> </pre><br>  We should not forget that sometimes, instead of optimizing the code, it is better to optimize the logic.  In Update, we have a check for going beyond the boundaries of the sphere where normalization is used. <br><br><pre> <code class="cs hljs">velocity += -tr.position.normalized;</code> </pre><br>  This is too accurate a function for such a purpose.  If we need not a strict unit vector, but only a direction, then the vector can be simply divided. <br><br><pre> <code class="cs hljs">velocity += -tr.position/<span class="hljs-number"><span class="hljs-number">25</span></span>;</code> </pre><br>  We can knock off another couple of milliseconds of calculations if we take out the turn of the boids into a separate function and run on a timer. <br><br><pre> <code class="cs hljs">InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"UpdateRotation"</span></span>, Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateRotation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (velocity != Vector3.zero &amp;&amp; model.forward != velocity.normalized) { model.forward = Vector3.RotateTowards(model.forward, velocity, turnSpeed, <span class="hljs-number"><span class="hljs-number">1</span></span>); } }</code> </pre><br><h4>  Physics </h4><br>  You probably noticed that we do not use physics at all, if we do not take into account the search for colliders.  We can save a little more resources if we move the boids into a separate layer, we will look for colliders using <a href="http://docs.unity3d.com/Documentation/ScriptReference/LayerMask.html">LayerMask</a> and turn off collision checking between boids in the physics settings. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LayerMask boidsLayer; ‚Ä¶ boids = Physics.OverlapSphere(tr.position, cohesionRadius, boidsLayer.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>);</code> </pre><br>  A bunch of FPS can be obtained if you unscrew to the minimum the <a href="http://docs.unity3d.com/Documentation/ScriptReference/Physics-solverIterationCount.html">Solver Iteration Count</a> in the <a href="http://docs.unity3d.com/Documentation/Components/class-PhysicsManager.html">Physics Manager</a> .  In addition, you can try to play with the Fixed Timestep and Maximum Allowed Timestep in the <a href="http://docs.unity3d.com/Documentation/Components/class-TimeManager.html">Time Manager</a> , but if you get carried away, the simulation will become chaotic and unattractive. <br><br>  One more nuance is associated with rotation.  When we rotate the model, we rotate the spherical collider attached to it.  Expensive and useless.  The problem is solved by separating the model from the collider in the hierarchy.  So you can win another FPS heels. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform model; ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (velocity != Vector3.zero &amp;&amp; model.forward != velocity.normalized) { model.forward = Vector3.RotateTowards(model.forward, velocity, turnSpeed, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br><h4>  Conclusion </h4><br>  That's all.  The bulk of resources eats away moving heaps of objects in a frame and searching for neighbors.  It's hard to do something with the first one, but for the second one you need to stop using physics altogether and change it to tricky data structures, but this is a topic for a separate article.  I hope that the wise hackers in the comments will offer their options for accelerating the boids. <br><br><div class="spoiler">  <b class="spoiler_title">Optimized version of Boid.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Boid</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> turnSpeed = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxSpeed = <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionRadius = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> maxBoids = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> separationDistance = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> cohesionCoefficient = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> alignmentCoefficient = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> separationCoefficient = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> tick = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform model; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LayerMask boidsLayer; [HideInInspector] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 velocity; [HideInInspector] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Transform tr; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Collider[] boids; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 cohesion; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 separation; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> separationCount; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 alignment; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Boid b; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector3 vector; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { tr = transform; velocity = Random.onUnitSphere*maxSpeed; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"CalculateVelocity"</span></span>, Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> * tick, tick); InvokeRepeating(<span class="hljs-string"><span class="hljs-string">"UpdateRotation"</span></span>, Random.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CalculateVelocity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { boids = Physics.OverlapSphere(tr.position, cohesionRadius, boidsLayer.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (boids.Length &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; velocity = Vector3.zero; cohesion = Vector3.zero; separation = Vector3.zero; separationCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; alignment = Vector3.zero; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; boids.Length &amp;&amp; i &lt; maxBoids; i++) { b = boids[i].GetComponent&lt;Boid&gt;(); cohesion += b.tr.position; alignment += b.velocity; vector = tr.position - b.tr.position; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vector.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; vector.sqrMagnitude &lt; separationDistance * separationDistance) { separation += vector / vector.sqrMagnitude; separationCount++; } } cohesion = cohesion / (boids.Length &gt; maxBoids ? maxBoids : boids.Length); cohesion = Vector3.ClampMagnitude(cohesion - tr.position, maxSpeed); cohesion *= cohesionCoefficient; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (separationCount &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { separation = separation / separationCount; separation = Vector3.ClampMagnitude(separation, maxSpeed); separation *= separationCoefficient; } alignment = alignment / (boids.Length &gt; maxBoids ? maxBoids : boids.Length); alignment = Vector3.ClampMagnitude(alignment, maxSpeed); alignment *= alignmentCoefficient; velocity = Vector3.ClampMagnitude(cohesion + separation + alignment, maxSpeed); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateRotation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (velocity != Vector3.zero &amp;&amp; model.forward != velocity.normalized) { model.forward = Vector3.RotateTowards(model.forward, velocity, turnSpeed, <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tr.position.sqrMagnitude &gt; <span class="hljs-number"><span class="hljs-number">25</span></span> * <span class="hljs-number"><span class="hljs-number">25</span></span>) { velocity += -tr.position / <span class="hljs-number"><span class="hljs-number">25</span></span>; } tr.position += velocity * Time.deltaTime; } }</code> </pre><br></div></div><br>  <b>Note: The code for the links below is outdated; see the <a href="https://github.com/Syomus/ProceduralToolkit">Procedural Toolkit for the</a> latest version.</b> <br><br>  <a href="https://github.com/BasmanovDaniil/Boids">Sources on GitHub</a> |  <a href="http://basmanovdaniil.github.io/Boids/">Online version for owners of Unity Web Player</a> </div><p>Source: <a href="https://habr.com/ru/post/182690/">https://habr.com/ru/post/182690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../182676/index.html">Access to hidden UEFI BIOS settings from Insyde</a></li>
<li><a href="../182678/index.html">Creating a multiplayer realtime game on node.js</a></li>
<li><a href="../182684/index.html">Bees can communicate through weak electric fields</a></li>
<li><a href="../182686/index.html">Bruce Schneier: The Illusion of Security</a></li>
<li><a href="../182688/index.html">Microsoft Dryad vs Apache Hadoop. Uncomplicated Big Data Battle</a></li>
<li><a href="../182698/index.html">Edward Snowden: an informant who gave secrets to the NSA</a></li>
<li><a href="../182702/index.html">How to test the finalizer code (c #)</a></li>
<li><a href="../182704/index.html">Infographics - Tor, HTTPS and Security</a></li>
<li><a href="../182706/index.html">Camjacking, like the evolution of Clickjacking, or ‚ÄúGyulchatay! Open your face! ‚Äù</a></li>
<li><a href="../182708/index.html">ASUS Padfone Infinity Review</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>