<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Camel in questions and answers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On April 6-7, for the sixth time in Moscow, the JPoint will be held - an international Java conference for experienced developers. This time Claus Ibs...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Camel in questions and answers</h1><div class="post__text post__text-html js-mediator-article">  On April 6-7, for the sixth time in Moscow, the <a href="https://jpoint.ru/">JPoint</a> will be <a href="https://jpoint.ru/">held</a> - an international Java conference for experienced developers.  This time Claus Ibsen (Claus Ibsen) - Red Hat senior engineer, Apache guru will take part in it.  Below is a translation of the beginning of his book Camel in Action - exclusively for readers of our blog. <br><br><img src="https://habrastorage.org/webt/v2/nv/w8/v2nvw8zldme8svxys3aelamtnyi.jpeg" width="100%"><br><br><a name="habracut"></a><br><h2>  Meet Camel </h2><br>  Creating complex systems from scratch is costly and almost always doomed to failure.  It is much more efficient and safer to assemble them as a jigsaw puzzle from existing and proven components.  In everyday life, we often rely on such integrated systems: from telephone communications and financial transactions to medical services and travel and entertainment planning. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A puzzle can be assembled only if you have all its fragments, and they are easily and securely connected to each other.  The same is true for systems integration projects.  But if the pieces of this puzzle are created in order to form a single picture, then with IT systems, the situation is usually the opposite.  As a developer, you, as a rule, are not very worried about the internal structure and operation of integrable systems, you are much more interested in how to interact with it from the outside.  A good integration framework (platform) implies two things: firstly, a simple and convenient abstraction apparatus for describing complex integrable systems, and secondly, a connecting mechanism that allows to combine them into a single whole. <br><br>  An example of such a platform is Apache Camel.  This book will help you understand what Camel is, how to use it, and why we consider it one of the best integration platforms.  The first chapter begins with an introduction to Camel and a description of its main features.  Then we look at the Camel distribution and explain how to follow the examples in this book.  At the end of the chapter, we present the basic concepts of Camel, necessary for understanding its architecture. <br><br>  Ready?  Then meet Camel. <br><br><h3>  Introducing Camel </h3><br>  Camel is an application integration platform designed to work productively and with pleasure.  Camel's history began in 2007, and today it is a mature open source project that is licensed under the Apache 2 license and around which there is a powerful development community. <br><br>  Camel's main goal is to simplify integration.  We hope that by reading this book, you will appreciate the capabilities of Camel and include it in your arsenal of essential tools. <br><br>  Camel is part of the Apache family of projects, getting its name thanks to the brevity and ease of remembering.  There is a version that the project is obliged by the name of the brand of cigarettes that one of its founders smoked.  Other versions can be found in the list of questions and answers on <a href="http://camel.apache.org/why-the-name-camel.html">the project website</a> . <br><br><h3>  What is Camel </h3><br>  The core of the Camel platform is the routing mechanism, more precisely, the linker of routing mechanisms.  With the help of the linker, you can define your own routing rules, decide which sources to receive messages from, and determine how to process and send these messages further.  The Camel integration language allows you to specify complex routing rules that are close to business processes.  As shown in Fig.  1.1, Camel is the link between unrelated systems. <br><br>  One of the fundamental principles of Camel is that he makes no assumptions about the data being processed.  This is an important point, because it allows you, as a developer, to integrate systems of various types without converting data into the canonical format. <br><br>  <i>Fig.</i>  <i>1.1 Camel is the link between unrelated systems.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/he/3j/ct/he3jctx1bfdpia1qwd_da3dcgrk.png"></div><br><br>  Thanks to high-level abstractions, Camel allows you to use the same API to interact with different systems using different protocols and data types.  APIs for specific protocols and data types are implemented as corresponding components.  By default, Camel supports more than 280 protocols and data types, and, thanks to an extensible modular architecture, allows you to independently implement support for the necessary protocols, both proprietary and open.  This eliminates unnecessary data conversion and makes Camel not only faster, but less voracious.  As a result, Camel is great for embedding in projects that require advanced processing capabilities.  In particular, Camel is already used for integration tasks in open source projects such as Apache ServiceMix, Karaf, and ActiveMQ. <br><br>  Now about what Camel is not.  This is not an ESB service bus, although some people call it the lightweight version of ESB because it supports routing, transformation, orchestration, monitoring, and other functions.  Camel does not have a container and a reliable messaging bus, although it can be used as such, for example, in the already mentioned Apache ServiceMix.  Therefore, we prefer to call Camel an integration platform, not an ESB solution. <br><br>  If at the mention of ESB you immediately come to mind complex monstrous systems, then we hasten to reassure: Camel with the same success can be used in very small things, like microservices or IoT (Internet of Things) gateways. <br><br>  To understand what Camel is, consider its main functions. <br><br><h3>  Why use camel </h3><br>  Camel is a practical embodiment of new ideas in the field of integration.  Next, we will look at Camel‚Äôs capabilities in detail, but for now let's list them: <br><br><ul><li>  Clearing House and Routing Mechanism </li><li>  Extensible Component Library </li><li>  Enterprise Application Integration Patterns (EIP) </li><li>  Domain-specific language (DSL) </li><li>  Payload formatted router </li><li>  Plug-in-based architecture </li><li>  Model Plain Old Java Object (POJO) </li><li>  Easy to configure </li><li>  Automatic type converters </li><li>  Lightweight core suitable for embedding in microservices </li><li>  Cloud support </li><li>  Testing Package </li><li>  Active development community </li></ul><br>  Now we will sort this list on points. <br><br><h3>  Clearing House and Routing Mechanism </h3><br>  The mediation and routing mechanism is the core of Camel.  The routing mechanism selectively moves messages according to the route configuration.  In Camel, routes are configured using integration templates and a subject language (more about them later). <br><br><h3>  Extensible Component Library </h3><br>  Camel has an extensive library of more than 280 components, allowing it to connect through a variety of transports, use different APIs and understand different data formats.  In Fig.  1.2.  you will surely find technologies that have already been used or would like to use.  Of course, in the framework of this book it is impossible to consider all the components of Camel, but we still discuss two dozen of the main ones. <br><br>  <i>Fig.</i>  <i>1.2 Ability to connect to anything: Camel supports over 280 transports, APIs, and data formats.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ur/tx/1k/urtx1kzcbd64k4t4mp8s2rvm_lu.png"></div><br><br><h3>  Enterprise Application Integration Patterns (EIP) </h3><br>  With all the variety of integration problems, many of them, as noted by Gregor Hohpe and Bobby Woolf, have similar solutions.  These two have released the book "Enterprise Integration Patterns" (translated into Russian - "Patterns of integration of corporate applications"), which should read anyone who considers himself an expert in the field <a href="http://www.enterpriseintegrationpatterns.com/">of application integration</a> .  In addition, this book will help you understand Camel concepts much faster and easier. <br><br>  Integration patterns (EIP) are useful not only because they offer proven solutions for various integration problems, but also because they simplify the description and presentation of these problems themselves by providing appropriate semantics.  Camel is largely based on EIP templates.  However, although EIP templates both describe problems and solutions, and also provide a common dictionary, this dictionary is not formalized.  Camel removes this gap by providing a language for describing integration solutions.  There is an almost one-to-one relationship between the patterns described in the book ‚ÄúEnterprise Integration Patterns‚Äù and the subject language CamelDSL. <br><br><h3>  Domain-specific language (DSL) </h3><br>  At the time Camel appeared, his main contribution to the cause of integration was the domain-oriented language (DSL).  Over time, this example was followed by other integration frameworks, and now DSL is in Java, XML and other programming languages.  DSL allows the developer to focus on the integration tasks, without being distracted by the features of the tool used (programming language).  Consider a couple of DSL examples that use different formats, but are completely equivalent in functionality: <br><br>  <i>Java DSL</i> <br><br><pre><code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> from(<span class="hljs-string"><span class="hljs-string">"file:data/inbox"</span></span>).to(<span class="hljs-string"><span class="hljs-string">"jms:queue:order"</span></span>);</code> </pre> <br>  <i>XML DSL</i> <br><br><pre> <code class="xml hljs">1 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span> 2 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">from</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"file:data/inbox"</span></span></span><span class="hljs-tag">/&gt;</span></span> 3 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">to</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">uri</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"jms:queue:order"</span></span></span><span class="hljs-tag">/&gt;</span></span> 4 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">route</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  This is real code, and it shows how easy it is to send a file from the desired folder to the JMS (Java Message Service) queue.  Since DSL is based on a popular programming language, the developer still has access to familiar and convenient tools of the IDE environment, such as auto-completion when typing or detecting compiler errors, as shown in Fig.  1.3. <br><br>  <i>Fig.</i>  <i>1.3 Camel DSL languages ‚Äã‚Äãare based on popular programming languages ‚Äã‚Äãlike Java, so you have access to convenient and familiar features of the IDE environment.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oz/ve/bb/ozvebbr0agekrmid7nzjawxp6qq.png"></div><br>  The figure shows how the auto-completion feature when typed into the Eclipse IDE offers a list of possible DSL expressions. <br><br><h3>  Payload formatted router </h3><br>  Camel can route useful data in any form, not limited to any single normalized format, for example, XML payload.  Therefore, in order to route the load, it does not need to be converted to the canonical format. <br><br><h3>  Plug-in-based architecture </h3><br>  The modular architecture of Camel allows you to load into it any components, both included in the package and those created by third-party developers, including you.  In addition, you can configure almost everything in Camel, many of its functions are pluggable and customizable: ID generation, flow control, completion sequence, stream caching, and more. <br><br><h3>  POJO model </h3><br>  Java beans (or Plain Old Java Objects, POJOs) in Camel are first-class citizens, so you can use them in integration projects almost anywhere and anytime.  In many cases, you can even extend the built-in functionality of Camel with your code. <br><br><h3>  Easy to configure </h3><br>  Configuring in Camel is minimized wherever possible.  To set endpoints directly in routes, a simple and clear URI configuration is used. <br><br>  For example, you can configure a Camel route that will start from a file endpoint and recursively scan subfolders for .txt files, just by writing the following: <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> from(<span class="hljs-string"><span class="hljs-string">"file:data/inbox?recursive=true&amp;include=.*txt$"</span></span>)...</code> </pre><br><h3>  Automatic type converters </h3><br>  Camel has a built-in type conversion mechanism with more than 350 converters.  You no longer need to configure the conversion rules, for example, to convert an array of bytes to a string.  And even if Camel does not have the necessary converter, you can always write it yourself.  And the best part is that it all works autonomously, without your participation. <br><br>  Camel components also use autoconversion of types, so they can take most types of data and convert them to the type they can use.  In the Camel community, this feature is the top favorite, and some even wonder why it is not in Java. <br><br><h3>  Lightweight core suitable for embedding in microservices </h3><br>  Kernel Camel really weighs quite a bit: the size of the library is about 4.9 MB, another 1.3 MB take runtime dependencies.  Therefore, Camel is easily embedded anywhere and deployed anywhere, including standalone applications, microservices, web applications, Spring applications, Java EE applications, OSGi, Spring Boot, WildFly, and cloud platforms such as AWS, Kubernetes or Cloud Foundry.  Camel was not originally created as a server system or an ESB solution, but as something that can be embedded in any executable things where there is Java. <br><br><h3>  Cloud support </h3><br>  Camel is not only cloud-oriented, but also offers many components for connecting to cloud services, such as: <br><br><ul><li>  Amazon DynamoDB, EC2, Kinesis, SimpleDB, SES, SNS, SQS, SWF, and S3 </li><li>  Braintree (PayPal, Apple, Android Pay, etc.) </li><li>  Dropbox </li><li>  Facebook </li><li>  Github </li><li>  Google Big Query, Calendar, Drive, Mail and Pub Sub </li><li>  HipChat </li><li>  LinkedIn </li><li>  Salesforce </li><li>  Twitter </li><li>  and many others </li></ul><br><h3>  Testing Package </h3><br>  Camel comes with a package for testing applications.  This package is actively used for testing Camel itself and has more than 18 thousand unit tests.  The package contains special components that allow, for example, to simulate real endpoints or to set the expected result so that Camel can check whether the application meets the specified requirements or not. <br><br><h3>  Active development community </h3><br>  The Camel project has an active and active community, which at the time of writing this book has been living and developing for over 10 years.  Having such a community is an important factor when choosing open source software to build your own applications.  If the project is inactive, you can hardly count on the support of the community and you are left alone with your problems.  Conversely, participants in an active project, such as Camel, and, both developers and ordinary users, are always ready to help. <br><br>  Now that we have briefly reviewed the main features of Camel, it's time to move on to practice: get its distribution and consider a few examples. <br><br><h2>  Getting started </h2><br>  In this section, we describe how to get the Camel distribution, and briefly describe its contents.  Then we will show how to perform the source code examples in this book using Apache Maven. <br><br>  Let's start with the distribution. <br><br><h3>  Download and install Camel </h3><br>  Camel is available <a href="http://camel.apache.org/download.html">on the Apache Camel project website</a> .  There you will find a list of all versions and download links for the latest release of Camel. <br><br>  In this book, we use Camel 2.20.1.  To get this version, use the corresponding link on the download page.  At the end of this page there are links to two distributions: a zip file for Windows and a tar.gz for macOS / Linux.  Download the desired file and unzip it to a local disk. <br><br>  Open the console and go to the folder where you unpacked the Camel distribution.  It will contain the following files: <br><br><pre> 1 [janstey @ ghost apache-camel-2.20.1] $ ls
 2 doc examples lib LICENSE.txt NOTICE.txt README.txt
</pre><br><br>  As you can see, the distribution has a simple and clear structure, namely: <br><br><ul><li>  doc - folder with the Camel manual in HTML format.  This is just a copy of the Camel site at the time of release.  It is useful in those moments when you do not have access to the site or not at hand of this book. </li><li>  examples - folder with 97 examples of Camel </li><li>  lib - folder with all Camel libraries.  Later we will show how to use Maven to simply load dependencies for non-core components. </li><li>  LICENSE.txt - file with the text of the license for the Camel distribution.  Since this is an Apache project, the license is an Apache License, version 2.0 </li><li>  NOTICE.txt - file with copyright information on third-party dependencies that are part of the Camel distribution </li><li>  README.txt - a file with a brief introduction to Camel and a list of links that will help beginners to get started quickly </li></ul><br>  Now we will understand how to perform the examples given in this book by Camel. <br><br><h3>  First launch camel </h3><br>  So, above we told how to get the Camel distribution, and briefly described its contents.  Among other things, there are examples with explanations and instructions, which we advise to study. <br><br>  However, in this book we will not use the distribution at all.  All the examples of source code shown here use Apache Maven, which automatically loads all the necessary Camel libraries.  Therefore, you will not need to control that they are registered in the classpath. <br><br>  All code examples from this book can be found on the <a href="https://github.com/camelinaction/camelinaction2">GitHub</a> website. <br><br>  The first example that we will consider is such a ‚Äúhello world‚Äù in the realities of integration, in other words, it is file routing.  Suppose you need to read the files in one folder (data / inbox), process them in a certain way and write the results to another folder (data / outbox).  For simplicity, we omit the processing, and then the task will be reduced to copying the source files, as shown in Fig.  1.4. <br><br>  <i>Fig.</i>  <i>1.4 Routing files from the data / inbox folder to the data / outbox folder.</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fl/sl/dq/flsldqxdzkjfaocadbbfxxydcjk.png"></div><br>  Easier, nowhere right?  This is how the implementation of this task looks like on ‚Äúpure‚Äù Java, without using Camel. <br><br>  <i>Listing 1.1 Routing files from one folder to another in "clean" Java</i> <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.File; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileInputStream; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.FileOutputStream; <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.IOException; <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.io.OutputStream; <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileCopier</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-number"><span class="hljs-number">8</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-number"><span class="hljs-number">10</span></span> File inboxDirectory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"data/inbox"</span></span>); <span class="hljs-number"><span class="hljs-number">11</span></span> File outboxDirectory = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"data/outbox"</span></span>); <span class="hljs-number"><span class="hljs-number">12</span></span> outboxDirectory.mkdir(); <span class="hljs-number"><span class="hljs-number">13</span></span> File[] files = inboxDirectory.listFiles(); <span class="hljs-number"><span class="hljs-number">14</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (File source : files) { <span class="hljs-number"><span class="hljs-number">15</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (source.isFile()) { <span class="hljs-number"><span class="hljs-number">16</span></span> File dest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File( <span class="hljs-number"><span class="hljs-number">17</span></span> outboxDirectory.getPath() <span class="hljs-number"><span class="hljs-number">18</span></span> + File.separator <span class="hljs-number"><span class="hljs-number">19</span></span> + source.getName()); <span class="hljs-number"><span class="hljs-number">20</span></span> copyFile(source, dest); <span class="hljs-number"><span class="hljs-number">21</span></span> } <span class="hljs-number"><span class="hljs-number">22</span></span> } <span class="hljs-number"><span class="hljs-number">23</span></span> } <span class="hljs-number"><span class="hljs-number">24</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">copyFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(File source, File dest)</span></span></span><span class="hljs-function"> 26 </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-number"><span class="hljs-number">27</span></span> OutputStream out = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileOutputStream(dest); <span class="hljs-number"><span class="hljs-number">28</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] buffer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) source.length()]; <span class="hljs-number"><span class="hljs-number">29</span></span> FileInputStream in = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileInputStream(source); <span class="hljs-number"><span class="hljs-number">30</span></span> in.read(buffer); <span class="hljs-number"><span class="hljs-number">31</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-number"><span class="hljs-number">32</span></span> out.write(buffer); <span class="hljs-number"><span class="hljs-number">33</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-number"><span class="hljs-number">34</span></span> out.close(); <span class="hljs-number"><span class="hljs-number">35</span></span> in.close(); <span class="hljs-number"><span class="hljs-number">36</span></span> } <span class="hljs-number"><span class="hljs-number">37</span></span> } <span class="hljs-number"><span class="hljs-number">38</span></span> }</code> </pre><br>  It would seem a very simple task, but FileCopier already has 37 lines of code.  In addition, I had to use low-level file APIs, and - importantly - I had to remember to close the resources correctly.  Now imagine that you only need to copy new files from the data / inbox folder.  Then you need to set a timer and keep track of which files have already been copied.  The difficulty grows right before our eyes. <br><br>  Fortunately, the integration tasks, like the one just discussed, have already been solved a thousand times.  Therefore, it is not necessary to reinvent the wheel and write code with your hands.  Let's see how all this functionality is implemented by means of an integration framework, such as Apache Camel. <br><br>  <i>Listing 1.2 Routing files from one folder to another on Apache Camel</i> <br><br><pre> <code class="java hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.CamelContext; <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.builder.RouteBuilder; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.apache.camel.impl.DefaultCamelContext; <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FileCopierWithCamel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String args[])</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-number"><span class="hljs-number">8</span></span> CamelContext context = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultCamelContext(); <span class="hljs-number"><span class="hljs-number">9</span></span> context.addRoutes(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RouteBuilder() { <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">configure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-number"><span class="hljs-number">11</span></span> from(<span class="hljs-string"><span class="hljs-string">"file:data/inbox?noop=true"</span></span>) <span class="hljs-number"><span class="hljs-number">12</span></span> .to(<span class="hljs-string"><span class="hljs-string">"file:data/outbox"</span></span>); <span class="hljs-number"><span class="hljs-number">13</span></span> } <span class="hljs-number"><span class="hljs-number">14</span></span> }); <span class="hljs-number"><span class="hljs-number">15</span></span> context.start(); <span class="hljs-number"><span class="hljs-number">16</span></span> Thread.sleep(<span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-number"><span class="hljs-number">17</span></span> context.stop(); <span class="hljs-number"><span class="hljs-number">18</span></span> } <span class="hljs-number"><span class="hljs-number">19</span></span> }</code> </pre><br>  Most of the code in this example is a template.  Any Camel application uses CamelContext, which subsequently starts and then stops.  We also added a sleep method to give Camel time to copy files.  The main thing to look out for in Listing 1.2 is the route. <br><br>  The routes in Camel are determined in the same order in which they are read.  For example, the route from the example above can be read as follows: accept messages from the file (from file) in the data / inbox folder with the noop parameter and send to the file (to file) in the data / outbox folder.  The noop parameter means that the source files must be left in place, otherwise Camel will transfer them.  Most people who have never come across Camel may well understand what this route is doing.  In addition, note that if we discard the template code, the whole task is reduced to two lines of Java code. <br><br>  To run this example, you need to download and install <a href="http://maven.apache.org/download.html">Apache Maven</a> .  After it is ready, open the console and go to the chapter1 / file-copy folder in the source directory of the examples in this book.  In it you will find: <br><br><ul><li>  data - in this folder there is an inbox folder with a single file message1.xml </li><li>  src - source folder of examples from this chapter </li><li>  pom.xml - a file with information for building examples, namely the Maven POM (Project Object Model) XML file </li></ul><br>  <i>NOTE</i> <br><br>  Maven 3.5.0 was used to write this book.  Other versions of Maven may not work exactly as shown here. <br><br>  The content of the POM file is shown in the listing below. <br><br>  <i>Listing 1.3 The Maven POM file required to use the Camel core library</i> <br><br><pre> <code class="xml hljs">1 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">2</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">3</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://maven.apache.org/POM/4.0.0 4 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span></span></span><span class="hljs-tag">&gt;</span></span> 5 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">modelVersion</span></span></span><span class="hljs-tag">&gt;</span></span>4.0.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">modelVersion</span></span></span><span class="hljs-tag">&gt;</span></span> 6 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent</span></span></span><span class="hljs-tag">&gt;</span></span> 7 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>com.camelinaction<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> 8 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>chapter1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> 9 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>2.0.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> 10 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">parent</span></span></span><span class="hljs-tag">&gt;</span></span> 11 12 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>chapter1-file-copy<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> 13 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>Camel in Action 2 :: Chapter 1 :: File Copy Example<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> 14 15 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span> 16 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> 17 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.apache.camel<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> 18 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>camel-core<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> 19 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> 20 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> 21 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>org.slf4j<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> 22 <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>slf4j-log4j12<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> 23 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> 24 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependencies</span></span></span><span class="hljs-tag">&gt;</span></span> 25 <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">project</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Maven is a separate big topic, and here we will touch it by the very minimum only so that you can work with examples. <br><br>  The Maven POM file in Listing 1.3 is probably one of the shortest POM files in your life, because it uses almost all of the default POM settings.  In addition to them, some settings are set in the parent (parent) POM.  Perhaps the most important part here is a dependency on the Camel library.  Using this POM, Maven does the following: <br><br><ol><li>  Creates a search path based on groupId, artifactId and version.  For the version element, the camel-version property is defined, defined in the POM referenced by the parent element, and eventually equal to 2.20.1.  The dependency type is not set, so it is assumed that this is a JAR file.  The search path thus becomes org / apache / camel / camel-core / 2.20.1 / camel-core-2.20.1.jar. </li><li>  Since Listing 1.3 does not contain any instructions on where to look for Camel dependencies, Maven searches them in its central repository <a href="http://repo1.maven.org/maven2">at</a> . </li><li>  By combining the search path and URL of the repository, Maven tries to <a href="">download the file</a> . </li><li>  The JAR file is saved to the local Maven cache, which is usually located in the home directory .m2 / repository.  In Linux / macOS, this is the ~ / .m2 / repository folder, in Windows it is C: \ Users \ [Username] \. M2 \ repository. </li><li>  When you run the application code from Listing 1.2, the Camel JAR file is added to the classpath. </li></ol><br>  To run the example from listing 1.2, go to the chapter1 / file-copy folder and run the following command: <br><br><pre> 1 mvn compile exec: java
</pre><br><br>  As a result, Maven will compile the source in the src directory and run the FileCopierWithCamel class with the camel-core JAR file in the classpath. <br><br>  <i>NOTE</i> <br><br>  All the examples in this book are designed to be connected to the Internet, since Apache Maven will actively download JAR dependencies.  The total size of the libraries downloaded from the execution of all the examples from this book will be several hundred megabytes. <br><br>  Run the Maven command from the folder1 / file-copy folder and after it is finished, go to the data / outbox folder to make sure that the file is copied.  Congratulations, you have just completed your first example.  Yes, it is very simple, but now you know how to run almost all the other examples from this book. <br><br><img src="https://habrastorage.org/webt/dw/t5/xu/dwt5xurafjdwwwnbeo-i90ifq3i.png" align="right" width="30%">  &lt;/ end of translation&gt; </div><p>Source: <a href="https://habr.com/ru/post/352188/">https://habr.com/ru/post/352188/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352178/index.html">All according to GOST. Information security when using virtualization technologies</a></li>
<li><a href="../352180/index.html">Patch from Meltdown led to a more critical vulnerability Windows 7x64 / 2008R2</a></li>
<li><a href="../352182/index.html">Validation of email addresses to protect against spam bots on the site</a></li>
<li><a href="../352184/index.html">From the installation of AWX to the launch of the first playbook - setting up centralized control Ansible</a></li>
<li><a href="../352186/index.html">Cache problems and solutions</a></li>
<li><a href="../352190/index.html">Divide and conquer: demarcation of access to the records of conversations</a></li>
<li><a href="../352192/index.html">How to become a GPU engineer in an hour</a></li>
<li><a href="../352194/index.html">How to grow from a junior tester into a good tester? Continuation</a></li>
<li><a href="../352196/index.html">Comparison of ITSM-systems</a></li>
<li><a href="../352198/index.html">Classes and factory functions in javascript. What to choose?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>