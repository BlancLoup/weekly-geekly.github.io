<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Interpreter bottlenecks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This note is intended for young programmers who have been using or interpreting programming languages ‚Äã‚Äãfor some time, but have not yet studied the wo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Interpreter bottlenecks</h1><div class="post__text post__text-html js-mediator-article">  <i>This note is intended for young programmers who have been using or interpreting programming languages ‚Äã‚Äãfor some time, but have not yet studied the working principle of the language itself.</i> <br><br>  Nowadays, due to potentially not bad salaries and office-type work, programming has become quite popular among young people.  In addition, the programming languages ‚Äã‚Äãthat are not difficult enough for initial development are in demand: JavaScript, PHP, Perl, Python, Java, C #, Basic, ... (as you can see, all of them are of the same family - interpreters).  As a result, a sufficiently large number of workers in this industry appeared who did not study programming anywhere else.  A programmer was required for the language ‚ÄúX‚Äù, bought the book ‚ÄúX in 2 weeks‚Äù and after 3 weeks - we are already writing a project on ‚ÄúX‚Äù.  And after a few thousand lines of code, or after the database has acquired the real data, the project begins to slow down mercilessly.  You can, of course, ‚Äúgo play the drums‚Äù until the iron grows to your project, but this option does not always and not everyone. <br><a name="habracut"></a><br><br>  What is usually the main problem?  Usually in the absence of understanding: what actually happens when the ‚ÄúY‚Äù command is executed.  Programming languages ‚Äã‚Äãas communication languages ‚Äã‚Äã- the same can be explained in different words.  But in the case of computers, it would be better if the explanation is as concise as possible.  ‚ÄúBetter‚Äù - in the sense of ‚Äúspeed of execution‚Äù.  Moreover, brevity should be at the level of a language that is understandable to the central processor, and not to you.  I mean that the brevity of the name of a function that you call in a particular programming language does not affect performance (there are exceptions);  performance is affected by what this function does in its depths.  And for this it is worth understanding how the computer actually works with numbers, strings, arrays, functions, and so on. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So that this note does not grow too much, I will not describe here what and how it works at a low level.  In some languages, this explanation may differ.  Detailed information can be searched on the Internet, books, or figure it out.  If you wish, I can answer your questions in the comments and collect them all in a separate note.  In the meantime, I will only explain ‚Äúwhere your legs grow from‚Äù from common omissions and what you should pay attention to. <br><br>  First, let's understand the classes of programming languages.  I would break them into 3 groups (perhaps they are broken up as well): <br><ul><li>  Assembler </li><li>  Compilers </li><li>  Interpreters </li></ul><br><br>  <b>Assembler</b> - is, by and large, the language of the CPU itself.  What the programmer writes on it, even though he writes in a human-readable syntax, remains the same at the output, only a processor-understandable syntax.  Some assembler compilers, in addition to this simple translation, also analyze your code and try to optimize it, but this does not change the essence.  If you know how to program in assembler, it means that you know all the nuances of the work of iron and, therefore, you have the opportunity to realize any task as optimally as possible. <br><br>  <b>Compilers</b> are more programmer-friendly languages: C, C ++, Pascal, ... They are much easier to write because the things like conditional transitions, loops, work with variables and functions are derived into the syntax of the language.  As a result, it is no longer necessary to write a lot of CPU commands to implement a complex cycle.  Plus, they implement various designs that the CPU (central processing unit) is not aware of at all.  But which make it much easier to structure the logic of the program (classes, objects, records, arrays, ...).  When compiling, the program is translated into a language understandable to a specific CPU.  Since the Assembler and the language understood by the CPU are essentially the same, you can always translate the compiled program into Assembler (disassembly).  Translating a compiled program into a compiled language is a much more complicated task, since some constructions of the processor language cannot always be transferred normally to the simplified syntax of compiled languages.  In addition, all names of variables and functions are lost during compilation, and it is not possible to restore them (except when the program is compiled in debug mode). <br><br>  <b>Interpreters</b> - these languages ‚Äã‚Äãrepresent the highest stage of evolution: JavaScript, PHP, Perl, Python, Java, C #, Basic ... Their peculiarity lies in the potential independence of the application execution platform. <br><br>  Programs written in assemblers can only work on the type of processors for which they are written, since they were written by the teams of these processors and others simply will not understand them. <br><br>  Programs written in compiled languages ‚Äã‚Äãwork only on those platforms for which they were compiled.  Theoretically, a program can be compiled for different platforms, but in practice, if necessary, even at the programming stage, it is necessary to take into account the peculiarities of all the platforms for which the program is supposed to be compiled. <br><br>  Programs that were written in interpreted languages ‚Äã‚Äãare executed by a certain interlayer program that reads your code in real time and translates it into a language understandable by the CPU.  As a result, the question of the portability of your application developers interpreters took over.  Now they have to make this layer for different systems so that your program works for them all.  But since all systems are quite different, it is not always possible to realize absolute independence.  If under Linux there is a function ‚ÄúZ‚Äù, and under Windows it does not exist, then you will have to either do without it, or your program will work only under Linux (for example, the functions of working with the file system). <br><br>  The main disadvantage of interpreted languages ‚Äã‚Äãis the speed of their implementation.  It is quite obvious that a program compiled into a language understandable by the CPU is processed by the CPU immediately, while a program written in an interpreted language must first be recognized and translated into a language understandable by the CPU, and then the CPU begins to execute it.  Modern interpreters have acquired a number of measures to combat this shortcoming.  In addition to a sufficiently high-quality optimizer and caching system, they translate your program into bytecode (either in real time or simulating compilation).  Now the interlayer program does not need to recognize your ‚Äúhandwritten text‚Äù every time.  It does this either only once, or does not do it at all (if the program has already been translated into byte-code).  Instead of your ‚Äúmanuscript‚Äù, it works with the bytecode of your program.  The byte code is very similar to the language of the CPU, but it is not the language of the CPU (it is more platform-independent).  It still needs to be translated into the CPU language.  Therefore, it is obvious that the rumors about Java, which is faster than C ++, are noticeably exaggerated.  And this will remain so until the processors learn to understand Java bytecode. <br><br>  Now, after a small general description of the interpreters, I would like to point out 3 topics that can be skipped when writing a small project, but which, at times, can give a significant performance boost when they are understood and used correctly. <br><br><h4>  Language features that are already compiled </h4><br><br>  Programming languages ‚Äã‚Äãare not only syntax.  It is also a set of ready-made libraries of functions for working with various data and devices.  In compiled languages, they are not much different, but in the interpreters there is a difference.  In some languages, such as Java, these functions are written in the language of the interpreter itself.  And in some, such as JavaScript or PHP, in compiled languages, that is, <i>they, at the time of program execution, are already compiled and do not require additional processing</i> .  Thus, their call will not require any additional processing, with the result that their execution will be much faster than if you write the same thing in this interpreted language.  Therefore, <b>if you have the opportunity to perform this kind of built-in function, even if it does something superfluous, but it solves your problem, try using it</b> instead of writing your complex or not so much constructions.  For example, to split a string into a set of substrings with a complex condition, it is better to use a regular expression, rather than writing your own loop with manual processing of the same string. <br><br><h4>  Difficult in structure, but easy to use, frameworks </h4><br><br>  In addition to a set of libraries of functions, some enthusiasts are also trying to transform the syntax and logic of languages, introducing some of their ideas that simplify something when working with structures and / or data (jQuery, LINQ, ORM, ...).  If the language is compiled, then it is not so scary.  But in the interpreters, blind immersion in third-party abstract functions is detrimental.  Yes, often with such converters is really more convenient, but this convenience is almost always achieved due to the speed of work.  Just look at the source code of these ‚Äúhelpers‚Äù and make sure that it is <b>sometimes much more efficient to call a couple of functions built into the language that perform specifically what you need than one universal third-party</b> that internally performs the ‚Äúton‚Äù of code before you realize what you want it and finally do it.  For example, in JavaScript, to retrieve all DIVs, you can directly call the built-in function ‚Äúdocument.getElementsByTagName (‚Äú DIV ‚Äù)‚Äù, which will immediately return what you need, or call the beautiful jQuery function ‚Äú$ (‚Äú DIV ‚Äù)‚Äù which will perform a couple of regular expressions, a few checks, a ‚Äúmanual‚Äù union of arrays and only after that will it return the required one. <br><br><h4>  Working with strings </h4><br><br>  And finally, the last thing I wanted to give your attention to is working with strings.  In interpreted languages, working with strings has become so transparent that the fact that these are one of the most resource-and-cost operations is absolutely not obvious.  This fact is usually known only to those who worked with them at least manually in the compiled languages ‚Äã‚Äã(there also have functions that facilitate this work).  The problem is that with almost any operation with strings (creating a string, concatenating strings, splitting into substrings, deleting a substring, replacing the substring), the search for free space in the memory, the necessary length, for a new string, and copying the resulting data to a new location is included .  Even such simple, at first glance, operations like searching by string, with the arrival of such complex formats as UTF-8, are not particularly fast.  Compared with work in ASCII format.  Therefore, <b>you should not abuse the lines where you can do without them</b> .  For example, associative arrays - if you can get around a numbered array, get along! <br><br><br>  It is worth noting that in a function that does almost nothing, you may not feel the difference in performance between optimized code and quick-and-dirty code with modern processors.  The difference will be more obvious in places where the ‚Äúquick fix‚Äù code is executed many times (in a loop, in a frequently called function) or where there is a lot of such code. <br><br>  Successes! </div><p>Source: <a href="https://habr.com/ru/post/102405/">https://habr.com/ru/post/102405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../102396/index.html">The unique selling proposition of SaaS services</a></li>
<li><a href="../102399/index.html">PDF price generation and automatic image linking</a></li>
<li><a href="../102400/index.html">SpiNNaker - neural computer</a></li>
<li><a href="../102401/index.html">QuickAdm - fast universal admins</a></li>
<li><a href="../102403/index.html">Intuitive testing. How to find a tricky bug?</a></li>
<li><a href="../102407/index.html">Creation of modules for PHPShopCMS Free - earnings for webmasters</a></li>
<li><a href="../102409/index.html">Rules of conduct in an emergency or an unusual situation</a></li>
<li><a href="../102410/index.html">Tale of how I received my sight</a></li>
<li><a href="../102411/index.html">Two psycho in Shanghai. Kane & Lynch 2: Dog Days: a new battle for life, death</a></li>
<li><a href="../102417/index.html">New in the world of furniture - walking table!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>