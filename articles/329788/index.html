<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>HexRaysPyTools: decompile with pleasure</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, I'm going to talk about the plugin for IDA Pro, which I wrote last summer, while still being on an internship at our company. As a re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>HexRaysPyTools: decompile with pleasure</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/a91/90a/f44/a9190af44ecc4fabb176f48e123fbb01.jpg"><br>  In this article, I'm going to talk about the plugin for IDA Pro, which I wrote last summer, while still being on <a href="https://habrahabr.ru/company/dsec/blog/311374/">an internship</a> at our company.  As a result, the plugin was introduced at ZeroNights 2016 <a href="https://2016.zeronights.ru/wp-content/uploads/2016/12/zeronights_2016_Kirillov.pptx">(Slides)</a> , and since then it has fixed several bugs and added new features.  Although on <a href="https://github.com/igogo-x86/HexRaysPyTools">GitHub</a> I tried to describe it in as much detail as possible, usually colleagues and acquaintances start using it only after a small workshop.  In addition, some details of the internal work are omitted, which would allow a better understanding and use of the plugin's features.  Therefore, I would like to try to explain with an example how to work with it, as well as talk about some of the problems and subtleties. </p><a name="habracut"></a><br><p>  HexRaysPyTools, as the name suggests, is intended to improve the performance of the <a href="https://www.hex-rays.com/products/decompiler/">Hex-Rays Decompiler</a> decompiler.  The decompiler, creating a pseudo-C code, greatly facilitates the work of the reserver.  Its main advantage, which makes the tool stand out from the rest, is the ability to transform the code, leading it to a convenient and understandable mind, unlike the assembler code, which, even with the best support, requires a certain amount of attention and concentration to understand its work.  Hex-Rays Decompiler, like IDA Pro itself, has an API that allows you to write extensions and go beyond the standard functionality.  And although the API is very wide, and in theory it allows to satisfy the most sophisticated needs of an add-on developer, it has several significant drawbacks, namely: </p><br><ul><li>  Weak documentation.  In order to find suitable functions or classes, the most effective way is to search regular expressions on files, guessing keywords. </li><li>  Arbitrary names of functions and structures - often their name does not mean anything </li><li>  Deprecated methods for which no replacement is suggested. </li><li>  The overall complexity of the work.  For example, to change the type of the argument of a function, you need to write 8 lines of code and use 3 classes.  And this is not the strangest example. </li><li> The Python API is not exactly the same as for C ++.  <code>idaapi</code> contains new methods that stumbled upon by chance </li><li>  There are no obvious things: for example, IDA Pro will fall if you do not disable Garbage Collector for objects added using <code>idaapi</code> to an abstract syntax tree (it is always built when decompiling occurs, and you can change objects or insert your own). </li></ul><br><p>  To understand all this, working examples collected on the Internet helped (something interesting was found even in the Chinese segment).  So now, if someone wants to create something of their own for the decompiler, you can also refer to the source codes of my plugin. </p><br><p>  Let us turn to the description of the plugin.  In HexRaysPyTools, two separate categories can be distinguished: this is help in transforming the default output of <a href="https://www.hex-rays.com/products/decompiler/">Hex-Rays Decompiler</a> to a convenient form and reconstruction of structures and classes. </p><br><h1 id="rabota-s-kodom">  Work with code </h1><br><p>  Initially, after starting the decompiler with the F5 key, IDA Pro produces a not very clear code, consisting mainly of standard types and variable names.  And despite the fact that sometimes it tries to guess the types, create arrays, or name these variables (which are lucky to be the arguments of standard functions), this is not very good.  In general, the task of the reviser is to bring the decompiled code into an adequate form.  Unfortunately, there are things that are impossible to do without resorting to the IDA SDK.  For example, negative references to the fields of structures, which always look ugly (sometimes turning into arrays with negative indices), as well as long conditional investments stretching from the upper left corner to the lower right.  In addition, there are not enough hot keys and options for faster code transformation.  As information is obtained during the program analysis, it is necessary to change function signatures, rename variables, and change types.  All this requires a large number of mouse manipulations and copy-inserts.  Let us turn to the description of what the plugin offers to solve these problems. </p><br><h3 id="otricatelnye-smescheniya">  Negative offsets </h3><br><p>  Very often found when reversing drivers or the Windows kernel or modules of the Linux kernel.  For example, several different structures can be located in a doubly linked list using the <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff554296">LIST_ENTRY</a> structure.  In this case, for each structure, a double-linked list can be accessed from an arbitrary field. </p><br><p>  As a result, when we look at what happens in IDA Pro, we see the following picture: </p><br><p><img src="https://habrastorage.org/web/705/ad7/231/705ad72316b04e47b4afb2723f1a5d75.PNG"></p><br><p>  This output will be whenever the CONTIAINING_RECORD (windows) and container_of (linux) macros are used in the source code of the programs.  These macros return a pointer to the beginning of the structure by its type, address, and field name.  And it is their plugin allows you to insert into the disassembler.  Here is how the example looks after its application: </p><br><p><img src="https://habrastorage.org/web/a65/329/bb6/a65329bb60c84ebb80f81c94c7b7200b.PNG"></p><br><p>  Even with negative displacements can be encountered with multiple inheritance, but this is a rather refined example, it is rarely found in practice. </p><br><p>  In order to insert a macro into a disassembler, it is necessary that the appropriate structure in this context exists in Local Types or in one of the libraries in the Types Library (there may be several of them).  We click on the nested structure with the right button and select Select Containing Structure.  Next, we determine where to look for the structure, either in Local Types or in the Types Library, and the plugin makes a list of suitable structures.  To do this, it analyzes how the specified variable is used in the code and determines the minimum and maximum limits in which the type field of this variable can be located.  Then, using this information, passes through all the structures containing the field, which have everything in order with the border.  When searching, the plugin looks at nested structures and associations at any depth. </p><br><p>  In the example above, the exe-file has characters, so the list of suitable structures turned out to be rather large: </p><br><p><img src="https://habrastorage.org/web/441/ebf/b83/441ebfb83967408386cc4aef3dc67157.PNG"></p><br><p>  In addition, there is a situation where a plugin can automatically insert a macro.  The fact is that if there is an explicit assignment of a pointer, IDA Pro guesses (sometimes incorrectly) to insert it, but does not distribute it further in the code. </p><br><p>  No plugin: </p><br><p><img src="https://habrastorage.org/web/660/157/24d/66015724dd714004a5454a8db54586de.png"></p><br><p>  With plugin: </p><br><p><img src="https://habrastorage.org/web/209/165/7e6/2091657e628e4220b4615fe760d49170.png"></p><br><h3 id="silnaya-vlozhennost">  Strong nesting </h3><br><p>  Perhaps the best way to show an artificial example.  No plugin: </p><br><p><img src="https://habrastorage.org/web/39c/60a/887/39c60a887d90458891e21b89a1903036.png"></p><br><p>  With plugin: </p><br><p><img src="https://habrastorage.org/web/779/296/8db/7792968dba57440c966598fd6eb8d2a2.png"></p><br><p>  Such a change will be made automatically if the plugin is installed.  I would like to be able to impose manually, but, alas, what the decompiler produces is very unstable in terms of saving changes to the syntax tree. </p><br><h3 id="pereimenovaniya">  Rename </h3><br><p>  The idea is to call a variable or argument no more than once, and then all the renaming was done with hot keys or two clicks. </p><br><p>  Often, IDA Pro creates duplicate variables.  It would be possible, using the standard "map to another variable" option, to get rid of them.  But this is not always convenient when debugging, it may be wrong and besides it is impossible to roll back without recreating the function again. </p><br><p>  You can transfer the name from one variable to another, while adding the symbol "_": </p><br><p>  Before: </p><br><p><img src="https://habrastorage.org/web/1f3/8d7/3c8/1f38d73c8a1e439ebd5b6835707085e5.PNG"></p><br><p>  After: </p><br><p><img src="https://habrastorage.org/web/ccb/cd3/85a/ccbcd385aca34436b8c3e5e5707ea30a.PNG"></p><br><p>  You can rename the argument of the function, forcing it to take the name of the variable (in this case, the extra underscores will be removed).  Or, conversely, to assign a variable the name of the function argument. </p><br><h3 id="recasts">  Recasts </h3><br><p>  There are many situations where there is an interaction between two certain entities with different types, and we need to transfer the type of one entity to another.  Entities are local, global variables, arguments, functions, structure fields (with reference to and without reference) and return values ‚Äã‚Äãof the function.  The plugin allows you to quickly produce it.  It is difficult to show a picture, I recommend in case you need to transfer the type of one entity to another, right-click on it and look at the options.  Surely there will appear "Recast ..." (and if it does not, then you can write to me, and I will try to add it). </p><br><h3 id="prochee">  Other </h3><br><p>  In addition, the following options are added: </p><br><ol><li>  Search structures by size and replace the number with <code>sizeof(Structure)</code> ).  Convenient for finding a structure of suitable size by the number of bytes specified by the <code>new</code> operator or the <code>malloc</code> function. </li><li>  Quickly change the function signature.  By right clicking on its declaration, you can add / remove the return value, delete the argument, reset the calling agreement to __stdcall. </li><li>  Double click on virtual methods. </li></ol><br><h1 id="vosstanovlenie-struktur">  Structure restoration </h1><br><p>  One of the most difficult and energy-intensive tasks of reverse engineering is the understanding of the work and the reconstruction of structures and classes.  HexRaysPyTools acts as an assistant in this process.  What is the problem?  By default, you can only fill in the already declared structure declaration, so you have to ‚Äúcrawl‚Äù along the code, trying to gather information about the fields, manually calculate the offsets and write down all the information somewhere (for example, in a notebook).  But, if we have class sizes in the hundreds of bytes and, in addition, have many methods and several virtual tables, everything becomes much more complicated. </p><br><p>  Consider an example of how a plugin helps in this case.  Once (only for the sake of self-education: D) I created a bot for an online toy.  In the process, I stumbled upon a protection encrypting packets that did not allow modifying the code in memory and preventing the call of the encryption function (which was strictly obfuscated) from interfering with the hook.  In order to bypass it, it was necessary to parse the class responsible for the exchange of data between the client and the server and learn, using it, call sending packets and read received, decrypted packets for several calls from the protection functions.  Then it was a difficult task, but with the plugin everything is pretty simple. </p><br><p>  Here is the method that accepts packets.  <code>this</code> and <code>v1</code> are pointers to a class object, <code>gepard_1</code> is a function replacing <code>recv</code> </p><br><p><img src="https://habrastorage.org/web/281/f0a/fb3/281f0afb395f4fe19df7ac76da29775e.PNG"></p><br><p>  If you look inside the functions <code>sub_41AF50</code> and <code>sub_41AFF0</code> , you can see quite a lot of code that accesses different fields.  And even this is only part of the functional responsible for creating and sending packets, so it may be difficult to understand the purpose of the fields.  The plugin helps to automatically analyze a large amount of code, and from the collected information to create a certain framework structure, which in the further analysis can be changed by the researcher and used to automatically create a new type.  First you need to open the Structure Builder via Edit-&gt; Plugins-&gt; HexRaysPyTools.  This window will contain the collected information, provide the ability to edit field names and resolve conflicts, as well as view virtual tables and scan virtual functions. </p><br><p>  There are 3 possible ways to collect field information: </p><br><p>  1) You can right-click on a variable and, by clicking Scan Variable, start a scan within one function.  When scanning, it will be considered how the variable is accessed and, if it falls under the field reference pattern, such information will be stored.  If another variable is assigned the value of the first (and their types do not have to be the same), it also connects to the scan (and turns off if a new value is assigned to it).  Here is the result if you apply this method to the this variable in the function above: </p><br><p><img src="https://habrastorage.org/web/6b6/19f/692/6b619f692045485e8f8fc5e136a39388.PNG"></p><br><p>  Although we ran a scan for <code>this</code> variable, information about <code>v1</code> also collected. <br>  All kinds of calls to the fields are marked yellow, and you need to choose which option is best for you, turning off all the others.  As long as there are conflicts, it will be impossible to create the final structure.  Red is the offset from which the scan is made.  It can be shifted using the Origin button in order to scan a potential substructure.  For example, you can enter the <code>sub_41AF50</code> function and, moving the pointer, collect some new information: </p><br><p><img src="https://habrastorage.org/web/7ef/821/d84/7ef821d845534d07910c4273f19e38ed.PNG"></p><br><p>  If you double-click on the Offset column of the field of interest, you can see a list of all calls to this field and quickly move to the destination in the disassembler.  Therefore, it makes sense to cover as many places as possible using the restored structure as much as possible.  More information about the fields - it's easier to figure out what's needed.  Scanning each variable can be quite tedious, because a pointer to a structure can travel through a large number of functions, so there is another way to collect information. </p><br><p>  2) By right-clicking on a variable, you can select the "Deep Scan Variable" option.  The main scanning process will be the same as that of the first method, only now, if the pointer to the structure is passed as an argument to the function, a recursive scan of this argument will be launched.  <em>Warning!</em>  <em>There is one problem here - the decompiler does not always recognize correctly the arguments of a function that it has not yet decompiled, so you have to recursively enter and decompile every function that can potentially contain a pointer to our structure as an argument.</em>  <em>This process starts automatically and occurs only once per session for each function.</em>  <em>Therefore, the first deep scan processes may take some time (on the order of a couple of minutes).</em> </p><br><p>  Moving up the challenge chain several times, you can find the place where the structure is created: </p><br><p><img src="https://habrastorage.org/web/137/cae/70b/137cae70b25b4ede8bac62724f23e856.PNG"></p><br><p>  Running a scan here, we get the following: </p><br><p><img src="https://habrastorage.org/web/2b5/b59/6e8/2b5b596e83ba45838626862212d023ee.PNG"></p><br><p>  3) It is best to start scanning where the structure first appears, in order to maximize its use in the code.  The plugin provides the ability to scan all the variables that are assigned the result returned by the constructor. </p><br><p>  If you enter the <code>sub_419890</code> function, which for the first time returns a pointer to a structure, you can see that the lone pattern is used: </p><br><p><img src="https://habrastorage.org/web/caa/336/b9b/caa336b9ba2543cb85e422c8a6c94ea1.PNG"></p><br><p>  The number of calls to this function is very large: </p><br><p><img src="https://habrastorage.org/web/340/f40/524/340f4052446a49b3af7ec9cecc1600fc.PNG"></p><br><p>  Scanning each variable would be tedious, so it is possible to start the scanner for everyone at once by clicking on the function header and selecting the "Deep Scan Returned Variables" option. </p><br><p>  Here is the result of using the example: </p><br><p><img src="https://habrastorage.org/web/737/927/c37/737927c37bf541d3b89b8b0a6391aee6.PNG"></p><br><p>  You may notice that there was information about accessing the fields 0x8 - 0x14.  There were also virtual tables - they are displayed in bold and by double-clicking on them, you can see a list of virtual functions (and at the same time scan them one at a time, and all at once). </p><br><p>  Now you can deal with the device structure.  Recall that by clicking on the offset, you can see all the calls to the fields. </p><br><p>  Here is what happened after a brief analysis: </p><br><p><img src="https://habrastorage.org/web/47f/ab1/7b5/47fab17b50a04c3aa1ac4068ba2919db.PNG"></p><br><p>  Preparing to create the structure is complete.  Now you can click "Finalize" and, having made recent changes, finish its creation: </p><br><p><img src="https://habrastorage.org/web/13d/e56/3b3/13de563b3d004d63b630f5d25367ee08.PNG"></p><br><p>  Further, everywhere where the scanner has reached, the variables that were a pointer to this structure will be applied to its newly created type.  Here is how the packet sending function will change: </p><br><p><img src="https://habrastorage.org/web/d3b/3a2/6e7/d3b3a26e727d4bed95aae3bc4946c6a2.PNG"></p><br><p>  In addition to the presented, in the Structure Builder, you can create or try to guess the substructures by selecting the required number of fields and clicking Pack or Recognize Shape, respectively.  When searching for a suitable structure, field types are taken into account - they must match exactly, with the exception of the basic types ( <code>char</code> - <code>BYTE</code> , <code>int</code> - <code>DWORD</code> - <code>int *</code> ), which are considered to be the same. </p><br><p>  For already created classes (structures with virtual tables), the plugin has the opportunity to more conveniently work with them.  On the way View-&gt; Open Subviews-&gt; Classes, you can open the following window: </p><br><p><img src="https://habrastorage.org/web/fe9/ec9/0b6/fe9ec90b6a294fc4a4eaf989a25377f4.PNG"></p><br><p>  Here you can: </p><br><ol><li>  Rename methods, as a result of which changes will be made immediately in the code and virtual tables (done to avoid desynchronization) </li><li>  Modify method declaration </li><li>  Quickly convert the first argument to this </li><li>  Move to function in disassembler window </li><li>  Filter information by regular expressions </li></ol><br><p>  And further.  I would like to remind once again that when working with classes it is very convenient to use the <a href="https://sourceforge.net/projects/classinformer/">ClassInformer</a> plugin.  If there is RTTI-information in the file, it will help to restore the class hierarchy, and the plugin will take the names of the virtual tables, which will help to get the class names close to the original. </p><br><p>  We hope that this article will help you figure out how to use the plugin.  You can find it and report bugs at <a href="https://github.com/igogo-x86/HexRaysPyTools">https://github.com/igogo-x86/HexRaysPyTools</a> .  We are also waiting for feature requests. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/329788/">https://habr.com/ru/post/329788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329778/index.html">Brief history of random numbers</a></li>
<li><a href="../329780/index.html">Chrome won</a></li>
<li><a href="../329782/index.html">Create your own Angular 2</a></li>
<li><a href="../329784/index.html">Node.js and cote: simple and convenient development of microservices</a></li>
<li><a href="../329786/index.html">WebVR: the rebirth of virtual reality</a></li>
<li><a href="../329792/index.html">SCCM Inventory</a></li>
<li><a href="../329794/index.html">Once again about storing logs in Zabbix</a></li>
<li><a href="../329796/index.html">Many pointless conversations</a></li>
<li><a href="../329798/index.html">Constructor</a></li>
<li><a href="../329804/index.html">Git: many useful and different hooks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>