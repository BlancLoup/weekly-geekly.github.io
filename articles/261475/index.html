<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Alternative to callback</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's assume that you need to make a rail application that allows you to create an order, depending on the input data of the order, create one or seve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Alternative to callback</h1><div class="post__text post__text-html js-mediator-article">  Let's assume that you need to make a rail application that allows you to create an order, depending on the input data of the order, create one or several services, reserve some resources for these services. <br><br>  During processing, the order changes its status from new to completed, while creating several services (depending on data) and they must be running and work by the end of order processing.  A simple example - you make yourself a SIM card for your cell phone.  Voice services, SMS and MMS, mobile Internet (which has its own tariffs), voice mail, caller ID, etc. are connected to this SIM card.  By the end of the processing of your contract (order), all these services must be up and running.  Then you can conclude additional.  contract and switch to other tariffs of the mobile Internet, etc.  This is just an example of logic, which I will refer to for clarity. <br><br>  The absolute majority of programmers will start making such an application on callbacks or triggers.  A new order has been created - we set a new state for it - and we hang up a callback which starts creating services, etc.  Next, I will try to explain why this is an absolute evil. <br><a name="habracut"></a><br><h4>  Callbacks are not controlled </h4><br>  While in your application there are 10-15 callbacks - you can still somehow control them.  As soon as there are more models in the application, the number of callbacks grows.  One callback changes the data, because of this, the second callback works, changes other data - the third works, and so on.  As a result, it is not easy to restore the whole chain and understand what arose and why.  I am already silent about such options as looping callbacks - the first one worked, the second one worked ... the tenth one worked and as a result of its changes the first callback re-worked.  Or, the first one worked first, then the third, then the fifth and then the second (the numbering here is conditional - just for clarity).  There is not even talk of any controlled sequence of work of callbacks.  Each by itself. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  The history of callbacks </h4><br>  You have a warrant.  It was partially processed, after which you rolled out the next update of the application - the logic has changed - the user comes to you and asks the same question - ‚Äúwhy is there such a value‚Äù.  Now you need to understand not only the current code, but also to see which version of the code was used at the time of the expected callback response - there are only more assumptions. <br><br><h4>  Logic Versions </h4><br>  Suppose you need to change the callback logic.  For example, when a condition was fulfilled, one type of service was created, now another.  But for already processed orders (those that started on the old logic and not yet fully processed) - you need to keep the old logic. <br>  Your callback is growing - you need to lay a new logic and keep the old one that works for orders that are running, for example, up to a certain number.  I had a case when business users tried to complete an order that ‚Äústood‚Äù unfinished for 7 years.  How much logic and code has changed during this time - just try to imagine. <br><br><h4>  The callbacks are awfully monitored. </h4><br>  When a business user comes to you and asks the question ‚Äúwhy does this service have such a value here‚Äù - you are faced with the first problem - you need to look at the base, logs, and so on. <br>  Even understanding exactly which callback worked and changed the data you are interested in can be a very difficult task and you can kill more than one day for it.  In fact, no matter how many times you dig in the logs - as a result, you can only assume that "this callback worked for some reason."  Even if you have logs, as the system grows, you will increasingly fall into assumptions.  Perhaps several callbacks worked and set the same value to this model.  Then absolutely bad.  The complexity of analyzing, reproducing and solving a problem grows exponentially. <br><br><h4>  Snap to model </h4><br>  My ‚Äúfavorite‚Äù sin of kolbek - they are tightly tied to the model.  Today you have a TypeA order, tomorrow it was replaced with a TypeB order - and the necessary callbacks did not fire - the order processing chain broke.  You can of course fix it - technically this is a code error, but in practice it is better to build your application in such a way that this error could not occur in principle. <br>  Next, we will set 2 order states for you - new and completed and associated callbacks.  You need to complicate the logic - add callbacks at the time of processing logic.  For example, failed, processing - and add some more callbacks to them.  The order can get failed several times during its processing and can go to processing several times - and each time callbacks will work. <br>  Then it turns out that the logic after fails is different and the status of re-processing (for example) appears and the logic becomes even greater.  The number of callbacks is growing.  At the same time, it is necessary to take into account that the order is paid or not - and these are some more callbacks attached to different parameters of the model.  While the order is not paid (paid - one order field, status - another) services cannot be started, etc.  - you start to invent new order states, almost-done-not-yet-paid, etc.  - you start to invent new and new states so that you can attach logic to them.  The combination of states (paid / processed, unpaid / processed, etc.) becomes more and more.  Callbacks are more complicated. <br><br><h4>  No isolation logic </h4><br>  I will try to explain - let's say you have a mobile Internet service.  There was a first order for which this service was launched, then there was a second order - a change in the tariff plan - the service is essentially the same, but differently, have a different Internet speed, etc.  At callbacks, you cannot isolate the logic associated with the first order from the logic associated with the second order ‚Äî everything is tied to the service model itself. <br>  Moreover, there is an accounting department - in which the business logic is connected with the payment of a warrant, there is a technical department that has to ensure the work of the Internet - it has a different business logic - and they really should be isolated.  At callbacks, everything is zavazano to the order model - and it is no longer possible to separate the processing of accounting and technical department.  The accounting department can pay for the service in several payments - several ‚Äúprocesses‚Äù - while the technical department during the same time can get rid of technical support and some service operations to ensure the same service and all this logic should not be tied to the model . <br><br>  <b>The conclusion is simple: the application logic should not be tied to the model.</b> <br><br><h4>  Alternative </h4><br>  The first thing you need to understand - if you have business logic - it means you need to tie it not to the model.  There is a flow of order processing - it means an entity is needed, to which all this is tied instead of the model.  Without being clever, let's call this entity a ‚Äúprocess‚Äù. <br><br>  All business logic is tied to the process - as an option - in the form of operations.  Those.  technically, you should be able to open the processes that changed the order ‚Äî and see when they were created, how they worked, which users participated, what changed and what was done, what operations worked (and why) ‚Äîthat is  you should have not just speculation - but an exact history of the process.  Plus - it would be desirable to be able to look at the processes that are not yet completed - what other operations can be performed as part of the process.  If something is broken in the process - you need to correct the data / code - to be able to start the process further (and not change the state of some object through the console, so that some callbacks would work and the process went further). <br><br>  Further - the user participates in your process.  If the application is on callbacks - the user is actually thrown out of logic - went to some order, changed some data - callbacks bummed and the order is further processed.  In the case of a process, you can introduce such a thing as ‚Äúuser operation‚Äù - and say that some process is waiting for certain user operations, that the following user operations were created and executed during the process.  As part of the "user" operation, the user can change the data on several models. <br><br>  Next, you need some kind of process configuration - the ability to specify which operations it contains, operation dependencies, etc. <br><br>  The process and operations should have their own data scopes - some intermediate process variables that make it possible not to load models with data needed only by processes.  As a result, the models are simpler and easier. <br><br>  While on this stop.  If the topic is interesting, then you can write a lot more.  Who <a href="https://github.com/madzhuga/rails_workflow">cares</a> - see <a href="https://github.com/madzhuga/rails_workflow">gem rails_workflow</a> and ask questions. </div><p>Source: <a href="https://habr.com/ru/post/261475/">https://habr.com/ru/post/261475/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261463/index.html">Comparing the speed of .NET providers for working with Oracle DB</a></li>
<li><a href="../261467/index.html">Rapid development on 1C-Bitrix or how I met gulp</a></li>
<li><a href="../261469/index.html">Love and mathematics. Heart of hidden reality</a></li>
<li><a href="../261471/index.html">Started Golden Site 2015</a></li>
<li><a href="../261473/index.html">We teach Raspberry Pi to accept telegrams with the help of Bot API and Python</a></li>
<li><a href="../261477/index.html">OpenCV and the illusion of circles on the water</a></li>
<li><a href="../261479/index.html">Static build dll-library with QtQuick modules</a></li>
<li><a href="../261481/index.html">Backing up physical machines with Veeam Endpoint Backup FREE</a></li>
<li><a href="../261483/index.html">Tame JMeter</a></li>
<li><a href="../261487/index.html">Big data and big questions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>