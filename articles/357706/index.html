<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell - knight's move 3. Conclusion</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the end of the second article, I tried to solve another problem related to the knight's move and calculate the number of closed routes in the recta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell - knight's move 3. Conclusion</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ee/md/sv/eemdsv3v3pa82x_dtatrkopa9y0.jpeg" alt="image"><br><br>  At the end of the <a href="https://geektimes.ru/post/294279/">second article,</a> I tried to solve another problem related to the knight's move and calculate the number of closed routes in the rectangle <i>mxn</i> , but did not progress further than the 6x6 square.  After a series of optimizations, the calculations were accelerated by six orders of magnitude, i.e.  about a million times and come close to the square of 8x8, calculating the number of cycles in a rectangle of 7x8. <br><br>  Let the 8x8 square still seem inaccessible to a rough search, but such acceleration indicates a good potential of both the language and the task as a whole.  And, in fact, I would like to share the experience of the disclosure of these potentials with the readers. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the same place, at the end of the previous article I mentioned two ideas.  The first and, perhaps, the main one is to check for the absence of dead-end branches.  At each step of construction in the remaining graph there should not be isolated and intermediate suspended vertices.  In other words, each free cell, except perhaps the current and final, must have at least two free (in terms of the knight's move) neighbors. <br><br>  This one check allows reducing the calculations by more than two orders of magnitude.  And this is despite the fact that in the list version it looks quite tricky and, like the test for connectivity, it has quadratic complexity.  And this complexity is due to the fact that for each cell, over and over again, the same list of neighbors is almost always searched. <br><br>  We proceed to the second idea - for all cells to calculate the connectivity lists ahead of time once, and then only change as needed.  You can store <i>key-value</i> pairs in different ways, even in the same lists, but the lists of search and delete operations have complexity <i>O (n)</i> .  There are more optimal data structures, for example, balanced binary trees, and in the Haskell language, such a structure has long been implemented in the <i>Data.Map</i> module.  All basic operations with this structure have a complexity of no more than <i>O (log n)</i> , and, most importantly, the search function for isolated and dangling vertices now takes an elegant form <br><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">deadlocks</span></span> = keys . filter ((&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>).length)</code> </pre> <br>  And its complexity improves to <i>O (n)</i> . <br><br>  The interface function due to the volume of preparatory actions is quite strongly transformed. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">kNCircles</span></span> mn = kNFromTo [(<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)] (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) $ prepare $ tail [(x,y) | x &lt;- [<span class="hljs-number"><span class="hljs-number">1.</span></span>.m], y &lt;- [<span class="hljs-number"><span class="hljs-number">1.</span></span>.n]] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> prepare xs = <span class="hljs-type"><span class="hljs-type">M</span></span>.fromList [(x, filter (near x) xs) | x &lt;- xs] near (x1,y1) (x2,y2) = abs ((x2-x1)*(y2-y1)) == <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  As for the main recursion, since the routes themselves are now uninteresting, we are only interested in their number, from building up chains you can proceed to a simple calculation of the number of successes.  And with the new data structure, the function takes the following form <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">kNFromTo</span></span> ks s xs | size xs == <span class="hljs-number"><span class="hljs-number">1</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> | otherwise = sum [kNFromTo (xs ! k) s (kDel k xs) | k &lt;- filter (/= s) ks, null $ deadlocks xs \\ [k,s]]</code> </pre><br>  At the entrance she has a list of possible moves, the final cell and the graph of unoccupied vertices. <br>  Well, since when deleting a vertex from a graph, it is also necessary to remove its mention in the neighbor connectivity lists, the removal function will have to be written separately <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">kDel</span></span> x xs = delete x $ foldr (adjust (delete x)) xs (xs ! x)</code> </pre><br>  It looks fancy, but the total complexity remains <i>O (log n)</i> , albeit with a sufficiently large coefficient <br><br>  By the way, I forgot to say that the connectivity check used in the last article now becomes superfluous.  If you require the absence of other pendant vertices, except the current and final, the algorithm in no other cell can finish the calculation and cannot.  Yes, this does not exclude the occurrence of isolated cycles along the way, which are not immediately eliminated.  The connectivity check in this case could be useful, but in practice such situations are rare and this time additional complexity is not interrupted by added merits. <br><br>  Further, if we analyze the process of the occurrence of pendant vertices, it can be noted that the degree of the vertex in the graph decreases only when the neighbor is removed.  Therefore, the filtration of degrees can be carried out not over the entire graph, but only according to the list of adjacent vertices. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">deadlocks</span></span> xs = filter ((&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>).length.(xs !))</code> </pre> <br>  And thus, the complexity of the test is improved to <i>O (log n)</i> . <br><br>  All weak spots left, you can only slightly twist what is.  More precisely, theoretically, one could still accelerate a couple of times, moving to arrays.  Actually arrays for rectangles are generally the most obvious data structure.  And the search for an element requires O (1) time, and this is the most requested operation.  But in Haskell, to preserve cleanliness, when elements are changed, a new copy of the array is created, and this is O (n).  As a result, instead of acceleration, it is one and a half times slower. <br><br>  But!  So far, we have been digging the problem deep into, but you can go and, so to speak, "in breadth".  All calculations in the Haskell language are performed single-threaded by default, on a single core.  And there are several cores, even if at times virtual ones.  And since the struggle for productivity has gone, I would like to load them all, this will allow us to speed up the calculations by an order of magnitude (plus or minus). <br><br>  While searching for material on parallelization of computations, I came across an <a href="http://eax.me/haskell-parallel/">interesting article</a> , which says that pure Haskell computations are not easy to parallelize, but very simple.  And for this we have almost everything.  It is enough to load the <i>Control.Parallel.Strategies</i> module and add the magic line <i>`using` parList rdeepseq</i> in the recursion after the list constructor. <br><br>  Below I have a listing of the final version.  The program must be compiled with the <i>-threaded</i> key and, when running, specify the <i>+ RTS -N</i> keys in the parameters other than the size of the rectangle, for example <i>knc 7 6 + RTS -N</i> . <br><br><div class="spoiler">  <b class="spoiler_title">knc.hs</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.List(<span class="hljs-title"><span class="hljs-title">delete</span></span>, (\\)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Map.Lazy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Parallel.Strategies <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Environment type Cell = (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>) type Pool = M.Map Cell [Cell] kDel :: Cell -&gt; Pool -&gt; Pool kDel x xs = M.delete x $ foldr (<span class="hljs-type"><span class="hljs-type">M</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> (<span class="hljs-title"><span class="hljs-title">delete</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>)) xs (<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.! <span class="hljs-title"><span class="hljs-title">x</span></span>) deadlocks :: Pool -&gt; [Cell] -&gt; [Cell] deadlocks xs = filter ((&lt;2).length.(<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.!)) kNFromTo :: [Cell] -&gt; Cell -&gt; Pool -&gt; Int kNFromTo ks s xs | M.size xs == 1 = 1 | otherwise = sum ( [<span class="hljs-title"><span class="hljs-title">kNFromTo</span></span> (<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.! <span class="hljs-title"><span class="hljs-title">k</span></span>) s (<span class="hljs-title"><span class="hljs-title">kDel</span></span> <span class="hljs-title"><span class="hljs-title">k</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | k &lt;- ks, k /= s, null $ deadlocks xs ks \\ [k,s]] `using` parList rdeepseq ) kNCircles :: Int -&gt; Int -&gt; Int kNCircles mn = kNFromTo [(2,3)] (3,2) $ prepare $ tail [(<span class="hljs-title"><span class="hljs-title">x</span></span>,<span class="hljs-title"><span class="hljs-title">y</span></span>) | x &lt;- [1..m], y &lt;- [1..n]] where prepare xs = M.fromList [(<span class="hljs-title"><span class="hljs-title">x</span></span>, <span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">near</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) xs) | x &lt;- xs] near (<span class="hljs-title"><span class="hljs-title">x1</span></span>,<span class="hljs-title"><span class="hljs-title">y1</span></span>) (<span class="hljs-title"><span class="hljs-title">x2</span></span>,<span class="hljs-title"><span class="hljs-title">y2</span></span>) = abs ((<span class="hljs-title"><span class="hljs-title">x2</span></span>-<span class="hljs-title"><span class="hljs-title">x1</span></span>)*(<span class="hljs-title"><span class="hljs-title">y2</span></span>-<span class="hljs-title"><span class="hljs-title">y1</span></span>)) == 2 main = do [m,n] &lt;- getArgs print $ kNCircles (<span class="hljs-title"><span class="hljs-title">read</span></span> <span class="hljs-title"><span class="hljs-title">m</span></span>) (<span class="hljs-title"><span class="hljs-title">read</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>)</code> </pre><br></div></div><br>  The simplicity of the implementation of concurrency and its result are, of course, impressive.  Theoretically, the program is able to parallelize on the number of threads equal to the number of branches, i.e.  total number of closed routes.  Unfortunately, there are no such number of cores, but the available 8 (tried and 24) are loaded at 100% with multiple acceleration.  And this final acceleration allowed for a week of calculations to split the rectangle 7x8, having found 34,524,432,316 cycles in it.  This turned out to be even more than expected, and now the estimate from Wikipedia for the 8x8 square seems quite real. <br><br>  Summing up, I would like to say that the task of the knight's move turned out to be unexpectedly versatile and served as a good practice in learning the language.  Well, along the way, it turned out to create several new numerical sequences corresponding to the number of closed undirected routes by running the knight in the rectangles: <br><br>  <b>3x2n:</b> <pre> <code class="hljs">0, 0, 0, 0, 16, 176, 1536, 15424, 147728, 1448416, 14060048, 136947616, 1332257856, 12965578752, ‚Ä¶</code> </pre> <br>  <b>5x2n:</b> <pre> <code class="hljs">0, 0, 8, 44202, 13311268, 4557702762, ‚Ä¶</code> </pre> <br>  <b>6xn:</b> <pre> <code class="hljs">0, 0, 0, 0, 8, 9862, 1067638, 55488142, 3374967940, 239187240144, ‚Ä¶</code> </pre> <br>  <b>7x2n:</b> <pre> <code class="hljs">0, 0, 1067638, 34524432316, ‚Ä¶</code> </pre> <br>  And although I wrote the word ‚Äúconclusion‚Äù in the title, it‚Äôs too early to put a full stop in the task itself. <br><br><div class="spoiler">  <b class="spoiler_title">PS The task did not immediately let go ...</b> <div class="spoiler_text">  ... periodically came ideas for further optimization of calculations.  Of course, not everything worked, but fine tuning was able to accelerate three times more.  Not very much, busting an 8x8 square on one machine now requires three years of work, but on a farm of two dozen knots, the result was achieved in a little over two months.  And this result completely coincided with Wikipedia, the 8x8 square contains <i>13,267,364,410,532</i> closed routes.  The sensation did not happen, was five years late, but now, I hope, I will let it go) <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.List (<span class="hljs-title"><span class="hljs-title">delete</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-keyword"><span class="hljs-keyword">qualified</span></span> Data.Map.Lazy <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> M <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Parallel.Strategies <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> System.Environment (<span class="hljs-title"><span class="hljs-title">getArgs</span></span>) type Cell = Int type Pool = M.Map Cell [Cell] kDel :: Cell -&gt; Pool -&gt; Pool kDel x xs = M.delete x $ foldr (<span class="hljs-type"><span class="hljs-type">M</span></span>.<span class="hljs-title"><span class="hljs-title">adjust</span></span> (<span class="hljs-title"><span class="hljs-title">delete</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>)) xs (<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.! <span class="hljs-title"><span class="hljs-title">x</span></span>) kNC :: [Cell] -&gt; Pool -&gt; Integer kNC ks xs | M.size xs == 4 = 1 | otherwise = let ds = filter (<span class="hljs-title"><span class="hljs-title">null</span></span>.<span class="hljs-title"><span class="hljs-title">tail</span></span>.(<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.!)) ks in if null ds then sum ( [ <span class="hljs-title"><span class="hljs-title">kNC</span></span> (<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.! <span class="hljs-title"><span class="hljs-title">k</span></span>) (<span class="hljs-title"><span class="hljs-title">kDel</span></span> <span class="hljs-title"><span class="hljs-title">k</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) | k &lt;- ks, k /= 1 ] `using` parList rseq ) else let k = head ds in if null (<span class="hljs-title"><span class="hljs-title">tail</span></span> <span class="hljs-title"><span class="hljs-title">ds</span></span>) &amp;&amp; k /= 1 then kNC (<span class="hljs-title"><span class="hljs-title">xs</span></span> <span class="hljs-type"><span class="hljs-type">M</span></span>.! <span class="hljs-title"><span class="hljs-title">k</span></span>) (<span class="hljs-title"><span class="hljs-title">kDel</span></span> <span class="hljs-title"><span class="hljs-title">k</span></span> <span class="hljs-title"><span class="hljs-title">xs</span></span>) else 0 kNCircles :: Int -&gt; Int -&gt; Integer kNCircles mn = kNC [m] $ prepare $ tail [(<span class="hljs-title"><span class="hljs-title">x</span></span>,<span class="hljs-title"><span class="hljs-title">y</span></span>) | x &lt;- [1..m], y &lt;- [1..n]] where prepare xs = M.adjust (++[1]) 1 $ M.fromList [(<span class="hljs-title"><span class="hljs-title">enc</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>, <span class="hljs-title"><span class="hljs-title">enc</span></span> &lt;$&gt; <span class="hljs-title"><span class="hljs-title">filter</span></span> (<span class="hljs-title"><span class="hljs-title">near</span></span> <span class="hljs-title"><span class="hljs-title">x</span></span>) xs) | x &lt;- xs] near (<span class="hljs-title"><span class="hljs-title">x1</span></span>,<span class="hljs-title"><span class="hljs-title">y1</span></span>) (<span class="hljs-title"><span class="hljs-title">x2</span></span>,<span class="hljs-title"><span class="hljs-title">y2</span></span>) = abs ((<span class="hljs-title"><span class="hljs-title">x2</span></span> - <span class="hljs-title"><span class="hljs-title">x1</span></span>) * (<span class="hljs-title"><span class="hljs-title">y2</span></span> - <span class="hljs-title"><span class="hljs-title">y1</span></span>)) == 2 enc (<span class="hljs-title"><span class="hljs-title">x</span></span>,<span class="hljs-title"><span class="hljs-title">y</span></span>) = (<span class="hljs-title"><span class="hljs-title">y</span></span> - 2) * m + x - 2 main = do [m,n] &lt;- getArgs print $ kNCircles (<span class="hljs-title"><span class="hljs-title">read</span></span> <span class="hljs-title"><span class="hljs-title">m</span></span>) (<span class="hljs-title"><span class="hljs-title">read</span></span> <span class="hljs-title"><span class="hljs-title">n</span></span>)</code> </pre><br></div></div><br><br>  ‚Üí <a href="https://geektimes.ru/post/293315/">Part One</a> <br>  ‚Üí <a href="https://geektimes.ru/post/294279/">Part Two</a> </div><p>Source: <a href="https://habr.com/ru/post/357706/">https://habr.com/ru/post/357706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../357696/index.html">Parsing the site using T-SQL</a></li>
<li><a href="../357698/index.html">Documentation generator using built-in 1C: Enterprise 8.3.10 language</a></li>
<li><a href="../357700/index.html">External scripts with access to your credit cards and personal account</a></li>
<li><a href="../357702/index.html">Haskel - knight's move II</a></li>
<li><a href="../357704/index.html">How not to work with time zones or Aeroflot-Fail</a></li>
<li><a href="../357710/index.html">The fate of the open source project after the death of the programmer</a></li>
<li><a href="../357712/index.html">Detective story with CMake 3.10 and Android Studio</a></li>
<li><a href="../357714/index.html">Semaphores, races, critical sections and Scratch. Plants vs. Zombies</a></li>
<li><a href="../357716/index.html">Delphi: the fastest DataSet (TJvMemoryData, TMemTableEh, TdxMemData, TkbmMemTable)</a></li>
<li><a href="../357718/index.html">Implementing FizzBuzz on FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>