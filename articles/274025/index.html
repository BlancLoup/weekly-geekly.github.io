<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagger 2 and the structure of the application for Android</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day! For more than a year our team has been developing the MyOffice client for the Android platform (we are developing the MyOffice application f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagger 2 and the structure of the application for Android</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/ba8/635/2ea/ba86352eabcf49968ca785033ab4f302.jpg"><br>  Good day!  For more than a year our team has been developing the MyOffice client for the Android platform (we are developing the MyOffice application for all popular platforms). <br><br>  Today we want to talk about the technologies that we use in the development of our mail client.  Namely, about the mechanisms of Dependency Injection in the form of the Dagger 2 library. In this article we describe the main parts of the library and describe how to use them in the Android project. <br><a name="habracut"></a><br><h1>  Why Dagger 2 </h1><br>  Before we started using Dagger 2, we didn‚Äôt use the Dependency Injection (DI) pattern.  This is similar to how to add too much cereal to porridge: our code was too connected and this prevented free testing and editing the code. <br><br>  In the same period, Google announced the library Dagger 2 - it was the new version.  We compared the available analogues and for the mail client MyOffice stopped on it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The Dagger 2 library has several advantages over other Dependency Injection libraries.  Its principal advantage is work on the principle of code generation, without reflection.  From this it follows that any errors related to the construction of a dependency graph will be found even at the time of compiling the project. <br><br>  By implementing DI in our project, we were able to beautifully get rid of the strong connectivity between the various modules of our application.  We were also able to remove most of the singletones, the use of which was unjustified.  Already, we see how the efficiency of writing and editing code has improved.  In the future, we will have the opportunity to simplify the task of covering the project Unit and UI tests, which in turn will lead to an increase in the stability of the application. <br><br>  In this article, we want to provide a full overview of Dagger 2. <br><br>  We will look at the main parts of Dagger 2: <br><ul><li>  dependency query options; </li><li>  modules that provide objects for implementation; </li><li>  components that associate requests with objects for implementation; </li></ul><br>  and tell you how to use additional parts Dagger 2: <br><ul><li>  delayed and asynchronous dependency initialization. </li></ul><br><h1>  Types of @ Inject </h1><br>  There are several ways to query dependencies: <br>  1) Implementation in the class constructor.  The bonus of this option is the implicit availability of using this dependency for implementation (ManagerA is not necessary to be written in the module).  If the constructor has parameters, it is necessary that they are in the dependency graph and can be implemented. <br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">//   @Scope  public class ManagerA{ @Inject public ManagerA(Context context){ /* */} }</span></span></code> </pre> <br><br>  2) Implementation through the method.  The method will be executed after calling the constructor. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SomeDepends depends)</span></span></span></span>{ depends.register(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><br>  3) Introduction to the class field.  Fields should not be private or final. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> ManagerB managerB;</code> </pre> <br><br>  4) Calling the getter object we need.  This getter is also used to link multiple dependency graphs. <br><pre> <code class="java hljs">managerA = component.getManagerA();</code> </pre> <br><br><h1>  @ Module </h1><br>  A module is a factory of objects that resolves our dependencies.  It should be marked with the @ Module annotation, and the methods generating dependencies should be @ Provides.  And if it is necessary to mark the scope, then we mark the module with one of the @ Scope annotations. <br><br>  Annotation @ Module may contain other modules. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span>(includes={SomeModule1.class, SomeModule2.class})</code> </pre> <br><br>  Thus, the dependencies contained in them will be available in the module that references them. <br><br>  A module may contain a constructor with a parameter if it needs data from outside to resolve dependencies.  The presence of the designer makes an important difference in the creation of the component, which will be discussed <a href="https://habr.com/ru/company/ncloudtech/blog/274025/">below</a> . <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span>{ Application app; AppModule(App app){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.app = app; } <span class="hljs-meta"><span class="hljs-meta">@PerApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-function">Context </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideContext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> app;} }</code> </pre> <br><br>  Cascading dependencies may also occur: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-function">RestAdapter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRestAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RestAdapter();} <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-function">GitHubApi </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">provideRetrofitAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RestAdapter adapter)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> adapter.create(GitHubApi.class); }</code> </pre> <br><br><h1>  @ Component </h1><br>  The component is the link between the modules and dependency claimants.  You can give a dependency through a component method (to which an object requesting dependencies will be passed) or via a getter (which returns the dependency).  In one component there can be both methods and getters.  The names of the methods or getters are not important. <br><br>  In both cases, we first create the interface and mark it with the annotation @ Component or @ Subcomponent.  Further we specify how dependencies will be resolved.  You need to add a list of modules that will generate dependencies. <br><br>  In the case of implementation through the method, the list of necessary dependencies is taken from the class itself and its base classes: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> ManagerA managerA; }</code> </pre> <br><br>  A component that contains both a method and a getter will look like this: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules={AppModule.class}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">injectInto</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(App holder)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ManagerA </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getManagerA</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><a name="component_create"></a><br>  Next you need to build a project.  Classes of the Dagger type will be generated. Name of your Component that is inherited from your component.  To create an instance of a component, use the builder.  Depending on whether the module has a constructor with parameters or not, we can act differently. <br><br>  If there is a parameterized module constructor, then you need to set all such modules yourself: <br><br><pre> <code class="java hljs">AppModule <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); DaggerAppComponent.builder().appModule(<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>).build(); <span class="hljs-comment"><span class="hljs-comment">//  public SecondActComponent build() { if (appModule == null) { throw new IllegalStateException("appModule must be set"); } return new DaggerAppComponent (this); }</span></span></code> </pre> <br><br>  If not, then in addition to the builder, the create () method will be generated and the build () method modified: <br><pre> <code class="java hljs">DaggerAppComponent.create(); <span class="hljs-comment"><span class="hljs-comment">//  public static AppComponent create() { return builder().build(); } //  public AppComponent build() { if (appModule == null) { this.appModule = new appModule(); } return new DaggerAppComponent (this); } class App{ @Inject ManagerA managerA; AppComponent component @Override public void onCreate(){ //‚Ä¶   component.inject(this); // managerA= component.getmanagerA(); super.onCreate() } }</span></span></code> </pre> <br><br><h1>  @ Scope </h1><br>  Consider Android and scoop application.  The @ Scope annotation and its heirs mark methods in modules that generate objects for implementation.  If the Produce method is marked with a scop, then any component using this module must be marked with the same scop. <br><br>  Different managers have different scopes.  For example, DataBaseHelper should be one for the entire application.  For this usually used singleton.  In Dagger, there is such a @ Singletone scooter with which to mark the objects needed in one instance for the entire application.  But we decided to use our @ PerApplication for the full analogy of the names with the activation and fragment scopes. <br><br>  The name of the scopa does not matter - the level of nesting of components and their scopes is important. <br><br><h4>  Application level </h4><br>  Annotations defining scopes are declared as follows: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Scope</span></span> <span class="hljs-meta"><span class="hljs-meta">@Retention</span></span>(RUNTIME) <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> PerApplication;</code> </pre> <br><br>  It is used like this: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppModule</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... @Provides @PerApplication DbHelper provideDbHelper(Context context){ return new DbHelper(context); } @Provides @PerApplication Context provideContext(){ return app; } }</span></span></code> </pre> <br><br>  Within the framework of one module and those that are specified in its includes, the same scop should be used, otherwise at compile time you will receive an error of constructing a dependency graph. <br><br>  Now we need to mark the components using this module: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PerApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules={AppModule.class}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(App)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Application</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> DbHelper dbHelper; Appcomponent comp; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> onCreate(){ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(); comp = DaggerAppComponent.builder() .appModule(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) .build(); } }</code> </pre> <br><br>  It is worth paying attention here that DI is convenient to use for tests, and we would like to be able to replace db with its imitation.  For this, it is advisable to bring DbHelper into a separate module: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DBModule</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@PerApp</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-function">DbHelper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbhelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DbHelper(context);} }</code> </pre> <br><br>  As you can see, this module does not contain context and is not able to resolve it on its own.  ontext is taken from the module that references it: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span>(Includes={DbModule.class})  : &lt;source lang=<span class="hljs-string"><span class="hljs-string">"Java"</span></span>&gt;comp = DaggerAppComponent.builder() .appModule(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AppModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) .dbModule(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockDbModule()) .build();</code> </pre> <br><br><h4>  Activity Level </h4><br>  There can be several Activity Objects in the application, and their components must be associated with the Application component.  Consider the parameters of annotations @ Component and @ Subcomponent and their participation in the construction of a dependency graph. <br><br>  Suppose we have an EventBus manager for communication between the Activity and the snippet.  Its scope is one instance of the manager for the Activity and fragments that are in the Activity. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Module</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActModule</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@PerActivity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Provides</span></span> <span class="hljs-function"><span class="hljs-function">provide </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bus();} <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActComponent</span></span></span></span>{ inject(MainActivity activity); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> DbHelper dbHelper; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Bus bus; }</code> </pre> <br><br>  But during compilation, we are immediately told that ActComponent cannot inject the DbHelper dependency.  Magic, of course, did not happen.  We have two different unbound dependency graphs.  And the second graph does not know where to get DbHelper. <br><br>  We have two options: either link the components through the interface, which will provide us with all the necessary dependencies, or, using the first component, create the second, then the graph will turn one. <br><br>  The @Component annotation has a dependencies parameter that points to a list of component interfaces that provides the necessary dependencies. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules={ActModule.class}, dependencies={AppComponent.class})</code> </pre> <br><br>  In this case, add dependencies to AppComponent. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PerApplication</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules={AppModule.class}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">appComponent</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(App)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">DbHelper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MainActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> DbHelper dbHelper; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Bus bus; ActComponent component; onCreate(){ AppComp appcomp = ((App)getApp).getAppComponent(); ActMod actModule = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActModule(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); component= DaggerActComponent.build .actmodule(actModule) .appComponent(appComp) .build(); component.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);} }</code> </pre> <br><br>  For the second method, you need to mark our internal component with the @ Subcomponent annotation.  In addition to the list of modules, it has no other parameters. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Subcomponent</span></span>(modules={ActModule.class}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActComponent</span></span></span></span>{ inject(MainActivity activity);}</code> </pre> <br><br>  And in AppComponent we add the method returning ActComponent.  There is a general rule that if a Subcomponent has a module with a parameterized constructor, it must be passed to our method.  Otherwise, an error will occur when the component is created. <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@PerApp</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules={AppModule.class}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(App)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">ActComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plusActModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ActModule </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; } <span class="hljs-comment"><span class="hljs-comment">// activity onCreate(){ AppComp appcomp = ((App)getApp).getAppComponent(); ActMod actModule = new ActModule(this); actCom = appcomponent.plusActModule(actModule); actCom.inject(this); }</span></span></code> </pre> <br><br>  The disadvantage of the SubComponent option is that if an ActComponent or ActModule contains several other modules, you will need to increase the number of parameters of the Plus method in order to be able to transfer the modified module: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">ActComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plusActModule</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ActModule </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span></span><span class="hljs-function"><span class="hljs-params">, BusModule busModule</span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/* ..*/</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>;</code> </pre> <br><br>  Total: the variant with the component and dependencies looks more flexible, but it will be necessary to describe all the necessary dependencies in the interface. <br><br><h4>  Fragment level </h4><br>  Introducing dependencies into fragments is more interesting, since a fragment can be used in several Activities.  For example, an application with a list of objects and their detailed description when two Activities are used on the phone and one Activity with two fragments on the tablet. <br><br>  For our email client, we decided to use our components for each fragment, even if we need to implement only one dependency.  This will facilitate our work if it is necessary to update the list of dependencies in the fragment.  There are also two options for creating a component: <br><br>  Use @ Component and its dependencies parameter <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActComponent</span></span></span></span>{ <span class="hljs-function"><span class="hljs-function">Bus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">DbHelper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbhelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules={ManagerAModule.class}, dependencies={FirstActComponent.class}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstFragmentComponent</span></span></span></span>{ inject(FirstFragment fragment); }</code> </pre> <br><br>  We immediately see the problem: our component depends on the specific component of the Activity.  A suitable solution is when an interface is created for each component of the fragment that describes the dependencies necessary for it: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules={ManagerAModule.class}, dependencies={FirstFrComponent.HasFirstFrDepends.class}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstFragmentComponent</span></span></span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FirstFragment fragment)</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasFirstFrDepends</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Bus </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bus</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">DbHelper </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dbHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } } <span class="hljs-meta"><span class="hljs-meta">@PerActivity</span></span> <span class="hljs-meta"><span class="hljs-meta">@Component</span></span>(modules = {BusModule.class}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstActComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstFrComponent</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasFirstFrDepends</span></span></span><span class="hljs-class"> </span></span>{ inject(FirstActivity activity) }</code> </pre> <br><br>  We now turn to the application.  We need to pull the component out of the Activity regardless of the specific Activity.  For this we use: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasComponent</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class">&gt;</span></span>{ <span class="hljs-function"><span class="hljs-function">Component </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br><br>  Total we inherit our Activity from it: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HasComponent</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstActComponent</span></span></span><span class="hljs-class">&gt;</span></span>{ FirstActComponent component; <span class="hljs-function"><span class="hljs-function">FirstActComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> component; } }</code> </pre> <br><br>  And now we can use this interface instead of a specific Activity: <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstFragmentextends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fragment</span></span></span></span>{ FirstFrComponent component; onActivityCreated(){ HasComponent&lt;FirstFrComponent.HasFirstFrDepends&gt; has = (HasComponent&lt;FirstFrComponent.HasFirstFrDepends&gt;) activity; FirstFrComponent.HasFirstFrDepends depends = has.getComponent(); component = DaggerFirstFrComponent.builder() .hasFirstFrDepends(actComponent) .build(); component.inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } }</code> </pre> <br><br>  2) Use the @ Subcomponent and plus method to create it: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Subcomponent</span></span>(modules = {ManagerBModule.class}) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SecondFrComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SecondFragment fragment)</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlusComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">SecondFrComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">plusSecondFrComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ManagerBModule </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">module</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; } }</code> </pre> <br><br>  To avoid duplication of code, we put the most common dependencies and common code into the base Activity and fragment: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppCompatActivity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> Bus bus; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ initDiComponent(); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initDiComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> AppComponent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getAppComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((App) getApplication()).getComponent(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseFragment</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fragment</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Bus bus; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onActivityCreated</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onActivityCreated(savedInstanceState); initDiComponent(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initDiComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> &lt;T&gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getActComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Class&lt;T&gt; clazz)</span></span></span></span>{ Activity activity = getActivity(); HasComponent&lt;T&gt; has = (HasComponent&lt;T&gt;) activity; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> has.getComponent(); } }</code> </pre> <br><br>  Now the initialization of the component in the fragment looks like this: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initDiComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FirstFrComponent.HasFirstFrDepends depends = getActComponent(FirstFrComponent.HasFirstFrDepends.class); DaggerFirstFrComponent.builder() .hasFirstFrDepends(depends) .build() .inject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); }</code> </pre> <br><br><h1>  Lazy ‚ÄπT‚Ä∫ and Provider ‚ÄπT‚Ä∫ </h1><br>  Suppose we have a manager that is initialized for a long time.  It would not be desirable, that at an application launch all such dependences at once occupied the main flow.  It is necessary to postpone the introduction of these dependencies until they are used.  To do this, Dagger 2 has Lazy and Provider interfaces that implement deferred dependency initialization. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Lazy&lt;ManagerA&gt; managerA; <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> Provider&lt;ManagerA&gt; managerA;</code> </pre> <br><br>  If ManagerA has a certain scop, their behavior is identical, but if there is no scop, Lazy caches the dependency after initialization, and the Provider generates a new one each time. <br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ManagerA</span></span></span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Inject</span></span> ManagerA(){ Log.i(<span class="hljs-string"><span class="hljs-string">"GTAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"managerA init"</span></span>); } } Log.i(<span class="hljs-string"><span class="hljs-string">"GTAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"managerA hashcode: "</span></span> + managerA.get().hashCode()); Log.i(<span class="hljs-string"><span class="hljs-string">"GTAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"managerA hashcode: "</span></span> + managerA.get().hashCode()); Log.i(<span class="hljs-string"><span class="hljs-string">"GTAG"</span></span>, <span class="hljs-string"><span class="hljs-string">"managerA hashcode: "</span></span> + managerA.get().hashCode()); Lazy-: managerA init mAct managerA hashcode: <span class="hljs-number"><span class="hljs-number">59563176</span></span> mAct managerA hashcode: <span class="hljs-number"><span class="hljs-number">59563176</span></span> mAct managerA hashcode: <span class="hljs-number"><span class="hljs-number">59563176</span></span> Provider-: managerA init managerA hashcode: <span class="hljs-number"><span class="hljs-number">162499239</span></span> managerA init managerA hashcode: <span class="hljs-number"><span class="hljs-number">2562900</span></span> managerA init managerA hashcode: <span class="hljs-number"><span class="hljs-number">32664317</span></span></code> </pre> <br><br><h1>  Producer </h1><br>  Also, asynchronous dependency initialization is being developed.  In order to look at them, you need to add: <br>  compile 'com.google.dagger: dagger-producers: 2.0-beta' <br><br>  And a small example: <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@ProducerModule</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncModule</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Produces</span></span> <span class="hljs-function"><span class="hljs-function">ListenableFuture&lt;HugeManager&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">produceHugeManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Futures.immediateFuture(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HugeManager()); } } <span class="hljs-meta"><span class="hljs-meta">@ProductionComponent</span></span>(modules = AsyncModule.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncComponent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">ListenableFuture&lt;HugeManager&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hugeManager</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initDiComponent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ AsyncComponent component = DaggerAsyncComponent .builder() .asyncModule(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AsyncModule()) .executor(Executors.newSingleThreadExecutor()) .build(); ListenableFuture&lt;HugeManager&gt; hugeManagerListenableFuture = component.hugeManager(); }</code> </pre> <br><br>  We receive ListenableFuture with which we can already work, for example, to turn in Rx Observable.  Done! <br><br>  Below are links to the project with examples and useful presentations: <br><br>  <a href="https://github.com/georgeci/DaggerTest">GitHub example</a> <br>  <a href="https://google.github.io/dagger/">Official documentation</a> <br>  <a href="https://speakerdeck.com/jakewharton/dependency-injection-with-dagger-2-devoxx-2014">Jake Wharton Presentation</a> <br>  <a href="https://events.yandex.ru/lib/talks/3109/">Good presentation in Russian</a> <br><br>  In the following articles we are ready to talk about our mobile developments and technologies used.  Thank you for your attention and Happy New Year! </div><p>Source: <a href="https://habr.com/ru/post/274025/">https://habr.com/ru/post/274025/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274015/index.html">FlexPod Express: UCS-Managed Configuration</a></li>
<li><a href="../274017/index.html">Comparison of sorting algorithms</a></li>
<li><a href="../274019/index.html">Soviet school: address programming language</a></li>
<li><a href="../274021/index.html">Trading and "iron": What are stock exchange data centers</a></li>
<li><a href="../274023/index.html">Select PHP version for a specific CMS and do not cry</a></li>
<li><a href="../274027/index.html">Recurrent neural network in 10 lines of code appreciated the feedback from viewers of the new episode of ‚ÄúStar Wars‚Äù</a></li>
<li><a href="../274029/index.html">Free hosting control panels. Goddess vesta</a></li>
<li><a href="../274033/index.html">A little bit about working with containers</a></li>
<li><a href="../274035/index.html">SVG highs and lows</a></li>
<li><a href="../274037/index.html">How to kill the smartphone Sony Xperia C2305 using a router D-Link DIR-300</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>