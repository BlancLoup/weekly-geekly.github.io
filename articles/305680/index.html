<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the SRR mechanism in Qt-designed QNX applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The Qt framework is one of the most popular and used in the development of cross-platform desktop and mobile applications. This popularity could soone...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the SRR mechanism in Qt-designed QNX applications</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/files/682/504/ce7/682504ce727b402685cddd5020a78a07.jpg" align="left">  The Qt framework is one of the most popular and used in the development of cross-platform desktop and mobile applications.  This popularity could sooner or later not lead to the use of Qt in systems of special and responsible purposes.  For a long time there is the possibility of developing on Qt for <a href="https://habrahabr.ru/post/124656/">QNX Neutrino</a> .  The Qt library supports the QNX platform, and the Qt Creator development environment provides interoperability with QNX systems.  However, QNX, as a system including for embedded solutions, incorporates technologies that are not required, and therefore are not available in general-purpose systems.  The key to the QNX RTOS is the functionality on which the system itself is built and on which user tasks are often based on <a href="https://habrahabr.ru/post/127173/">message passing</a> .  The peculiarities of using the SRR mechanism (Send / Receive / Reply), as they also call messaging in QNX, and the development of two examples of Qt applications ‚Äî client and server ‚Äî I would like to talk about today. <a name="habracut"></a></p><br><p>  The note does not make any discoveries, it is proposed in general known information.  Nevertheless, Qt is a relatively new framework for developers of special-purpose systems, where historically there has been some inertia in the introduction of new technologies.  QNX system developers may not be familiar enough with Qt's intricacies, and Qt application developers may often not know the specifics of QNX.  Solving the problem of using in one project both the graphical capabilities of the Qt library and QNX-specific technologies may require effort, especially in the early stages.  That is why this note appeared, the purpose of which is to gather information in one place that developers may need when using Qt in QNX. </p><br><h3>  Typical example of using SRR in QNX </h3><br><p>  Since I have already written about <a href="https://habrahabr.ru/post/127173/">QNX messages</a> earlier on Habr√©, including compound messages, we will assume that the theory is already known in some form and we can proceed to practice.  Therefore, here are the source code of the client application: </p><br><div class="spoiler">  <b class="spoiler_title">qnx_client.c</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////// // qnx_client.c // // demonstrates using input/output vector (IOV) messaging // //////////////////////////////////////////////////////////////////////////////// #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include "../iov_server.h" int main(int argc, char* argv[]) { int coid; // Connection ID to server cksum_header_t hdr; // msg header will specify how many bytes of data will follow int incoming_checksum; // space for server's reply int status; // status return value iov_t siov[2]; // create a 2 part iov if ( 2 != argc ) { printf("ERROR: This program must be started with a command-line arg, for example:\n\n"); printf(" iov_client abcdefjhi \n\n"); printf(" where 1st arg(abcdefghi) is the text to be sent to the server to be checksum'd\n"); exit(EXIT_FAILURE); } // locate the server coid = name_open(CKSUM_SERVER_NAME, 0); if ( -1 == coid ) // was there an error attaching to server? { perror("name_open"); // look up error code and print exit(EXIT_FAILURE); } printf("Sending the following text to checksum server: %s\n", argv[1]); // build the header hdr.msg_type = CKSUM_MSG_TYPE; hdr.data_size = strlen(argv[1]) + 1; // setup the message as a two part iov, first the header then the data SETIOV(&amp;siov[0], &amp;hdr, sizeof hdr); SETIOV(&amp;siov[1], argv[1], hdr.data_size); // and send the message off to the server status = MsgSendvs(coid, siov, 2, &amp;incoming_checksum, sizeof incoming_checksum); if ( -1 == status ) // was there an error sending to server? { perror("MsgSend"); exit(EXIT_FAILURE); } printf("received checksum=%d from server\n", incoming_checksum); printf("MsgSend return status: %d\n", status); return EXIT_SUCCESS; }</span></span></code> </pre> </div></div><br><p>  The program is quite trivial, I just took an example from the QNX courses and ‚Äúbrushed my hair‚Äù a little.  This is a console application that accepts a string as input, sends it to the server and displays the server's response ‚Äî the checksum of the string that was transferred earlier.  Note that the example uses compound messages - the <a href="http://www.qnx.com/developers/docs/6.5.0SP1.update/index.html"><code>SETIOV()</code></a> macro and the <a href="http://www.qnx.com/developers/docs/6.5.0SP1.update/index.html"><code>SETIOV()</code></a> function instead of <a href="http://www.qnx.com/developers/docs/6.5.0SP1.update/index.html"><code>MsgSend()</code></a> - which avoids unnecessary copying.  The most interesting thing here is the use of the <a href="http://www.qnx.com/developers/docs/6.5.0SP1.update/index.html"><code>name_open()</code></a> function to search for a server and establish a connection with it. </p><br><p>  Now it's time to look at the source code of the server: </p><br><div class="spoiler">  <b class="spoiler_title">qnx_server.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////////// // qnx_server.c // // demonstrates using input/output vector (IOV) messaging // //////////////////////////////////////////////////////////////////////////////// #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "../iov_server.h" typedef union { uint16_t msg_type; struct _pulse pulse; cksum_header_t cksum_hdr; } msg_buf_t; int calculate_checksum(char *text) { char *c; int cksum = 0; for ( c = text; *c; c++ ) cksum += *c; sleep(10); // emulate calculation delay return cksum; } int main(void) { int rcvid; name_attach_t* attach; msg_buf_t msg; int status; int checksum; char* data; attach = name_attach(NULL, CKSUM_SERVER_NAME, 0); if ( NULL == attach ) { perror("name_attach"); // look up the errno code and print exit(EXIT_FAILURE); } while ( 1 ) { printf("Waiting for a message...\n"); rcvid = MsgReceive(attach-&gt;chid, &amp;msg, sizeof(msg), NULL); if ( -1 == rcvid ) // Was there an error receiving msg? { perror("MsgReceive"); // look up errno code and print break; } else if ( rcvid &gt; 0 ) // Process received message { switch ( msg.msg_type ) { case _IO_CONNECT: // name_open() within the client may send this printf("Received an _IO_CONNECT msg\n"); MsgReply(rcvid, EOK, NULL, 0); break; case CKSUM_MSG_TYPE: printf("Received a checksum request msg, header says the data is %d bytes\n", msg.cksum_hdr.data_size); data = malloc(msg.cksum_hdr.data_size); if ( NULL == data ) { MsgError(rcvid, ENOMEM ); } else { status = MsgRead(rcvid, data, msg.cksum_hdr.data_size, sizeof(cksum_header_t)); printf("Received the following text from client: %s\n", data); checksum = calculate_checksum(data); free(data); status = MsgReply(rcvid, EOK, &amp;checksum, sizeof(checksum)); if (-1 == status) { perror("MsgReply"); } } break; default: MsgError(rcvid, ENOSYS); break; } } else if ( 0 == rcvid ) // Process received pulse { switch ( msg.pulse.code ) { case _PULSE_CODE_DISCONNECT: printf("Received disconnect pulse\n"); ConnectDetach(msg.pulse.scoid); break; case _PULSE_CODE_UNBLOCK: printf("Received unblock pulse\n"); break; default: printf("unknown pulse received, code = %d\n", msg.pulse.code); } } else { printf("Receive returned an unexpected value: %d\n", rcvid); } } return 0; }</span></span></code> </pre> </div></div><br><p>  The server code is a bit more interesting.  The server receives and processes messages from the client.  In fact, in this example, only one message is <code>CKSUM_MSG_TYPE</code> - <code>CKSUM_MSG_TYPE</code> - calculation of the checksum of the transmitted data.  Another message, <code>_IO_CONNECT</code> is sent to the server when the client calls the <code>name_open()</code> function.  In addition to messages, the server can handle service impulses <code>_PULSE_CODE_DISCONNECT</code> and <code>_PULSE_CODE_UNBLOCK</code> .  In this simple example, handling of service messages is not required in principle. </p><br><p>  The algorithm of the server is quite simple.  Initialization is performed first, in this case, the name declaration using the <a href="http://www.qnx.com/developers/docs/6.5.0SP1.update/index.html"><code>name_attach()</code></a> function, after which clients can find the server.  Further work of the server is an ‚Äúeternal cycle‚Äù.  At the very beginning of the cycle, the server is blocked on the <a href="http://www.qnx.com/developers/docs/6.5.0SP1.update/index.html"><code>MsgReceive()</code></a> call waiting for messages from the client.  When a message or pulse arrives, the QNX kernel unlocks the server, which will begin processing the received message.  The example uses the union <code>msg_buf_t</code> to get the message.  This is a common practice for QNX, when possible message types (and the message is usually described by the structure of the C language) are combined into a union.  Our useful message <code>CKSUM_MSG_TYPE</code> we receive with the help of <code>MsgReceive()</code> not entirely, only the header is received, which indicates the size of the data.  The data is read using the <code>MsgRead()</code> function.  The response to the client is sent using the <a href="http://www.qnx.com/developers/docs/6.5.0SP1.update/index.html"><code>MsgReply()</code></a> function, and in case of an error, it is <a href="http://www.qnx.com/developers/docs/6.5.0SP1.update/index.html"><code>MsgError()</code></a> .  Impulses do not require an answer. </p><br><p>  For completeness, here is the text of the header file.  This header file is used by both the server and the client, and, as we will see later, the Qt versions of our server and client also use this file.  It is intended to include the necessary header files and the declaration of the message header structure <code>CKSUM_MSG_TYPE</code> . </p><br><div class="spoiler">  <b class="spoiler_title">iov_server.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _IOV_SERVER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _IOV_SERVER_H_ #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/dispatch.h&gt; #include &lt;sys/neutrino.h&gt; #include &lt;sys/iomsg.h&gt; #include &lt;errno.h&gt; #define CKSUM_SERVER_NAME "cksum" #define CKSUM_MSG_TYPE (_IO_MAX + 2) typedef struct { uint16_t msg_type; unsigned data_size; } cksum_header_t; // checksum reply is an int #endif //_IOV_SERVER_H_</span></span></span></span></code> </pre> </div></div><br><p>  The screenshot below shows an example of the console versions of the server and client: </p><br><p><img src="https://habrastorage.org/files/a2e/9e6/ffd/a2e9e6ffd4c744f78c9a622b8f531e41.png" alt="image"></p><br><p>  First, start the server that expects messages from the client.  Then the client is started, and the string ‚ÄúHello, QNX!‚Äù Is specified as an argument. During operation, the client and server output diagnostic messages to the console, which can be used to judge the work of the programs.  Programs work as expected, you can start writing graphical variants on Qt.  First, we adapt the client application. </p><br><h3>  Qt client example </h3><br><p>  We will develop Qt applications in Qt Creator.  In this case, the process of developing applications for QNX in general does not differ from developing applications for other operating systems.  After all, Qt is a cross-platform framework.  You only need to create a QNX Kit for Qt Creator. </p><br><p>  Create a new application project like Qt Widgets Application.  In this case, Qt Creator will prepare all the necessary files, including the form for the window.  For the client, the form of the window is as follows: </p><br><p><img src="https://habrastorage.org/files/8b3/753/85e/8b375385ee8447c69f752ada9a061664.png" alt="image"></p><br><p>  The form contains a text entry field (text) that is sent to the server, connect (connect) and disconnect (disconnect) buttons from the server, a button (calc) to send a message to the server, an input field (cksum), which is used to display the checksum received from server, and the output area of ‚Äã‚Äãdiagnostic messages (status). </p><br><p>  It remains only to write the code for working with the server and processing the logic of the graphic form.  As a result, we get the following class <code>MainWindow</code> : </p><br><div class="spoiler">  <b class="spoiler_title">mainwindow.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAINWINDOW_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAINWINDOW_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMainWindow&gt; #include "../iov_server.h" namespace Ui { class MainWindow; } class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget *parent = 0); ~MainWindow(); public slots: void log(QString msg); void showCrc(QString crc); private slots: void qnxConnect(); void qnxDisconnect(); void calculate(); private: Ui::MainWindow *ui; int coid; // Connection ID to server }; #endif // MAINWINDOW_H</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">mainwindow.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mainwindow.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ui_mainwindow.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QDateTime&gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) { ui-&gt;setupUi(this); coid = -1; connect(ui-&gt;connect, SIGNAL(clicked()), this, SLOT(qnxConnect())); connect(ui-&gt;disconnect, SIGNAL(clicked()), this, SLOT(qnxDisconnect())); connect(ui-&gt;calc, SIGNAL(clicked()), this, SLOT(calculate())); } MainWindow::~MainWindow() { delete ui; } void MainWindow::qnxConnect() { // check if we already connected if ( coid &gt;= 0 ) return; // connect to the server coid = name_open(CKSUM_SERVER_NAME, 0); if ( coid &lt; 0 ) { log(QString(tr("Can't connect to server: ")).append(strerror(errno))); return; } log(tr("Connected to server")); ui-&gt;connect-&gt;setEnabled(false); ui-&gt;disconnect-&gt;setEnabled(true); ui-&gt;calc-&gt;setEnabled(true); } void MainWindow::qnxDisconnect() { // check if we already disconnected if ( coid &lt; 0 ) return; // disconnect from the server int status = name_close(coid); if ( status &lt; 0 ) { log(QString(tr("Can't disconnect from server: ")).append(strerror(errno))); return; } log(tr("Disconnected from server")); coid = -1; ui-&gt;calc-&gt;setEnabled(false); ui-&gt;disconnect-&gt;setEnabled(false); ui-&gt;connect-&gt;setEnabled(true); } void MainWindow::calculate() { ui-&gt;disconnect-&gt;setEnabled(false); ui-&gt;calc-&gt;setEnabled(false); // get the data QString data = ui-&gt;text-&gt;toPlainText(); log(QString(tr("Sending the following text to checksum server: %1")).arg(data)); // build the header cksum_header_t hdr; // msg header will specify how many bytes of data will follow hdr.msg_type = CKSUM_MSG_TYPE; hdr.data_size = data.length() + 1; // setup the message as a two part iov, first the header then the data iov_t siov[2]; // create a 2 part iov SETIOV(&amp;siov[0], &amp;hdr, sizeof(hdr)); SETIOV(&amp;siov[1], data.toAscii().data(), hdr.data_size); // and send the message off to the server int incoming_checksum; // space for server's reply int status = MsgSendvs(coid, siov, 2, &amp;incoming_checksum, sizeof(incoming_checksum)); if ( status &lt; 0 ) { log(QString(tr("Can't send message to server: ")).append(strerror(errno))); return; } log(QString(tr("MsgSend return status: %1")).arg(status)); showCrc(QString::number(incoming_checksum)); } void MainWindow::showCrc(QString crc) { ui-&gt;cksum-&gt;setText(crc); ui-&gt;disconnect-&gt;setEnabled(true); ui-&gt;calc-&gt;setEnabled(true); } void MainWindow::log(QString msg) { ui-&gt;status-&gt;append(msg.prepend(QDateTime::currentDateTime().toString("hh:mm:ss "))); }</span></span></span></span></code> </pre> </div></div><br><p>  The main.cpp file remains the way Qt Creator created it, so I will not list its contents. </p><br><p>  So, let's see what we have done here.  First, as in the previous example, we start the server.  Then run the Qt client version.  Press the Connect button, note that the server receives a notification about the client connection in the form of a <code>_IO_CONNECT</code> message.  Then we write the text ‚ÄúHello, QNX!‚Äù And press the Calc button, which causes the message to be sent to the server.  The send event is also displayed on the screen.  The checksum received from the server is displayed in the client window. </p><br><p><img src="https://habrastorage.org/files/5e0/f32/3b5/5e0f323b5f31403a98a2001bd83ac584.png" alt="image"></p><br><p>  The example works, messages are sent and received, no problems were noticed.  But ... But I know that everything should not work so well.  The fact is that after calling <code>MsgSendvs()</code> client is blocked at least until the server calls the <code>MsgReceive()</code> function (it can be more if there are higher-priority processes in the system).  To illustrate this feature, a delay in the form of the <code>sleep(10)</code> call has been added to the server's <code>calculate_checksum()</code> function code.  With such a delay in the server, the client is blocked for 10 seconds, which leads to a noticeable "freezing" of the graphical server window. </p><br><p>  In some cases, especially when the server responds immediately to the client (i.e., the information is always available to the server, and does not come from the outside), locking is not a problem.  In other cases, the user may become nervous when his GUI freezes.  I would not risk and release programs that can irritate customers.  With the ‚Äúfrozen‚Äù interface, the client will not be able to continue working with the application after sending the message before receiving a response from the server, and in real life the application can interact with several servers and provide other management functions.  No, the current version of the client application does not suit us.  So let's look at the correct implementation of the client. </p><br><h3>  Right Qt client example </h3><br><p>  How can you solve the problem with locking the client?  The client can not be blocked on <code>MsgSendvs()</code> .  However, it is quite possible to allocate work with messages in a separate thread.  In this case, one thread serves a graphical interface, the other implements the SRR mechanism.  To work with threads in Qt, we will use the <a href="http://doc.qt.io/qt-4.8/qthread.html"><code>QThread</code></a> class.  The SRR implementation will be rendered into a separate <code>Sender</code> class.  The relationship between the <code>Sender</code> classes (work with messages) and <code>MainWindow</code> (graphical interface) is organized through Qt signals and slots. </p><br><p>  Let's see how the <code>MainWindow</code> class has changed, taking into account the above.  For clarity, the old code is also retained, and the <code>SENDER_THREAD</code> macro has been added, when declaring which work with messages is performed in a separate Qt thread. </p><br><div class="spoiler">  <b class="spoiler_title">mainwindow.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAINWINDOW_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAINWINDOW_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMainWindow&gt; #include "../iov_server.h" #define SENDER_THREAD #ifdef SENDER_THREAD #include &lt;QThread&gt; #endif namespace Ui { class MainWindow; } class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget *parent = 0); ~MainWindow(); #ifdef SENDER_THREAD signals: void calcCrc(int coid, QString data); #endif public slots: void log(QString msg); void showCrc(QString crc); private slots: void qnxConnect(); void qnxDisconnect(); void calculate(); private: Ui::MainWindow *ui; int coid; // Connection ID to server #ifdef SENDER_THREAD QThread senderThread; #endif }; #endif // MAINWINDOW_H</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">mainwindow.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mainwindow.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ui_mainwindow.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> SENDER_THREAD #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sender.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QDateTime&gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) { ui-&gt;setupUi(this); coid = -1; connect(ui-&gt;connect, SIGNAL(clicked()), this, SLOT(qnxConnect())); connect(ui-&gt;disconnect, SIGNAL(clicked()), this, SLOT(qnxDisconnect())); connect(ui-&gt;calc, SIGNAL(clicked()), this, SLOT(calculate())); #ifdef SENDER_THREAD Sender *sender = new Sender; sender-&gt;moveToThread(&amp;senderThread); connect(&amp;senderThread, SIGNAL(finished()), sender, SLOT(deleteLater())); connect(this, SIGNAL(calcCrc(int, QString)), sender, SLOT(send(int, QString))); connect(sender, SIGNAL(result(QString)), this, SLOT(showCrc(QString))); connect(sender, SIGNAL(log(QString)), this, SLOT(log(QString))); senderThread.start(); #endif } MainWindow::~MainWindow() { #ifdef SENDER_THREAD senderThread.quit(); senderThread.wait(); #endif delete ui; } void MainWindow::qnxConnect() { // check if we already connected if ( coid &gt;= 0 ) return; // connect to the server coid = name_open(CKSUM_SERVER_NAME, 0); if ( coid &lt; 0 ) { log(QString(tr("Can't connect to server: ")).append(strerror(errno))); return; } log(tr("Connected to server")); ui-&gt;connect-&gt;setEnabled(false); ui-&gt;disconnect-&gt;setEnabled(true); ui-&gt;calc-&gt;setEnabled(true); } void MainWindow::qnxDisconnect() { // check if we already disconnected if ( coid &lt; 0 ) return; // disconnect from the server int status = name_close(coid); if ( status &lt; 0 ) { log(QString(tr("Can't disconnect from server: ")).append(strerror(errno))); return; } log(tr("Disconnected from server")); coid = -1; ui-&gt;calc-&gt;setEnabled(false); ui-&gt;disconnect-&gt;setEnabled(false); ui-&gt;connect-&gt;setEnabled(true); } void MainWindow::calculate() { ui-&gt;disconnect-&gt;setEnabled(false); ui-&gt;calc-&gt;setEnabled(false); // get the data QString data = ui-&gt;text-&gt;toPlainText(); #ifdef SENDER_THREAD emit calcCrc(coid, data); #else log(QString(tr("Sending the following text to checksum server: %1")).arg(data)); // build the header cksum_header_t hdr; // msg header will specify how many bytes of data will follow hdr.msg_type = CKSUM_MSG_TYPE; hdr.data_size = data.length() + 1; // setup the message as a two part iov, first the header then the data iov_t siov[2]; // create a 2 part iov SETIOV(&amp;siov[0], &amp;hdr, sizeof(hdr)); SETIOV(&amp;siov[1], data.toAscii().data(), hdr.data_size); // and send the message off to the server int incoming_checksum; // space for server's reply int status = MsgSendvs(coid, siov, 2, &amp;incoming_checksum, sizeof(incoming_checksum)); if ( status &lt; 0 ) { log(QString(tr("Can't send message to server: ")).append(strerror(errno))); return; } log(QString(tr("MsgSend return status: %1")).arg(status)); showCrc(QString::number(incoming_checksum)); #endif } void MainWindow::showCrc(QString crc) { ui-&gt;cksum-&gt;setText(crc); ui-&gt;disconnect-&gt;setEnabled(true); ui-&gt;calc-&gt;setEnabled(true); } void MainWindow::log(QString msg) { ui-&gt;status-&gt;append(msg.prepend(QDateTime::currentDateTime().toString("hh:mm:ss "))); }</span></span></span></span></code> </pre> </div></div><br><p>  The <code>calcCrc()</code> signal appeared in the declaration of the <code>MainWindow</code> class, with which we tell an instance of the <code>Sender</code> class to whom and what message we need to send. </p><br><p>  The implementation of the <code>MainWindow</code> class has undergone major changes.  A block of code has appeared in the constructor, in which an instance of the <code>Sender</code> class is created and, using the <a href="http://doc.qt.io/qt-4.8/qobject.html"><code>moveToThread()</code></a> method, is allocated to a separate thread.  In the destructor, we expect the thread to end (the <code>quit()</code> and <code>wait()</code> <code>QThread</code> class).  The entire code of the <code>calculate()</code> method has been moved to the <code>Sender</code> class and replaced with the generation of the <code>calcCrc()</code> signal. </p><br><p>  After finalizing the <code>MainWindow</code> , you can go to the <code>Sender</code> class. </p><br><div class="spoiler">  <b class="spoiler_title">sender.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SENDER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SENDER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; #include "../iov_server.h" class Sender : public QObject { Q_OBJECT public: Sender() {} virtual ~Sender() {} signals: void result(QString data); void log(QString err); public slots: void send(int coid, QString data); }; #endif // SENDER_H</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">sender.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"sender.h"</span></span></span><span class="hljs-meta"> void Sender::send(int coid, QString data) { emit log(QString(tr(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Sending the following text to checksum server: %1"</span></span></span><span class="hljs-meta">)).arg(data)); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// build the header cksum_header_t hdr; // msg header will specify how many bytes of data will follow hdr.msg_type = CKSUM_MSG_TYPE; hdr.data_size = data.length() + 1; // setup the message as a two part iov, first the header then the data iov_t siov[2]; // create a 2 part iov SETIOV(&amp;siov[0], &amp;hdr, sizeof(hdr)); SETIOV(&amp;siov[1], data.toAscii().data(), hdr.data_size); // and send the message off to the server int incoming_checksum; // space for server's reply int status = MsgSendvs(coid, siov, 2, &amp;incoming_checksum, sizeof(incoming_checksum)); if ( status &lt; 0 ) { emit log(QString(tr("Can't send message to server: ")).append(strerror(errno))); return; } emit log(QString(tr("MsgSend return status: %1")).arg(status)); emit result(QString::number(incoming_checksum)); }</span></span></span></span></code> </pre> </div></div><br><p>  In essence, this is the code that was previously in the <code>calculate()</code> method of the <code>MainWindow</code> class.  The output of errors and results in the graphical window of the client application is implemented using the signals <code>log()</code> and <code>result()</code> . </p><br><p>  With such modifications, the client‚Äôs graphical interface does not ‚Äúfreeze‚Äù, i.e.  while the <code>Sender</code> class instance is blocked for 10 seconds in a separate thread, we can control the graphic window.  However, in the presented example there is nothing to control, but the possibility is there. </p><br><h3>  Sample Qt Server </h3><br><p>  After experimenting with the client, we will immediately develop the server correctly.  Since the <code>MsgReceive()</code> call causes blocking, we will move the server functionality to the Server class, which will work in a separate thread.  The principles are the same as in the client.  The honest window ‚Äúskomunichd‚Äù form of the client - copy mainwindow.ui, open it in the editor, remove unnecessary buttons and convert the <code>QPlainTextEdit</code> class (text object) into <code>QTextBrowser</code> (the editor allows it). </p><br><p><img src="https://habrastorage.org/files/64c/f23/5b4/64cf235b4e85488cb70068c34dcb1b7c.png" alt="image"></p><br><p>  The declaration and implementation of the server's <code>MainWindow</code> class are listed below: </p><br><div class="spoiler">  <b class="spoiler_title">mainwindow.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAINWINDOW_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAINWINDOW_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QMainWindow&gt; #include &lt;QThread&gt; #include "../iov_server.h" namespace Ui { class MainWindow; } class MainWindow : public QMainWindow { Q_OBJECT public: explicit MainWindow(QWidget *parent = 0); ~MainWindow(); signals: void startServer(name_attach_t* attach); public slots: void log(QString msg); void showCrc(QString crc); void showText(QString txt); void stopServer(void); private: Ui::MainWindow *ui; name_attach_t* attach; QThread serverThread; }; #endif // MAINWINDOW_H</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">mainwindow.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"mainwindow.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ui_mainwindow.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"server.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QDateTime&gt; MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent), ui(new Ui::MainWindow) { ui-&gt;setupUi(this); Server *server = new Server; server-&gt;moveToThread(&amp;serverThread); connect(&amp;serverThread, SIGNAL(finished()), server, SLOT(deleteLater())); connect(this, SIGNAL(startServer(name_attach_t*)), server, SLOT(process(name_attach_t*))); connect(server, SIGNAL(result(QString)), this, SLOT(showCrc(QString))); connect(server, SIGNAL(text(QString)), this, SLOT(showText(QString))); connect(server, SIGNAL(log(QString)), this, SLOT(log(QString))); attach = name_attach(NULL, CKSUM_SERVER_NAME, 0); if ( NULL == attach ) { log(QString(tr("Can't attach name: %1")).arg(strerror(errno))); } else { serverThread.start(); emit startServer(attach); } } MainWindow::~MainWindow() { stopServer(); serverThread.quit(); serverThread.wait(); delete ui; } void MainWindow::showText(QString txt) { ui-&gt;text-&gt;setText(txt); } void MainWindow::showCrc(QString crc) { ui-&gt;cksum-&gt;setText(crc); } void MainWindow::log(QString msg) { ui-&gt;status-&gt;append(msg.prepend(QDateTime::currentDateTime().toString("hh:mm:ss "))); } void MainWindow::stopServer() { if ( NULL != attach ) { name_detach(attach, 0); } }</span></span></span></span></code> </pre> </div></div><br><p>  For server operation, create a name in <code>MainWindow</code> using the function <code>name_attach()</code> .  With the help of a signal, we pass the <code>attach</code> structure to the server thread, thereby starting it.  To stop the server, delete the name - the function <a href="http://www.qnx.com/developers/docs/6.5.0SP1.update/index.html"><code>name_detach()</code></a> .  The rest is very similar to what was done in the client.  Let's look at the code: </p><br><div class="spoiler">  <b class="spoiler_title">server.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SERVER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SERVER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; #include "../iov_server.h" typedef union { uint16_t msg_type; struct _pulse pulse; cksum_header_t cksum_hdr; } msg_buf_t; class Server : public QObject { Q_OBJECT public: Server() {} virtual ~Server() {} signals: void result(QString data); void text(QString text); void log(QString err); public slots: void process(name_attach_t* attach); private: int calculate_checksum(char *text); }; #endif // SERVER_H</span></span></span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">server.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"server.h"</span></span></span><span class="hljs-meta"> int Server::calculate_checksum(char *text) { int cksum = 0; for ( char *c = text; *c; c++ ) cksum += *c; sleep(10); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// emulate calculation delay return cksum; } void Server::process(name_attach_t* attach) { if ( NULL == attach ) { return; } int rcvid; msg_buf_t msg; char *data; while ( 1 ) { emit log(tr("Waiting for a message...")); rcvid = MsgReceive(attach-&gt;chid, &amp;msg, sizeof(msg), NULL); if ( -1 == rcvid ) // Was there an error receiving msg? { emit log(QString(tr("MsgReceive: %1")).arg(strerror(errno))); // look up errno code and print break; } else if ( rcvid &gt; 0 ) // Process received message { switch ( msg.msg_type ) { case _IO_CONNECT: // name_open() within the client may send this emit log(tr("Received an _IO_CONNECT msg")); MsgReply(rcvid, EOK, NULL, 0); break; case CKSUM_MSG_TYPE: emit log(QString(tr("Received a checksum request msg, header says the data is %1 bytes")).arg(msg.cksum_hdr.data_size)); data = (char *)malloc(msg.cksum_hdr.data_size); if ( NULL == data ) { MsgError(rcvid, ENOMEM ); } else { int status = MsgRead(rcvid, data, msg.cksum_hdr.data_size, sizeof(cksum_header_t)); emit text(data); int checksum = calculate_checksum(data); emit result(QString::number(checksum)); free(data); status = MsgReply(rcvid, EOK, &amp;checksum, sizeof(checksum)); if (-1 == status) { emit log(tr("MsgReply")); } } break; default: MsgError(rcvid, ENOSYS); break; } } else if ( 0 == rcvid ) // Process received pulse { switch ( msg.pulse.code ) { case _PULSE_CODE_DISCONNECT: emit log(tr("Received disconnect pulse")); ConnectDetach(msg.pulse.scoid); break; case _PULSE_CODE_UNBLOCK: emit log(tr("Received unblock pulse")); break; default: emit log(QString(tr("unknown pulse received, code = %1")).arg(msg.pulse.code)); } } else { emit log(QString(tr("Receive returned an unexpected value: %1")).arg(rcvid)); } } }</span></span></span></span></code> </pre> </div></div><br><p>  The <code>Server</code> class implements two console server functions (qnx_server), only the output of messages has changed (using Qt signals / slots) and the name is registered in the <code>MainWindow</code> class.  The work of the graphical variants of the client and server is presented in the following screenshot: </p><br><p><img src="https://habrastorage.org/files/cd2/bcb/0ac/cd2bcb0ac8494b60971e381ed6aed9ab.png" alt="image"></p><br><p>  The server turned out without controls.  There are no buttons or input fields.  The graphical server window serves only to monitor its operation. </p><br><h3>  Conclusion </h3><br><p>  That came to an end this note.  The code of several examples was considered, it became clear how to correctly use the QNX message mechanism in Qt applications.  For those who want to reproduce the examples, I <a href="https://bitbucket.org/kpda/qt-srr-example">published them on Bitbucket</a> .  Anticipating possible comments on the code, please note that these are only examples that illustrate the operation of SRR in Qt.  I would have done something differently in the working system, but in order not to overload the examples, their code was simplified, and for some moments I closed my eyes.  Nevertheless, if someone from the readers has specific suggestions for improving the code of examples or correcting errors, I will consider them if possible.  I ask on these issues to contact private messages. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/305680/">https://habr.com/ru/post/305680/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305666/index.html">Improving the energy efficiency of data centers: the experience of Apple, Google, Microsoft, Active Power and Burland Energy</a></li>
<li><a href="../305668/index.html">Scientists again "puzzled": Is it possible to upgrade the brain and what to expect from it</a></li>
<li><a href="../305672/index.html">How to connect to the server via RDP from Windows, Mac OS, iPhone, iPad, Android, Ubuntu or Debian (Linux OS)</a></li>
<li><a href="../305676/index.html">The language of inter-professional communication. Poll results</a></li>
<li><a href="../305678/index.html">Scripto - replacing the standard JavaScriptInterface</a></li>
<li><a href="../305682/index.html">How to write a SQL query on Slick and not open the portal to hell</a></li>
<li><a href="../305686/index.html">Typical mistakes novice technical director in IT - expert opinion</a></li>
<li><a href="../305688/index.html">PhpStorm 2016.2 released</a></li>
<li><a href="../305692/index.html">The best packages for machine learning in R, part 1</a></li>
<li><a href="../305694/index.html">SMS Authentication Organization by Telegram / Viber / WhatsApp Example</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>