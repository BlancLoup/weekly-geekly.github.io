<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Optimization of games for iOS platform. Code vectorization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It has long been brewing a desire to write a couple of articles in which I can lay out my experience and knowledge on how to optimize games for ARMv7 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Optimization of games for iOS platform. Code vectorization</h1><div class="post__text post__text-html js-mediator-article">  It has long been brewing a desire to write a couple of articles in which I can lay out my experience and knowledge on how to optimize games for ARMv7 CPU architecture and PowerVR SGX 5 series of GPUs, read the iOS platform.  But all, or almost all, tips are equally applicable to other systems with the same hardware, read Androids.  This material can be applied not only in games but also in most demanding applications - image processing, audio, video, etc.  I will begin my first article with the most important, IMHO, optimization - vectorization of the code for <b>NEON</b> . <br><br>  This article began as a report at a conference to be held on November 24th.  A bunch of optimization tips for iPhone can be found <a href="http://nukecode.blogspot.com/2012/10/leran-ios-game-development-hard-way.html">here</a> .  The following articles will develop into the breadth and depth of the topics of material from this presentation. <br><a name="habracut"></a><br>  What is NEON?  NEON is a general purpose <abbr title="Single Instruction Multiple Data">SIMD</abbr> engine used in ARM processors.  On board has 16 registers of 128 bits each, which can be considered as 32 registers of 64 bits.  NEON shares its registers with VFP, although it has its own pipeline.  As in the case of SSE data must be aligned to 16 bytes.  NEON also knows how to work with non-aligned data, but usually it is 2 times slower. <br><br>  NEON can work with: <br><ul><li>  Signed \ without signed 8 \ 16 \ 32 \ 64-bit integer data types; </li><li>  Single precision floating point numbers - 32-bit float. </li></ul><br>  It is great for multimedia tasks, including games. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start with the core - the heart of every modern mobile system, a system on a chip, or a SoC (System on Chip).  It is known that iOS devices use Apple A series of systems on a chip - A4, A5, A5x, A6 and A6x.  The most important specifications of these chips are given in the table: <br><table><tbody><tr><th>  <i>CPU specifications</i> </th><th>  A4 </th><th>  A5 </th><th>  A5x </th><th>  A6 </th></tr><tr><td>  Architecture </td><td>  ARMv7 </td><td>  ARMv7 </td><td>  ARMv7 </td><td>  ARMv7 </td></tr><tr><td>  Core </td><td>  Cortex A8 </td><td>  Cortex A9 </td><td>  Cortex A9 </td><td>  Self-developed </td></tr><tr><td>  # cores </td><td>  one </td><td>  2 </td><td>  2 </td><td>  2 </td></tr><tr><td>  Frequency, MHz </td><td>  800 </td><td>  1000 </td><td>  1000 </td><td>  1300 </td></tr><tr><td>  Extensions </td><td>  VFPv3 (VFPLite), NEON </td><td>  VFPv3, NEON </td><td>  VFPv3, NEON </td><td>  VFPv4, NEON </td></tr><tr><td>  <i>GPU specifications</i> </td><td></td><td></td><td></td><td></td></tr><tr><td>  Model </td><td>  PowerVR SGX 535 </td><td>  PowerVR SGX 543MP2 </td><td>  PowerVR SGX 543MP4 </td><td>  PowerVR SGX 543MP3 </td></tr><tr><td>  Frequency, MHz </td><td>  200 </td><td>  200 </td><td>  200 </td><td>  266 </td></tr></tbody></table>  <i>* Note: NEON runs on CPU frequency</i> <br><br>  It is easy to see that NEON has a 5-fold increase in frequency compared to the GPU!  Of course, this does not mean that we will get a 5-fold increase in performance compared with the GPU - IPC, pipeline, etc.  are significant.  But NEON has one killer feature - it can process 4 32-bit floats in parallel, while PowerVR SGX has only one.  It seems that the PowerVR SGX 5-series SIMD registers have a length of 64 bits, since the GPU can process 4 floats of half precision (16 bits) in parallel.  Consider an example: <br><br><pre><code class="cpp hljs">highp vec4 v1, v2; highp <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> s1, s2; <span class="hljs-comment"><span class="hljs-comment">//  v2 = (v1 * s1) * s2; //v1 * s1      ‚Äì 4 ,       s2,     -  4 . //8    //  v2 = v1 * (s1 * s2); //s1 * s2 ‚Äì 1    ;  * v1 ‚Äì 4   . //5   </span></span></code> </pre> <br>  Now let's look at another example, executed on the vector GPU engine: <br><pre> <code class="cpp hljs">mediump vec4 v1, v2, v3; highp vec4 s1, s2, s3; v3 = v1 * v2; <span class="hljs-comment"><span class="hljs-comment">//    ‚Äì 1  s3 = s1 * s2; //    ‚Äì 4 </span></span></code> </pre><br>  You will need a <b>highp</b> specifier for your data, for example, the vertex position.  The profit from NEON is obvious here. <br><br>  We now turn to another advantage of NEON.  It is known that PowerVR SGX 5th series have <abbr title="Universal Scalable Shader Engine">USSE</abbr> , a shader processor, which no matter what type of shaders to process - vertex or pixel.  This means that the programmer has a certain power budget and he has to decide what to spend on it - vertex or pixel processing.  This is where NEON comes to the rescue - this is your new vertex processor.  You might think that I forgot to insert a troll-face here, but everything is quite serious.  The performance of almost every mobile system is limited by fill rate, especially in 2D games, especially in our time of the race for screen resolution.  Having transferred all vertex processing to NEON, you release resources for pixel processing.  In addition, NEON will help reduce the number of calls to draw - count the positions of all the vertices of one batch in world coordinates and draw N objects in one call. <br><br>  The theory is over!  Now for the hardcore!  There are several ways to take advantage of NEON'a: <br><ul><li>  Let the compiler vectorize the code for you.  Bad way.  The compiler may vectorize ... or it may not vectorize.  Even if the compiler vectorizes the code, it‚Äôs far from a fact that this will be the optimal code.  But, on the other hand, this method does not require any effort on your part, and you can get a profit.  But still, you should not blindly hope for the compiler, but manually vectorize at least the most critical code. </li><li>  NEON assembler.  And here he is, hardcore.  The path of a true Jedi and all that.  We'll have to learn dark magic, spend the night behind manuals from ARM, etc.  It is also worth keeping in mind that the NEON code works in both ARM and Thumb-2 modes. </li><li>  NEON intrinsics (same as SSE for x86).  In contrast to the assembler, where the compiler stupidly inserts what he was given, intrinsiki will be optimized.  It is much easier to live with them - there is no need to learn the timings of instructions, shuffle them to avoid stagnation of the pipeline, etc. </li><li>  Use with already vectorized code - GLKMath, math neon. </li></ul><br>  It is time to discover all the advantages and disadvantages of each method.  For this, I wrote a simple demo - every frame of 10,000 sprites will change its position to a random one within the screen.  The goal is to get the fastest code with a minimum load on the CPU - because in games you need to read a lot of things, in addition to the data for rendering. <br><br>  All data is stored in one VBO.  The Update method multiplies the projection matrix on the ModelView matrix of a random position.  Then each vertex of each sprite will be multiplied by the resulting ModelViewProjection matrix.  The final position of each vertex will simply be transferred to gl_Position in the vertex shader.  All data is aligned to the 16 byte boundary. <br><br>  Update method code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GLKMatrix4 modelviewMat = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> u32 QUADS_COUNT = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> u32 VERTS_PER_QUAD = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Y_DELTA = <span class="hljs-number"><span class="hljs-number">420.0f</span></span> / QUADS_COUNT; <span class="hljs-comment"><span class="hljs-comment">//     Y float vertDelta = Y_DELTA; for (int i = 0; i &lt; QUADS_COUNT * VERTS_PER_QUAD; i += VERTS_PER_QUAD) { float randX = random() % 260; //     modelviewMat.m[12] = randX; modelviewMat.m[13] = vertDelta; float32x4x4_t mvp; Matrix4ByMatrix4((float32x4x4_t*)proj.m, (float32x4x4_t*)modelviewMat.m, &amp;mvp); for (int j = 0; j &lt; 4; ++j) { Matrix4ByVec4(&amp;mvp, &amp;squareVertices[j], &amp;data[i + j].pos); } vertDelta += Y_DELTA; } glBindBuffer(GL_ARRAY_BUFFER, vertexBuffer); glBufferData(GL_ARRAY_BUFFER, sizeof(data), data, GL_STREAM_DRAW); }</span></span></code> </pre><br>  Well, now we come to the essence of this article - vectorization of the code.  Next, the code used in the three compared approaches for the most frequently used operations in game devs will be presented - matrix multiplication by vector and matrix multiplication by matrix. <br><br>  Copypasta with GLKMath: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> __<span class="hljs-function"><span class="hljs-function">inline__ GLKVector4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GLKMatrix4MultiplyVector4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLKMatrix4 matrixLeft, GLKVector4 vectorRight)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float32x4x4_t</span></span> iMatrix = *(<span class="hljs-keyword"><span class="hljs-keyword">float32x4x4_t</span></span> *)&amp;matrixLeft; <span class="hljs-keyword"><span class="hljs-keyword">float32x4_t</span></span> v; iMatrix.val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vmulq_n_f32(iMatrix.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">float32_t</span></span>)vectorRight.v[<span class="hljs-number"><span class="hljs-number">0</span></span>]); iMatrix.val[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vmulq_n_f32(iMatrix.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">float32_t</span></span>)vectorRight.v[<span class="hljs-number"><span class="hljs-number">1</span></span>]); iMatrix.val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vmulq_n_f32(iMatrix.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">float32_t</span></span>)vectorRight.v[<span class="hljs-number"><span class="hljs-number">2</span></span>]); iMatrix.val[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vmulq_n_f32(iMatrix.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], (<span class="hljs-keyword"><span class="hljs-keyword">float32_t</span></span>)vectorRight.v[<span class="hljs-number"><span class="hljs-number">3</span></span>]); iMatrix.val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vaddq_f32(iMatrix.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], iMatrix.val[<span class="hljs-number"><span class="hljs-number">1</span></span>]); iMatrix.val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vaddq_f32(iMatrix.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], iMatrix.val[<span class="hljs-number"><span class="hljs-number">3</span></span>]); v = vaddq_f32(iMatrix.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], iMatrix.val[<span class="hljs-number"><span class="hljs-number">2</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(GLKVector4 *)&amp;v; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> __<span class="hljs-function"><span class="hljs-function">inline__ GLKMatrix4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GLKMatrix4Multiply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GLKMatrix4 matrixLeft, GLKMatrix4 matrixRight)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float32x4x4_t</span></span> iMatrixLeft = *(<span class="hljs-keyword"><span class="hljs-keyword">float32x4x4_t</span></span> *)&amp;matrixLeft; <span class="hljs-keyword"><span class="hljs-keyword">float32x4x4_t</span></span> iMatrixRight = *(<span class="hljs-keyword"><span class="hljs-keyword">float32x4x4_t</span></span> *)&amp;matrixRight; <span class="hljs-keyword"><span class="hljs-keyword">float32x4x4_t</span></span> m; m.val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vmulq_n_f32(iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vmulq_n_f32(iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vmulq_n_f32(iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vmulq_n_f32(iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>)); m.val[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vmlaq_n_f32(m.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], iMatrixLeft.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], vgetq_lane_f32(iMatrixRight.val[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(GLKMatrix4 *)&amp;m; }</code> </pre>  It is easy to see that the implementation of these operations from Apple uses a far from optimal approach - transferring variables by value, copying variables.  It looks pretty slow, at least in the debug build it will be such.  Let's see how this code will show itself when profiling. <br><br>  Assembly approach: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Matrix4ByVec4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ mat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ vec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ result)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> ( <span class="hljs-string"><span class="hljs-string">"vldmia %0, { d24-d31 } \n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vld1.32 {q1}, [%1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmul.f32 q0, q12, d2[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q0, q13, d2[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q0, q14, d3[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q0, q15, d3[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vstmia %2, { q0 }"</span></span> : : <span class="hljs-string"><span class="hljs-string">"r"</span></span> (mat), <span class="hljs-string"><span class="hljs-string">"r"</span></span> (vec), <span class="hljs-string"><span class="hljs-string">"r"</span></span> (result) : <span class="hljs-string"><span class="hljs-string">"memory"</span></span>, <span class="hljs-string"><span class="hljs-string">"q0"</span></span>, <span class="hljs-string"><span class="hljs-string">"q1"</span></span>, <span class="hljs-string"><span class="hljs-string">"q8"</span></span>, <span class="hljs-string"><span class="hljs-string">"q9"</span></span>, <span class="hljs-string"><span class="hljs-string">"q10"</span></span>, <span class="hljs-string"><span class="hljs-string">"q11"</span></span> ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Matrix4ByMatrix4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ m1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ m2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span> ( <span class="hljs-string"><span class="hljs-string">"vldmia %1, { q0-q3 } \n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vldmia %2, { q8-q11 }\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmul.f32 q12, q8, d0[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmul.f32 q13, q8, d2[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmul.f32 q14, q8, d4[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmul.f32 q15, q8, d6[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q12, q9, d0[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q13, q9, d2[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q14, q9, d4[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q15, q9, d6[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q12, q10, d1[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q13, q10, d3[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q14, q10, d5[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q15, q10, d7[0]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q12, q11, d1[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q13, q11, d3[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q14, q11, d5[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vmla.f32 q15, q11, d7[1]\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"vstmia %0, { q12-q15 }"</span></span> : : <span class="hljs-string"><span class="hljs-string">"r"</span></span> (result), <span class="hljs-string"><span class="hljs-string">"r"</span></span> (m2), <span class="hljs-string"><span class="hljs-string">"r"</span></span> (m1) : <span class="hljs-string"><span class="hljs-string">"memory"</span></span>, <span class="hljs-string"><span class="hljs-string">"q0"</span></span>, <span class="hljs-string"><span class="hljs-string">"q1"</span></span>, <span class="hljs-string"><span class="hljs-string">"q2"</span></span>, <span class="hljs-string"><span class="hljs-string">"q3"</span></span>, <span class="hljs-string"><span class="hljs-string">"q8"</span></span>, <span class="hljs-string"><span class="hljs-string">"q9"</span></span>, <span class="hljs-string"><span class="hljs-string">"q10"</span></span>, <span class="hljs-string"><span class="hljs-string">"q11"</span></span>, <span class="hljs-string"><span class="hljs-string">"q12"</span></span>, <span class="hljs-string"><span class="hljs-string">"q13"</span></span>, <span class="hljs-string"><span class="hljs-string">"q14"</span></span>, <span class="hljs-string"><span class="hljs-string">"q15"</span></span> ); }</code> </pre>  For a person not familiar with the assembler, everything seems pretty scary - I myself am so, I can understand only the NEON assembler.  But in fact, everything is simple here - <i>q1-q15</i> is, actually, NEON registers.  <b>vldmia \ vld1.32</b> - download instructions;  <b>vstmia</b> - save to memory;  <b>vmul.f32 \ vmla.f32</b> - multiply \ multiply and add. <br><br>  Intrinsic method: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Matrix4ByVec4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ mat, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ vec, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ result)</span></span></span><span class="hljs-function"> </span></span>{ (*result) = vmulq_n_f32((*mat).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], (*vec)[<span class="hljs-number"><span class="hljs-number">0</span></span>]); (*result) = vmlaq_n_f32((*result), (*mat).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], (*vec)[<span class="hljs-number"><span class="hljs-number">1</span></span>]); (*result) = vmlaq_n_f32((*result), (*mat).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], (*vec)[<span class="hljs-number"><span class="hljs-number">2</span></span>]); (*result) = vmlaq_n_f32((*result), (*mat).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], (*vec)[<span class="hljs-number"><span class="hljs-number">3</span></span>]); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Matrix4ByMatrix4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ m1, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ m2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float32x4x4_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">* __restrict__ r)</span></span></span><span class="hljs-function"> </span></span>{ (*r).val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vmulq_n_f32((*m1).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vmulq_n_f32((*m1).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vmulq_n_f32((*m1).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vmulq_n_f32((*m1).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">1</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">2</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">0</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">1</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">2</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">2</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>)); (*r).val[<span class="hljs-number"><span class="hljs-number">3</span></span>] = vmlaq_n_f32((*r).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], (*m1).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], vgetq_lane_f32((*m2).val[<span class="hljs-number"><span class="hljs-number">3</span></span>], <span class="hljs-number"><span class="hljs-number">3</span></span>)); }</code> </pre>  Almost the same code as in GLKMath, but there are some minor differences.  Explanations: <b>vmulq_n_f32</b> - multiplication of a vector by a scalar;  <b>vgetq_lane_f32</b> - a macro that selects a scalar from a vector;  <b>vmlaq_n_f32</b> - multiply by a scalar and add.  This code is simply a reflection of the assembler on intrinsiki.  Let's see how he will show himself in comparison with him. <br><br>  I did a test on the iPod Touch 4. The table contains the results of the profiling Update function: <br><table><tbody><tr><th>  An approach </th><th>  Execution time, ms </th><th>  CPU load,% </th></tr><tr><td>  FPU </td><td>  6058 + 5067 * </td><td>  35-38 </td></tr><tr><td>  GLKMath </td><td>  2789 </td><td>  20-23 </td></tr><tr><td>  Assembler </td><td>  5304 </td><td>  23-25 </td></tr><tr><td>  Intrinsiki </td><td>  2803 </td><td>  18-20 </td></tr></tbody></table>  <i>* In the <a href="">screenshot</a> of Instruments, you can see that the Matrix4ByMatrix4 function has not been zailed.</i> <br><br>  Here's another tip - aggressively inline your performance-critical code.  Prefer <b>__attribute __ ((always_inline))</b> before the usual <b>inline</b> in such cases. <br><br>  Updated results table: <br><table><tbody><tr><th>  An approach </th><th>  Execution time, ms </th><th>  CPU load,% </th></tr><tr><td>  FPU forceinlined </td><td>  6209 </td><td>  25-28 </td></tr><tr><td>  GLKMath </td><td>  2789 </td><td>  20-23 </td></tr><tr><td>  Assembler </td><td>  5304 </td><td>  23-25 </td></tr><tr><td>  Intrinsiki </td><td>  2803 </td><td>  18-20 </td></tr></tbody></table>  Forced inline gave a very good performance boost!  Let's see how code auto-vectorization will show itself.  All we need is to add <b>‚Äìmllvm ‚Äìvectorize ‚Äìmllvm ‚Äìbb-vectorize-aligned-only</b> to <i>Other C Flags</i> in the project settings. <br><br>  Final results table: <br><table><tbody><tr><th>  An approach </th><th>  Execution time, ms </th><th>  Runtime (vector), ms </th><th>  CPU load,% </th><th>  CPU load (vector),% </th></tr><tr><td>  FPU forceinlined </td><td>  6209 </td><td>  5028 </td><td>  25-28 </td><td>  22-24 </td></tr><tr><td>  GLKMath </td><td>  2789 </td><td>  2776 </td><td>  20-23 </td><td>  20-23 </td></tr><tr><td>  Assembler </td><td>  5304 </td><td>  5291 </td><td>  23-25 </td><td>  22-24 </td></tr><tr><td>  Intrinsiki </td><td>  2803 </td><td>  2789 </td><td>  18-20 </td><td>  18-20 </td></tr></tbody></table><br>  Quite strange results can be observed in the case of the assembler and intrinsoks - in fact, the code is the same, but the result differs dramatically - almost 2 times!  The answer to this question lies in the assembler listing (willing to look in for yourself).  In the case of the assembler, we see in the listing exactly what we wrote.  In the case of intrinsics, the compiler optimized the code.  Slow, at first glance, the code GLKMath compiler perfectly optimized that gave the same time of execution of the code as that of manually written intrinsikov. <br><br><div class="spoiler">  <b class="spoiler_title">Results in the form of screenshots</b> <div class="spoiler_text">  <a href="">FPU forceinlined</a> <br>  <a href="">FPU AutoVectorized</a> <br>  <a href="">GLKMath</a> <br>  <a href="">Assembler</a> <br>  <a href="">Intrinsiki</a> <br></div></div><br>  It is time to sum up.  You can draw several conclusions: <br><ul><li>  The engineers at the LLVM team did a great job.  As a result, the compiler generates well optimized code for intrinsics.  I did a similar test more than a year ago, when the only compiler in XCode was GCC 4.2 and it gave a very bad result - only 10-15% of the performance gain compared to the FPU code.  This is great news - there is no need to learn assembler and I am extremely happy about it! </li><li>  Clang compiler can auto-vectorize code.  For a programmer, this is a bonus in productivity by writing only 4 words.  What else can I say besides the fact that this is a cool thing ?! </li><li>  NEON code gives a very good performance boost compared to normal C code - 2.22 times!  According to the results of the done optimization, vertex processing became faster than copying those very peaks to the GPU side!  If you look at the memcpy assembler, you can see that it also uses the NEON code.  The lack of hardware prifetcha in Cortex A8, apparently, is the cause of slower code. </li><li>  Learning all these low level things is worth your time, especially if your goal is to become a professional. </li></ul><br><br><h5>  Links </h5>  <a href="http://www.arm.com/products/processors/technologies/neon.php">www.arm.com/products/processors/technologies/neon.php</a> <br>  <a href="http://blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores/">blogs.arm.com/software-enablement/161-coding-for-neon-part-1-load-and-stores</a> <br>  <a href="http://code.google.com/p/math-neon/">code.google.com/p/math-neon</a> <br>  <a href="http://llvm.org/devmtg/2012-04-12/Slides/Hal_Finkel.pdf">llvm.org/devmtg/2012-04-12/Slides/Hal_Finkel.pdf</a> <br>  <a href="http://code.google.com/p/neon-demo/">Demo project</a> </div><p>Source: <a href="https://habr.com/ru/post/156809/">https://habr.com/ru/post/156809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../156797/index.html">SEO apology</a></li>
<li><a href="../156801/index.html">ARM ChrUbuntu 12.04 Alpha - Porting Ubuntu to Samsung Chromebook</a></li>
<li><a href="../156803/index.html">The most popular programming languages</a></li>
<li><a href="../156805/index.html">A simple way to prepare reports based on rtf forms</a></li>
<li><a href="../156807/index.html">Easy copying of paper documents in Linux</a></li>
<li><a href="../156811/index.html">Apple Push Notification Service Guide</a></li>
<li><a href="../156813/index.html">Webinar on the topic: How to avoid the 5 most common mistakes that lead to the failure of all startups?</a></li>
<li><a href="../156817/index.html">EventTrace for Windows. High-speed transmission of driver debug messages over the network</a></li>
<li><a href="../156819/index.html">Pow - easy, fast, convenient</a></li>
<li><a href="../156821/index.html">Technology tracking and scanning using a conventional webcam</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>