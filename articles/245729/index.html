<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CPU vs GPU. Distance field</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello to all. I already once wrote about Distance Field and gave the implementation of a "heuristic" code that gives a good speed: "Honest glow and sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CPU vs GPU. Distance field</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/699/ff7/4e5/699ff74e5715436c9b7ee44a814690e2.png" align="left">  Hello to all.  I already once wrote about Distance Field and gave the implementation of a "heuristic" code that gives a good speed: <a href="http://habrahabr.ru/post/186482/">"Honest glow and speed</a> . <a href="http://habrahabr.ru/post/186482/">"</a> <br><br><h4>  Why is it needed? </h4><br>  DField can be applied: <br><ul><li>  To significantly improve the quality of fonts </li><li>  For effects like contour burning.  I gave one of the effects in my previous article. </li><li>  For the ‚Äúmetaballs‚Äù effect, but in 2D and for any complex shapes.  (maybe I'll ever give an example of the implementation of this effect) </li><li>  And at the moment I need DField for high-quality smoothing of corners and removal of small details. </li></ul><br>  And if in the first two cases we can calculate the DField in advance, then for other effects we need to calculate it in real time. <br>  The article will consider the most popular, I would say the classic Chamfer distance (CDA) with a bunch of pictures explaining its principle of operation, as well as a two-pass algorithm on the GPU. <br>  Both algorithms are <a href="https://sourceforge.net/projects/dfsamples/">implemented in FPC demonstration programs</a> . <br><a name="habracut"></a><br><h4>  Chamfer Classic on CPU </h4><br>  Today I would like to draw attention to the classic way of calculating DField.  You can play <a href="http://sourceforge.net/projects/dfsamples/files/ChamferDF.zip/download">here</a> (source code in git).  The algorithm has an unstable name: <i>chamfer distance algoritm</i> .  <s>This method has already described the <a href="http://habrahabr.ru/users/rpg/" class="user_link">RPG</a> in his <a href="http://habrahabr.ru/post/215905/">topic</a> .</s>  <s>However, there is no explanation why and how this code works.</s>  <s>Why there are errors, what they are, and how to reduce them.</s> <s><br></s>  <b>upd.</b>  The <a href="http://habrahabr.ru/users/rpg/" class="user_link">RPG has a</a> modification of the CDA algorithm that successfully fights errors. <br><h4>  Under the hood at chamfer </h4><br>  So, we have a monochrome image from which we want to build a Distance Field.  This is a white dot on a black background: <br><br><img src="https://habrastorage.org/files/b28/3ab/01f/b283ab01f28d4152965d4bfc4afa004b.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start building a DField.  To do this, first fill our future image + infinity for voids, and zeros for the object.  Something like this: <br><br><img src="https://habrastorage.org/files/9fd/de9/b0a/9fdde9b0ab5f41109f86b9dec0d4fca2.PNG"><br><br>  Then we start to run along the image (from left to right and from top to bottom), and for each pixel to check its neighbors.  Take the value in the adjacent pixel, add to this the distance to the neighbor.  For pixels on the right and left, this distance is 1. For pixels on the diagonal, sqrt (1 * 1 + 1 * 1) = sqrt (2).  Let's write in our pixel the minimum value between the current one and the one just calculated by the neighbor.  After we do this for all neighbors - go to the next pixel.  We got this picture: <br><br><img src="https://habrastorage.org/files/b6f/616/98a/b6f61698a7924a11899a9d78752d576f.PNG"><br><br>  As we ran from left to right and from top to bottom, the distances accumulated from previous calculations, and the pixels marked with red arrows automatically counted "true."  Now, if we run in the opposite direction (from right to left, from bottom to top), then the missing part of the map will be filled. <br><br>  So, the main idea is to use the already calculated early distance.  To do this, we do not need to check all the neighbors.  It is enough to check the pixels for which we have already run: <br><br><img src="https://habrastorage.org/files/996/bf7/2c4/996bf72c4aff452680843a36a3dfa70a.PNG"><br>  Red - pixels of neighbors for the first pass are marked (right, down).  Blue - for the second (left, up). <br><br>  The first pass will give us a beautiful trail in one direction: <br><br><img src="https://habrastorage.org/files/414/92d/18b/41492d18b0304a49a1e770440c2f89c5.png"><br><br>  The second will give to the other, and since we will record only the minimum value in both cases, then in sum it will look like this: <br><br><img src="https://habrastorage.org/files/d69/16c/2e1/d6916c2e156b43e9bc0970d16007ca68.png"><br>  O (2 * W * H * 5) algorithm complexity <br><br>  Now let's talk about accuracy.  There are no problems on the current image, but if you try to build a contour (as in <a href="http://habrahabr.ru/post/215905/">this article</a> ), then the result will not be the most plausible.  Let's look at the distance% 16 contour: <br><br><img src="https://habrastorage.org/files/d01/c1b/bbf/d01c1bbbfc4c42fa9df8c1be867f8bcd.png"><br><br>  Red arrows, I noted the pronounced octagon image.  Why is this happening?  Everything is simple, because our result accumulates, and it accumulates incorrectly: <br><br><img src="https://habrastorage.org/files/b59/e61/408/b59e614084b64b25bab9480476bb6512.PNG"><br><br>  Our distance will be calculated by the red line: 1 + sqrt (2), while it will be correctly calculated by the blue line: sqrt (2 * 2 + 1 * 1) = sqrt (3).  If we take in the calculations not only neighbors, but also neighbors neighbors: <br><br><img src="https://habrastorage.org/files/933/ac6/782/933ac67825984e79960c65f780edf4f6.PNG"><br><br>  The result, of course, will be better.  But computational complexity increases from O (2 * W * H * 5) to O (2 * W * H * 13).  But there is good news, we can throw out some of the neighbors, without affecting the result: <br><br><img src="https://habrastorage.org/files/c8d/04f/054/c8d04f054c124d8eb1176a745e4abc8d.PNG"><br><br>  The fact is that the discarded neighbors have a multiple distance and lie on the same beam.  So we can throw them away, because the value from the nearest ones will correctly accumulate.  I will call the matrix of neighbors a kernel.  In the first case, we had a 3x3 core.  Now the core is 5x5.  Let's look at the result: <br><br><img src="https://habrastorage.org/files/b05/f3a/18e/b05f3a18eb3442a5a879375b2424ad78.png"><br><br>  Our octogonality has become noticeably ‚Äúrounder‚Äù.  (By the way, in Photoshop for layers there is an Outer glow effect with the precise parameter. I have the result exactly the same after the 5x5 core passes. It looks like they use this algorithm for this effect.) <br>  Difficulty for optimized 5x5 = O (2 * W * H * 9) <br>  You can continue to continue to increase and increase the size of the core, the quality will increase, but we will not be able to overcome one unpleasant effect.  Here is the image for the kernel 13 * 13: <br><br><img src="https://habrastorage.org/files/f6a/57c/713/f6a57c71387e4769921e18570febd1dd.png"><br><br>  On the image there are stepped gradients.  They are still associated with the notorious error, and in order to completely get rid of them we would have to create a kernel the size of two image widths, since  a diagonal with sides (Many; 1) can cover only a core of 2 * Many + 1.  (various modifications of CDA struggle with these errors, one of the options is to store the vector in a pixel to the nearest one, but I will not touch them in the article). <br><br><h5>  So summarily, the advantages of the algorithm </h5><br><ul><li>  Unlimited Distance Field (we understand what it is when we deal with the algorithm on the GPU). </li><li>  Linear complexity, and high speed for small cores. </li><li>  Ease of implementation. </li></ul><br><br><h5>  Minuses </h5><br><ul><li>  Poor accuracy (especially for small cores) </li><li>  Dependence on previous calculations (no SIMD to you) </li></ul><br><h4>  GPU into battle </h4><br>  Unfortunately, I have not found any popular algorithms that fall on the multi-threaded GPU architecture.  Either my hands are wrong, or Google is squeezed.  Therefore, I will share with you my "bicycle".  Fortunately it is simple.  You can play <a href="http://sourceforge.net/projects/dfsamples/files/gpuDF.zip/download">here</a> , the source is in git.  The game will require a video card that supports OpenGL3 and Rect textures. <br><br>  So, let's say it is important for us to calculate Distance Field within a radius of 40 pixels.  The first pass, we consider only the vertical distance from 40 neighbors above and from 40 neighbors below for each pixel.  We write down the minimum value (if there are no filled neighbors - we write down the maximum value, 40).  We get this picture: <br><br><img src="https://habrastorage.org/files/2a1/200/f40/2a1200f402954164a48191c864e170d3.png"><br><br>  After this, we make the second passage horizontally.  Similarly, 40 neighbors left, 40 neighbors right.  Knowing the distance to the neighbor, + vertical distance from the neighbor - we easily consider the hypotenuse: <br><br><img src="https://habrastorage.org/files/06d/7c9/823/06d7c982354447db91c57296f27bdbcd.png"><br><br>  In the result we write the minimum hypotenuse.  After the second pass, we are waiting for a beautiful and well-constructed picture: <br><br><img src="https://habrastorage.org/files/009/c16/359/009c163597ec46599bd02c560240fc3e.png"><br><br>  The complexity of the algorithm is O (2 * W * H * (2 * D + 1)), where W and H are the dimensions of the image, and D is the distance of the distance field.  The distance field we get is normalized (in the image there will be no values ‚Äã‚Äãgreater than D). <br>  The accuracy of the calculations is excellent, because  errors do not accumulate: <br><br><img src="https://habrastorage.org/files/614/0f1/990/6140f1990326414bb798eb4d7d71888e.png"><br><br>  In the annex to the article there are three modes: GL_R8, GL_R16, GL_R32F.  If you turn on GL_R8 and twist distortion, then you can see jumping errors.  The point here is this.  For an intermediate vertical DField, the storage texture is 8 bits per pixel.  Since I normalize the distance to the range [0; 1], errors arise.  It is necessary either to keep the distance not normalized (but then for an eight-bit texture it will be limited to 255 pixels), or to increase the bit depth of the texture.  For the texture of R16, these errors are smaller, and for R32F these errors are generally ‚Äúout of place‚Äù, since  This is a float texture.  Consider this if you want to implement a similar distance field. <br><br><h5>  So, the pros: </h5><br><ul><li>  Absolute accuracy </li><li>  Perfectly fits SIMD. </li><li>  Ease of implementation </li><li>  The data immediately lie on the GPU! </li></ul><br><br><h5>  Minuses </h5><br><ul><li>  Limited distance.  We need to know what distance we need in advance. </li><li>  The complexity of the algorithm depends on the distance. </li><li>  Data on the GPU (this may require additional time to get if we plan to continue working with this data on the CPU) </li></ul><h4>  Findings? </h4><br>  I have a GF450 in my home computer.  For the Hello world and DField = 500 pixels image, my GPU manages to do 20 frames per second, which is approximately 50ms per frame.  All this with excellent quality and simple transparent code.  On a 3x3 CPU, the distance field is calculated to be approximately 100ms.  5x5 about 200ms.  Even if I accelerate, optimizing for the CPU 4 times (which is very cool), then I will get the quality noticeably worse in the same time.  Use the GPU if the algorithms allow it. <br><br><h4>  Related Links </h4><br><ol><li>  <a href="https://sourceforge.net/projects/dfsamples/">sourceforge.net/projects/dfsamples</a> - Actually examples for the article.  Binary and source codes. </li><li>  <a href="http://www.springer.com/cda/content/document/cda_downloaddocument/9780387312019-c1.pdf">www.springer.com/cda/content/document/cda_downloaddocument/9780387312019-c1.pdf</a> - an excellent analysis of both the Chamfer algorithm and its modifications.  Comparison of errors and runtime. </li><li>  <a href="http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf">www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf</a> - Using DField in a font renderer.  Perhaps the most famous article. </li><li>  <a href="http://habrahabr.ru/post/215905/">habrahabr.ru/post/215905</a> - the above article from the <a href="http://habrahabr.ru/users/rpg/" class="user_link">RPG</a> .  Well shows the use of DField. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/245729/">https://habr.com/ru/post/245729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245713/index.html">Hell Visualization 1.1 - Book 1: Overview</a></li>
<li><a href="../245717/index.html">WiFi Pineapple Mark V: black box for wireless interception</a></li>
<li><a href="../245719/index.html">Obfuscation of lines at compile time</a></li>
<li><a href="../245721/index.html">If the customer is a revision</a></li>
<li><a href="../245727/index.html">Concurrency structure in .net. ConcurrentDictionary from the inside</a></li>
<li><a href="../245731/index.html">Expressive JavaScript: Forms and Form Fields</a></li>
<li><a href="../245735/index.html">Search for the best sequence of viewing the list of 250 best movies using the Wolfram Language (Mathematica)</a></li>
<li><a href="../245737/index.html">Web Design Books</a></li>
<li><a href="../245739/index.html">Japanese startup attracted $ 90 million for advertising on the moon</a></li>
<li><a href="../245745/index.html">Composer. It is not safe to use packagist and a private source of packages at the same time.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>