<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using monads in C ++. Part 2: state monad</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part 1 
 Part 2 

 What do you do if you win the lottery tomorrow? Buy a sports car, quit your job and go on a tour of the USA? Or maybe become the fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using monads in C ++. Part 2: state monad</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://habrahabr.ru/company/infopulse/blog/260809/"><b>Part 1</b></a> <br>  <b>Part 2</b> <br><br>  What do you do if you win the lottery tomorrow?  Buy a sports car, quit your job and go on a tour of the USA?  Or maybe become the founder of your own company, multiply the state and buy a personal plane? <br><br>  We all love to make plans, and most often they rely on our financial condition.  Such plans can be described by function.  For example, the plan for buying a car is: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs">pair&lt;Car, Cash&gt; buyCar(Cash cashIn)</code> </pre> <br><br>  At the entrance we have a certain amount of money ( <b>Cash</b> ), and at the exit a new car ( <b>Car</b> ) and some amount (not a fact that is positive!) Of the remaining finances ( <b>Cash</b> ). In general, a financial plan is a function that accepts money and returns the result, plus the remaining amount of money.  It can be described by the pattern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plan</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">&lt;pair&lt;A, Cash&gt;(Cash)&gt;;</span></span></code> </pre><br><br>  You can combine small plans to get big.  For example, you can use the funds left after buying a car for your trip or invest in a business.  If you have things that already belong to you, they can become part of your plans: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plan</span></span></span><span class="hljs-class">&lt;A&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">got_it</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [a](Cash s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(a, s); }; }</code> </pre><br><br>  What does all these dreams have to do with solving our <a href="http://habrahabr.ru/company/infopulse/blog/260809/">puzzle</a> ?  I said earlier that we need to save a state somewhere, and this is the way programmers in functional languages ‚Äã‚Äãwork with state.  Instead of explicitly modifying the state, they write code that generates a plan of action. <br><a name="habracut"></a><br>  In our case, the programmer in the imperative language can write something like the procedure for buying a car, which transfers the object of the bank account and the cost of the car.  Or (horror!) The object of a bank account can be global. <br><br>  In functional programming, each individual plan is a function: the state arrives at the input and the new state returns at the output associated with anything that the function deems necessary to return as the result of its work.  These small plans are going to larger plans.  In the end, the Main Plan is executed - that function, at the input of which the present input state comes and whose result should represent the final entity we are looking for.  In modern C ++, we can do things like this with lambdas. <br><br><h4>  State monad </h4><br><br>  To find a solution to our puzzle, we will generate substitutions by selecting numbers from a list of integers.  The list of integers will be our state. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> State = List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;;</code> </pre><br><br>  We will use a persistent list, so we don‚Äôt need to worry about rolling back.  Persistent lists never change - all their versions are persistent and we can return to them without fear that they might change.  We need them when we combine our state calculations with the list monad to get the final solution.  For now, consider one substitution. <br><br>  We will create plans that take the current state and create a new one: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">using</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plan</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">&lt;pair&lt;A, State&gt;(State)&gt;;</span></span></code> </pre><br><br>  We can always start a plan by giving it some initial state: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pair</span></span></span><span class="hljs-class">&lt;A, State&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">runPlan</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plan</span></span></span><span class="hljs-class">&lt;A&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pl</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">s</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pl(s); }</code> </pre><br><br>  As you can remember from the previous article, the feature of each monad is that it can combine smaller entities to create larger ones.  In the case of a state monad, we need the ability to create action plans. <br><br>  Imagine, for example, that you know how to generate a plan for a tour of the United States, provided you have a car and some budget.  But you do not have a car.  No problem, we can create a plan for buying a car.  Having both of them is not difficult to generate a general plan for buying a car and planning a trip. <br><br>  Pay attention to two components: one of them is a plan for buying a car: <b>Plan &lt;Car&gt;</b> .  The second component is the function that receives the car and generates the trip plan, <b>Plan &lt;Trip&gt;</b> .  This function is a ‚Äúcontinuation‚Äù that leads you to the ultimate goal: functions like <b>Plan &lt;Trip&gt; (Car)</b> .  And the ‚Äúcontinuation‚Äù in itself can consist of a large number of small plans. <br><br>  And here is the <b>mbind</b> function that binds the plan <b>pl</b> to the ‚Äúcontinuation‚Äù <b>k</b> .  Continuing uses the output of the plan <b>pl</b> to generate a new plan.  The <b>mbind</b> function should return the new master plan, that is, it should return the lambda.  Like any other plan, this lambda takes a state and returns a pair: value and state.  We implement this lambda in the most common way. <br><br>  The logic is simple.  Inside the lambda state is available to us, which means we can run a plan <b>pl</b> .  At its output, we get a pair: the value of type <b>A</b> and the new state.  We transfer this value to the ‚Äúcontinuation‚Äù <b>k</b> and get a new plan.  In the end, we run this plan with a new state and that's it. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mbind</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plan</span></span></span><span class="hljs-class">&lt;A&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pl</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">decltype</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">k</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pl</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class">()).</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">first</span></span></span><span class="hljs-class">)) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> B = <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(k(pl(State()).first)(State()).first); <span class="hljs-comment"><span class="hljs-comment">//         ,  //       ++ static_assert(std::is_convertible&lt; F, std::function&lt;Plan&lt;B&gt;(A)&gt;&gt; ::value, "mbind requires a function type Plan&lt;B&gt;(A)"); return [pl, k](State s) { pair&lt;A, State&gt; ps = runPlan(pl, s); Plan&lt;B&gt; plB = k(ps.first); return runPlan(plB, ps.second); // new state! }; }</span></span></code> </pre><br><br>  Note that this entire launch of the plans inside <b>mbind</b> does not happen immediately.  It occurs only when lambda is performed, i.e.  when a larger plan is launched (perhaps as part of a larger plan launch).  So all that <b>mbind</b> does is create a new plan that will be executed sometime in the future. <br><br>  And, as for any monad, there is a function that takes the usual input data and turns it into a trivial plan.  Let's call it mreturn. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Plan</span></span></span><span class="hljs-class">&lt;A&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mreturn</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [a](State s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(a, s); }; }</code> </pre><br><br>  Two auxiliary functions usually come close to the state monad.  The <b>getState</b> function gives direct access to the state by copying it to the return value: <br><br><pre> <code class="cpp hljs">Plan&lt;State&gt; getState() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [](State s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(s, s); }; }</code> </pre><br><br>  Using <b>getState,</b> you can check the status as the plan <b>runs</b> and dynamically select one of the branches of your code.  This makes the monads very flexible, but at the same time complicates the composition of several monads.  We will see this at the stage of combining the monad of the state and the monad of the list. <br><br>  The second auxiliary function is used to modify (complete replacement) the state. <br><br><pre> <code class="cpp hljs">Plan&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*&gt; putState(State newState) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [=](State s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(<span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>, newState); }; }</code> </pre><br><br>  It does not calculate anything useful, so it returns a value of type <b>void *</b> and this value is <b>nullptr</b> .  Its only purpose is to encapsulate side effects.  Yes, you can do this and still maintain the functional purity of your code. <br><br><h5>  Example </h5><br><br>  And here is a small demonstration of the work of the state monad.  We will start with a simple plan that just takes the first number from the list (the list will be our state): <br><br><pre> <code class="cpp hljs">pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; select(List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; lst) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = lst.front(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> make_pair(i, lst.popped_front()); }</code> </pre><br><br>  The <b>popped_front</b> method of a persistent list returns a list without its first element.  Since the list is persistent, this method does not modify the original list.  At the same time, it does not create a copy of it ‚Äî it simply returns a pointer to the tail of the list, starting from the second element. <br><br>  Here is our first plan: <br><br><pre> <code class="cpp hljs">Plan&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; sel = &amp;select;</code> </pre><br><br>  Now we will create a more complex plan for generating pairs of integers: <br><br><pre> <code class="cpp hljs">Plan&lt;pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; pl = mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mreturn(make_pair(i, j)); }); });</code> </pre><br><br>  Let's analyze this code.  The first <b>mbind</b> accepts the <b>sel</b> plan, which selects the first item from the list (the list will be provided later during the execution of the plan).  It binds to the "continuation", which takes the selected integer <b>i</b> and generates a plan that creates a pair of integers.  Here is the "continuation": <br><br><pre> <code class="cpp hljs">[=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mreturn(make_pair(i, j)); }); });</code> </pre><br><br>  It binds the <b>sel</b> plan to another, smaller ‚Äúextension‚Äù, which accepts the selected element <b>j</b> and generates a plan to create a pair of integers.  Here is a smaller "continuation": <br><br><pre> <code class="cpp hljs">[=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mreturn(make_pair(i, j)); });</code> </pre><br><br>  It combines the first integer <b>i</b> , which was captured by a lambda with the second integer <b>j</b> , which was passed to the lambda argument and creates a trivial plan that returns a pair: <br><br><pre> <code class="cpp hljs">mreturn(make_pair(i, j));</code> </pre><br><br>  Please note that we use the same <b>sel</b> plan twice.  But when this plan is executed within our final plan, it will return two different elements of the initial list.  When <b>mbind</b> is <b>executed</b> , it first passes the state (a list of integers) to the first <b>sel</b> .  Back she gets a modified state - a list without the first element.  She then uses this short list to fulfill the plan created by the continuation.  Thus, the second <b>sel</b> selects the first item from the already shortened list (the second item of the original list).  Here the list is shortened again and passed to <b>mreturn</b> , which no longer modifies it. <br><br>  Now we can run the final plan, giving it a list of integers: <br><br><pre> <code class="cpp hljs">List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; st{ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; runPlan(pl, st) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br><br>  We are still not ready to solve the original puzzle, but the solution is already very close.  All we have to do is combine the list monad and state monad.  And we will do it in the next part. <br>  In the meantime, take a look at the final decision: <br><br><pre> <code class="cpp hljs">StateL&lt;tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; solve() { StateL&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; sel = &amp;select&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> s) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> o) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mbind(sel, [=](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mthen(guard(s != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; m != <span class="hljs-number"><span class="hljs-number">0</span></span>), [=]() { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> send = asNumber(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;{s, e, n, d}); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> more = asNumber(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;{m, o, r, e}); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> money = asNumber(<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;{m, o, n, e, y}); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mthen(guard(send + more == money), [=]() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mreturn(make_tuple(send, more, money)); }); }); });});});});});});});}); }</code> </pre><br><br>  This time I did not rename <b>mbind</b> to <b>for_each</b> , but mreturn to <b>yield</b> . <br><br>  Now that we have reviewed the state monad, you can see that the single <b>sel</b> passed to the arguments in <b>mbind</b> will generate different numbers (assuming that there were different numbers in the original list). <br><br><h5>  Before you write a comment </h5><br><br>  I know what you are thinking now: why do I need to complicate my life with monads, if there is a much simpler imperative style of working with the state?  What are the benefits of a functional approach?  Immediate benefit is thread safety.  In imperative programming, the mutable shared state is the source of endless errors.  The state monad and the use of persistent data structures exclude the possibility of racing and does so without any synchronization (except for reference counting in smart pointers). <br><br>  I completely agree that C ++ is not the best language for a functional programming style and C ++ monads look complicated.  But let's face it, C ++ code rarely looks simple at all.  What I have described here is the details of the components that should be encapsulated in an easy-to-use library. <br><br><h5>  Home tasks </h5><br><br><ul><li>  Implement <b>select</b> from example in text using <b>getState</b> and <b>putState</b> </li><li>  Implement <b>evalPlan</b> , a <b>runPlan</b> version that returns only the final value, without state </li><li>  Implement <b>mthen</b> , the <b>mbind</b> version, where the ‚Äúcontinuation‚Äù takes no arguments.  It ignores the result of the plan, which is the first argument <b>mthen</b> (but still runs it and uses the modified state) </li><li>  Use the state monad to write a simple expression calculator in the <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">reverse Polish notation</a> .  The state in this case will be a stack (list) of elements. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ItemType { Plus, Minus, Num }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span><span class="hljs-class"> {</span></span> ItemType _type; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _num; Item(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) : _type(Num), _num(i) {} Item(ItemType t) : _type(t), _num(<span class="hljs-number"><span class="hljs-number">-1</span></span>) {} };</code> </pre><br><br>  Implement the <b>calc ()</b> function, which implements an elementary calculator.  Here is an example, the output should be -1: <br><br><pre> <code class="cpp hljs">List&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>{ Item(Plus) , Item(Minus) , Item(<span class="hljs-number"><span class="hljs-number">4</span></span>) , Item(<span class="hljs-number"><span class="hljs-number">8</span></span>) , Item(<span class="hljs-number"><span class="hljs-number">3</span></span>) }; <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; evalPlan(calc(), <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  (Solution is available on <a href="https://github.com/BartoszMilewski/MoreMoney">Github</a> ) <br></li></ul></div><p>Source: <a href="https://habr.com/ru/post/261145/">https://habr.com/ru/post/261145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261133/index.html">Vulnerability iOS and OS X, the success of Bethesda, a reward from Google - and other news of the week for a mobile developer</a></li>
<li><a href="../261137/index.html">Fast filter catalog for online stores based on Redis bitmaps</a></li>
<li><a href="../261139/index.html">How we developed our DNS manager</a></li>
<li><a href="../261141/index.html">JavaScript Modules</a></li>
<li><a href="../261143/index.html">Virtual PBX 3CX Phone System v14 in 3CX company cloud</a></li>
<li><a href="../261147/index.html">New Cherry Framework 4 | Cherry ripened</a></li>
<li><a href="../261149/index.html">Intel RealSense SDK Architecture</a></li>
<li><a href="../261151/index.html">A simple alarm clock with a web interface on Asterisk</a></li>
<li><a href="../261155/index.html">ICANN suspended Freenom accreditation</a></li>
<li><a href="../261157/index.html">Gateway through the Chinese firewall</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>