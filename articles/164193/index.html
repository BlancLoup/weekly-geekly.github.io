<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>What is TCHAR, WCHAR, LPSTR, LPWSTR, LPCTSTR (etc)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many C ++ programmers writing under Windows are often confused over these strange identifiers like TCHAR, LPCTSTR. In this article I will try to dot t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>What is TCHAR, WCHAR, LPSTR, LPWSTR, LPCTSTR (etc)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/6e9/a58/1e0/6e9a581e01e0a30eab11b7577cd43546.jpg"><br><br>  Many C ++ programmers writing under Windows are often confused over these strange identifiers like TCHAR, LPCTSTR.  In this article I will try to dot the best way over I. And dispel the fog of doubt. <br><br>  At one time, I spent a lot of time digging through the sources and did not understand what these mysterious TCHAR, WCHAR, LPSTR, LPWSTR, LPCTSTR mean. <br>  Recently I found a very competent article and present its high-quality translation. <br>  The article is recommended for those who sleepless nights to crawl in C ++ codes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You are interested ?? <br>  I ask under kat !!! <br><a name="habracut"></a><br><br>  In general, a character string can be represented as 1 byte and 2 bytes. <br>  Typically, a single-byte character is an ANSI character encoding ‚Äî all characters are represented in this encoding.  A 2-byte character is a UNICODE encoding in which all other languages ‚Äã‚Äãin the world can be represented. <br><br>  The Visual C ++ compiler supports char and wchar_t as built-in data types for ANSI and UNICODE encodings. Although there is a more specific definition of Unicode, but for understanding, Windows uses exactly 2-byte encoding for many application language support. <br><br><blockquote>  To represent 2-byte Unicode encoding, Microsoft Windows uses UTF16 encoding. <br>  Microsoft has become one of the first companies that began to implement Unicode support in their operating systems (Windows NT family). </blockquote><br><br>  What to do if you want your C / C ++ code to be independent of encodings and the use of different coding modes? <br><br>  <b>TIP.</b>  Use common data types and names to represent characters and strings. <br><br>  For example, instead of changing the following code: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cResponse; <span class="hljs-comment"><span class="hljs-comment">// 'Y' or 'N' char sUsername[64]; // str* functions (  char       str*)</span></span></code> </pre> <br><br>  On that!!! <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> cResponse; <span class="hljs-comment"><span class="hljs-comment">// 'Y' or 'N' wchar_t sUsername[64]; // wcs* functions (  wchar_t       wcs*)</span></span></code> </pre><br>  In order to support multilingual applications (for example, Unicode), you can write code in a more general manner. <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;TCHAR.H&gt; // Implicit or explicit include TCHAR cResponse; // 'Y' or 'N' TCHAR sUsername[64]; // _tcs* functions (  TCHAR       _tcs*)</span></span></span></span></code> </pre><br><br>  In the project settings on the GENERAL tab, there is a CHARACTER SET parameter that indicates in which encoding the program will be compiled: <br><br><img src="https://habrastorage.org/storage2/3e8/254/081/3e825408153f8ddb366e6e5c20fe595e.png"><br><br>  If the ‚ÄúUse Unicode Character set‚Äù parameter is specified, the TCHAR type will be translated to the wchar_t type.  If the parameter ‚ÄúUse Multi-byte character set‚Äù is specified, then TCHAR will be translated to type char.  You can freely use the char and wchar_t types, and the project settings in no way affect the use of these keywords. <br><br>  TCHAR is defined as: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _UNICODE typedef wchar_t TCHAR; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> typedef char TCHAR; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  The _UNICODE macro will be included if you specify ‚ÄúUse Unicode Character set‚Äù and then the TCHAR type will be defined as wchar_t.  When you specify ‚ÄúUse Multi-byte character set‚Äù TCHAR will be defined as char. <br><br>  In addition, for supporting multiple character sets using common base code, and possibly supporting many language applications, use specific functions (that is, macros). <br>  Instead of using strcpy, strlen, strcat (including protected versions of the function with the _s prefix), or wcscpy, wcslen, wcscat (including protected versions), you'd better use the _tcscpy, _tcslen, _tcscat functions. <br><br>  As you know, the strlen function is described as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*);</code> </pre><br><br>  And the wcslen function is described as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> wcslen(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>* );</code> </pre><br><br>  You'd better use _tcslen, which is logically described as: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _tcslen(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TCHAR* );</code> </pre><br><br>  WC is a Wide Character.  Therefore, wcs functions will be for wide-character-string (i.e., for a large-character string). Thus _tcs will mean _T character string.  And as you know, strings with the _T prefix can be of type char or wchar_t. <br><br>  But in reality _tcslen (and other functions with the _tcs prefix) are not functions at all, they are macros.  They are simply described as: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _UNICODE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _tcslen wcslen #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _tcslen strlen #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  You can view the TCHAR.H header file and search for more Macro descriptions like the one above. <br><br>  Thus, TCHAR is not a type at all, but a superstructure over types char and wchar_t.  Allowing thereby to choose a multi-language application, we will have or all the same, one language. <br><br>  You ask why they are described as macros, and not as a full feature ?? <br>  The reason is simple: A library or DLL can export a simple function with the same name and prototype (Excluding the concept of overloading in C ++). <br>  For example, if you export a function: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _TPrintChar(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>);</code> </pre><br><br>  How should the client call her ??  How: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> _TPrintChar(<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>);</code> </pre><br><br>  _TPrintChar can magically be converted to a function that takes a two-byte character as an argument. <br><br>  To do this, we will do two different functions: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintCharA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// A = ANSI (  ) void PrintCharW(wchar_t); // W = Wide character ( )</span></span></code> </pre><br><br>  And a simple macro will hide the difference between them: <br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> _UNICODE void _TPrintChar(wchar_t); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> void _TPrintChar(char); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre><br><br>  The client will simply call the function as <br><pre> <code class="cpp hljs">TCHAR cChar; _TPrintChar(cChar);</code> </pre><br><br>  Note that TCHAR and _TPrintChar will now be comparable to UNICODE or ANSI, and the variable cChar and the function parameter will be comparable to the char or wchar_t data type. <br><br>  Macros allow us to circumvent these difficulties, and allow us to use ANSI or UNICODE functions for our characters and strings.  Many Windows functions are described this way, and for a programmer there is only one function (that is, a macro) and this is good. <br><br>  I will give an example with SetWindowText: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// WinUser.H #ifdef UNICODE #define SetWindowText SetWindowTextW #else #define SetWindowText SetWindowTextA #endif // !UNICODE</span></span></code> </pre><br><br>  There are only a few functions that do not have such macros, and they are only with the suffix W or A. An example of this is the ReadDirectoryChangesW function, which has no equivalent in the ANSI encoding. <br><hr><br><br>  As you know, we use double quotes to represent strings.  The string represented in this manner is an ANSI string, for each character 1 byte is used.  I will give an example: <br><pre> <code class="cpp hljs">‚Äú ANSI .    <span class="hljs-number"><span class="hljs-number">1</span></span> .‚Äù</code> </pre><br><br>  The above string is not a UNICODE string, and is not suitable for a lot of language support.  In order to get a UNICODE string, you need to use the prefix L. <br>  I will give an example: <br><pre> <code class="cpp hljs">L‚Äù Unicode .     <span class="hljs-number"><span class="hljs-number">2</span></span> ,  . ‚Äù</code> </pre><br><br>  Put an L in front and you get a UNICODE string.  All characters (I repeat all characters) occupy 2 bytes, including English letters, spaces, numbers and the null character.  The amount of Unicode string data will always be a multiple of 2 bytes.  Unicode string of 7 characters will occupy 14 bytes.  If the Unicode string is 15 bytes, then this is not the correct string, and it will not work in any context. <br><br>  Also, the string will be a multiple of the sizeof size (TCHAR) in bytes. <br><br>  When you need hard-coded code, you can write code like this: <br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">" ANSI"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ANSI L" Unicode"; // Unicode _T(" ,   "); // ANSI  Unicode //    TEXT,      </span></span></code> </pre><br><br>  Strings without a prefix are ANSI strings, with a L prefix, Unicode strings, and strings with the _T prefix and TEXT are compilation dependent.  Again, _T and TEXT are macros again.  They are defined as: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  #ifdef _UNICODE #define _T(c) L##c #define TEXT(c) L##c #else #define _T(c) c #define TEXT(c) c #endif</span></span></code> </pre><br><br>  The ## symbol is the key (token) of the operator insertion, which converts _T ("Unicode") to L "Unicode", where the string is an argument for the macro, unless of course _UNICODE is defined. <br>  If _UNICODE is not defined then _T (‚ÄúUnicode‚Äù) will turn it into ‚ÄúUnicode‚Äù.  The operator's insert key even existed in C, and this is not a specific thing related to the encoding of strings in VC ++. <br><br>  Note that macros can be used not only for strings, but also for characters.  For example, _T ('R') turns it into L'R 'well, or just' R '.  Ie either in the Unicode character or in the ANSI character. <br><br>  <b>No, and again no, you cannot use a macro to convert a character or string to Unicode and not Unicode text.</b> <br>  The following code will be incorrect: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c = <span class="hljs-string"><span class="hljs-string">'C'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> str[<span class="hljs-number"><span class="hljs-number">16</span></span>] = <span class="hljs-string"><span class="hljs-string">"Habrahabr"</span></span>; _T( c ); _T(str);</code> </pre><br><br>  Strings _T (c);  _T (str);  compile perfectly in ANSI mode, _T (x) will turn into x, and _T (c) along with _T (str) will turn into just c and str. <br>  But when you build a project in Unicode mode, the code does not compile: <br><pre> <code class="cpp hljs">error C2065: <span class="hljs-string"><span class="hljs-string">'Lc'</span></span> : undeclared identifier error C2065: <span class="hljs-string"><span class="hljs-string">'Lstr'</span></span> : undeclared identifier</code> </pre><br><br>  I would not want to cause a stroke of your intellect and explain why it does not work. <br><br>  There are several functions for converting multibyte strings to UNICODE, which I will discuss shortly. <br><br>  There is an important note that almost all functions that a string or character takes, which is prioritized in the Windows API, have a generic name in MSDN and elsewhere. <br>  The SetWindowTextA / W function will be classified as: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWindowText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> TCHAR*)</span></span></span></span>;</code> </pre><br><br>  But as you know, SetWindowText is just a macro, and depending on the project settings it will be viewed as: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWindowTextA</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetWindowTextW</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(HWND, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">wchar_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">*)</span></span></span></span>;</code> </pre><br><br>  So do not break your head if you can not get the address of this function: <br><pre> <code class="cpp hljs">HMODULE hDLLHandle; FARPROC pFuncPtr; hDLLHandle = LoadLibrary(<span class="hljs-string"><span class="hljs-string">L"user32.dll"</span></span>); pFuncPtr = GetProcAddress(hDLLHandle, <span class="hljs-string"><span class="hljs-string">"SetWindowText"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// pFuncPtr  null,      SetWindowText   </span></span></code> </pre><br><br>  In the User32.DLL library, there are 2 functions SetWindowTextA and SetWindowTextW which are exported, that is, there are no names with a generic name. <br><br>  All functions that have ANSI and UNICODE versions generally have only UNICODE implementations.  This means that when you call SetWindowTextA from your code, passing an ANSI string parameter - it converts ANSI to UNICODE and calls SetWindowTextW. <br>  The real work (setting the title / title / window label) is only the Unicode version! <br><br>  Take another example that will retrieve window text using GetWindowText. <br>  You call GetWindowTextA by passing it an ANSI buffer as the target buffer. <br>  GetWindowTextA first calls GetWindowTextW, possibly allocating memory for the Unicode string (that is, the wchar_t array). <br>  It then converts the Unicode to the ANSI string for you. <br><br>  These ANSI to Unicode conversions are not a limitation of only GUI functions, but the whole subset of the Windows API functions that accept strings and has two options. <br>  I will give another example of such functions: <br><ul><li>  CreateProcess </li><li>  Getusername </li><li>  Opendesktop </li><li>  DeleteFile </li><li>  etc </li></ul><br><br>  Therefore, it is highly recommended to call Unicode functions directly. <br>  In turn, this means that you should always aim at building the Unicode version, and not at the ANSI version, given the fact that you have been used to using ANSI strings for many years. <br><br>  Yes, you can save and receive ANSI lines, for example, to write to a file, or send a chat message to your chat program.  Conversion functions exist for such needs. <br><br>  <b>Note: There is one more type description: the name to it is WCHAR - it is equivalent to wchar_t.</b> <br><hr><br><br>  TCHAR is a macro for declaring a single character.  You can also declare a TCHAR array.  And what if for example you want to describe a pointer to characters or, a constant pointer to characters. <br>  I will give an example: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ANSI  foo_ansi(char*); foo_ansi(const char*); /*const*/ char* pString; // Unicode/wide-string foo_uni(WCHAR*); wchar_t* foo_uni(const WCHAR*); /*const*/ WCHAR* pString; //  foo_char(TCHAR*); foo_char(const TCHAR*); /*const*/ TCHAR* pString;</span></span></code> </pre><br><br>  After reading chips with TCHAR, you probably prefer to use it.  There are still good alternatives for representing strings in your code.  To do this, simply include Windows.h in the project. <br>  Note: If your project includes windows.h (indirectly or directly), you should not include TCHAR.H in the project. <br>  To begin with we will reconsider old function that it was easier to understand.  Example function strlen. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*);</code> </pre><br>  Which can be presented differently. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(LPCSTR);</code> </pre><br><br>  Where LPCSTR is described as: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Simplified typedef const char* LPCSTR;</span></span></code> </pre><br><br>  LPCSTR is understood as. <br>  ‚Ä¢ LP - Long Pointer (long pointer) <br>  ‚Ä¢ C - Constant (constant) <br>  ‚Ä¢ STR - String (string) <br>  Essentially, LPCSTR is a (Long) pointer to a string. <br><br>  Let's change the strcpy to match the new style of the type name: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">LPSTR </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">strcpy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPSTR szTarget, LPCSTR szSource)</span></span></span></span>;</code> </pre><br><br>  szTarget is of type LPSTR, without using the C language types. LPSTR is defined as: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* LPSTR;</code> </pre><br><br>  Note that szSource is of type LPCSTR, since the strcpy function does not modify the source buffer, therefore the const attribute is set.  The returned data type is not a constant string: LPSTR. <br><br>  So, functions with the prefix str for manipulating ANSI strings.  But we need another two byte Unicode strings.  For the same large symbols, there are equivalent functions. <br>  For example, to calculate the length of characters of large characters (Unicode strings), you will use wcslen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> nLength; nLength = wcslen(<span class="hljs-string"><span class="hljs-string">L"Unicode"</span></span>);</code> </pre><br><br>  The prototype of the wcslen function is: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> wcslen(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>* szString); <span class="hljs-comment"><span class="hljs-comment">//  WCHAR*</span></span></code> </pre><br><br>  And the code above can be presented differently: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> wcslen(LPCWSTR szString);</code> </pre><br><br>  Where LPCWSTR is described as: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> WCHAR* LPCWSTR; <span class="hljs-comment"><span class="hljs-comment">// const wchar_t*</span></span></code> </pre><br><br>  LPCWSTR can be understood as: <br>  LP - Long Pointer (Long Index) <br>  C - Constant (constant) <br>  WSTR - Wide character String (large character string) <br><br>  Similarly, the strcpy equivalent of wcscpy, for Unicode strings: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>* wcscpy(<span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>* szTarget, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>* szSource)</code> </pre><br><br>  Which can be represented as: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">LPWSTR </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wcscpy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(LPWSTR szTarget, LPWCSTR szSource)</span></span></span></span>;</code> </pre><br><br>  Where szTarget is not a constant big string (LPWSTR), but szSource is a constant big string. <br><br>  There are a number of equivalent wcs functions for str functions.  the str functions will be used for plain ANSI strings, and the wcs functions for unicode strings. <br><br>  Although I have already advised that you should use native Unicode functions, not just ANSI or just synthesized TCHAR functions.  The reason is simple - your application should only be Unicode, and you should not worry about whether they are being sorted for ANSI.  But for the sake of completeness, I mentioned these general mappings (projections) !!! <br><br>  To calculate the length of a string, you can use the _tcslen function (macro). <br>  Which is described as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _tcslen(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TCHAR* szString);</code> </pre><br><br>  Or so: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _tcslen(LPCTSTR szString);</code> </pre><br><br>  Where the name of the LPCTSTR type can be understood as <br>  LP - Long Pointer (Long Index) <br>  C - Constant (Constant) <br>  T = tchar <br>  STR = String (String) <br><br>  Depending on the project settings, LPCTSTR will be projected into LPCSTR (ANSI) or LPCWSTR (Unicode). <br><br>  Note that the strlen, wcslen, or _tcslen functions will return the number of characters in a string, not the number of bytes. <br><br>  The generic _tcscpy string copy operation is described as follows: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _tcscpy(TCHAR* pTarget, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TCHAR* pSource);</code> </pre><br><br>  Or in an even more generalized manner, like: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> _tcscpy(LPTSTR pTarget, LPCTSTR pSource);</code> </pre><br><br>  You can guess what LPTSTR means)) <br><br><hr><br><h5>  Examples of using. </h5><br><br>  First I give an example of a non-working code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ TCHAR name[] = <span class="hljs-string"><span class="hljs-string">"Saturn"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nLen; <span class="hljs-comment"><span class="hljs-comment">// Or size_t lLen = strlen(name); }</span></span></code> </pre><br><br>  On an ANSI assembly, this code successfully compiles because TCHAR is of type char, and the variable name is an array of char.  Calling strlen for a name will work just fine too. <br><br>  So.  Let's compile the same with the UNICODE / _UNICODE enabled (in the project settings, select ‚ÄúUse Unicode Character Set‚Äù). <br>  Now the compiler will produce this kind of error: <br><pre> <code class="cpp hljs">error C2440: <span class="hljs-string"><span class="hljs-string">'initializing'</span></span> : cannot convert from <span class="hljs-string"><span class="hljs-string">'const char [7]'</span></span> to <span class="hljs-string"><span class="hljs-string">'TCHAR []'</span></span> error C2664: <span class="hljs-string"><span class="hljs-string">'strlen'</span></span> : cannot convert parameter <span class="hljs-number"><span class="hljs-number">1</span></span> from <span class="hljs-string"><span class="hljs-string">'TCHAR []'</span></span> to <span class="hljs-string"><span class="hljs-string">'const char *'</span></span></code> </pre><br><br>  And programmers will begin to correct the error in this way: <br><pre> <code class="cpp hljs">TCHAR name[] = (TCHAR*)<span class="hljs-string"><span class="hljs-string">"Saturn"</span></span>;</code> </pre><br><br>  And this will not pacify the compiler, because converting from TCHAR * to TCHAR [7] is impossible.  The same error will occur when embedded ANSI strings are passed to Unicode functions: <br><br><pre> <code class="cpp hljs">nLen = wcslen(<span class="hljs-string"><span class="hljs-string">"Saturn"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// error: cannot convert parameter 1 from 'const char [7]' to 'const wchar_t *' // :      1  'const char [7]'  'const wchar_t *'</span></span></code> </pre><br><br>  Unfortunately (or fortunately), this error can be incorrectly corrected by simply casting the C language types. <br><pre> <code class="cpp hljs">nLen = wcslen((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span>*)<span class="hljs-string"><span class="hljs-string">"Saturn"</span></span>);</code> </pre><br><br>  And you think that you have increased your experience when working with pointers.  YOU are not right - this code will give an incorrect result, and in most cases you will receive Access Violation (access violation).  Type casting in this way is like passing a float variable when it is expected (logically) to have a structure of 80 bytes. <br><br>  The string "Saturn" is a sequence of 7 bytes: <br><table><tbody><tr><td>  <strong>'S'</strong> (83) </td><td>  <strong>'a'</strong> (97) </td><td>  <strong>'t'</strong> (116) </td><td>  <strong>'u'</strong> (117) </td><td>  <strong>'r'</strong> (114) </td><td>  <strong>'n'</strong> (110) </td><td>  <strong>'\ 0'</strong> (0) </td></tr></tbody></table><br><br>  But when you send the same set of bytes to wcslen, it treats every 2 bytes as one character.  Therefore, the first 2 bytes [97,83] will be considered as one character meaning 24915 (97 &lt;&lt; 8 | 83).  This is a Unicode character ??? .. And the other following characters are treated as [117,116] and so on. <br><br>  Of course, you did not pass on these Chinese characters, but the type cast did it for you !!! <br>  And therefore it is very important to know that casting will not work.  So to initialize the first line, you must do the following: <br><pre> <code class="cpp hljs">TCHAR name[] = _T(<span class="hljs-string"><span class="hljs-string">"Saturn"</span></span>);</code> </pre><br><br>  Which will translate to 7 or 14 bytes, depending on the compilation. <br>  The wcslen call should be like this: <br><pre> <code class="cpp hljs">wcslen(<span class="hljs-string"><span class="hljs-string">L"Saturn"</span></span>);</code> </pre><br><br>  In the sample program code above, I used strlen, which causes errors when building Unicode. <br>  I will give an example of a non-working solution with the casting of C types: <br><pre> <code class="cpp hljs">lLen = <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>*)name);</code> </pre><br><br>  On Unicode assemblies, the name variable will be 14 bytes in size (7 unicode characters, including null).  Since the string <br>  ‚ÄúSaturn‚Äù contains only English characters that can be represented using ASCII encoding, the Unicode character 'S' will be represented as [83, 0].  The following ASCII characters will be represented as zeros.  Notice now the character 'S' is represented as a 2-byte value of 83. The end of the line will be represented as 2 bytes having a value of 0. <br><br>  So, when you pass such a string to strlen, the first character (that is, the first byte) will be correct ('S' in the case of 'Saturn').  But the next character / byte will be identified as the end of the line.  Therefore, strlen returns an invalid value of 1. <br><br>  As you know, the Unicode string can contain not only English characters, and the result of strlen will be even more uncertain. <br><br>  In short, type casting will not work. <br>  You will have to either present the lines in the correct form, or use the ANSI to Unicode conversion functions, and vice versa. <br><br><hr><br><br>  Now, I hope you understand the following code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">BOOL </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetCurrentDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( LPCTSTR lpPathName )</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">DWORD </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCurrentDirectory</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(DWORD nBufferLength,LPTSTR lpBuffer)</span></span></span></span>;</code> </pre><br><br>  Continuing the topic.  You've probably seen some functions / methods that need to pass the number of characters, or return the number of characters.  However, there is a GetCurrentDirectory to which the number of characters must be transferred, not the number of bytes. <br>  Example: <br><pre> <code class="cpp hljs">TCHAR sCurrentDir[<span class="hljs-number"><span class="hljs-number">255</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//  255   255*2 GetCurrentDirectory(sCurrentDir, 255);</span></span></code> </pre><br><br>  On the other hand, if you need to allocate memory for the desired number of characters, you must allocate the proper number of bytes.  In C ++, you can simply use the new operator: <br><br><pre> <code class="cpp hljs">LPTSTR pBuffer; <span class="hljs-comment"><span class="hljs-comment">// TCHAR* pBuffer = new TCHAR[128]; //  128  256 ,    .</span></span></code> </pre><br><br>  But if you use memory allocation functions such as malloc, LocalAlloc, GlobalAlloc, etc., you must specify the number of bytes! <br><br><pre> <code class="cpp hljs">pBuffer = (TCHAR*) <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> (<span class="hljs-number"><span class="hljs-number">128</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(TCHAR) );</code> </pre><br><br>  As you know, you need to cast the return type.  The expression in the malloc argument ensures that it allocates the required number of bytes - and allocates space for the required number of characters. <br><br><h5>  PS </h5><br>  <a href="http://www.codeproject.com/Articles/76252/What-are-TCHAR-WCHAR-LPSTR-LPWSTR-LPCTSTR-etc">Original article</a> <br><br>  All with NG !!! </div><p>Source: <a href="https://habr.com/ru/post/164193/">https://habr.com/ru/post/164193/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../164177/index.html">One small optimization</a></li>
<li><a href="../164181/index.html">JOBS Act promises explosive growth for IT companies in the US</a></li>
<li><a href="../164183/index.html">Happy New Year</a></li>
<li><a href="../164185/index.html">What is not written in Wikipedia on global navigation satellite systems</a></li>
<li><a href="../164191/index.html">A set of useful tools for working with DNS</a></li>
<li><a href="../164195/index.html">How to do without dyndns</a></li>
<li><a href="../164197/index.html">Go to Puppet or how not to spoil the soup</a></li>
<li><a href="../164201/index.html">Hackathon through the eyes of the participant and the winner</a></li>
<li><a href="../164203/index.html">Diameter. The basic protocol. Part 1</a></li>
<li><a href="../164205/index.html">ION Piano Apprentice - controller for Garage Band</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>