<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Gitlab flow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a translation of a fairly important article about GitLab Flow, an alternative to Git flow and GitHub flow. The article was written in 2014, so...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Gitlab flow</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>This is a translation of a fairly important article about GitLab Flow, an alternative to Git flow and GitHub flow.</em>  <em>The article was written in 2014, so the screenshots have become outdated.</em>  <em>Nevertheless, the article itself is more than relevant:</em> </p><br><hr><br><p>  Branching and merging branches in git is much simpler than in earlier version control systems, such as SVN.  Therefore, there are many ways to organize team work on code, and most of them are good enough.  At the very least, they offer many advantages over what happened before git.  But git itself is not a silver bullet, and in many teams the organization of the workflow with git has a number of problems: </p><br><ul><li>  The entire workflow is not described in a precise way. </li><li>  Making unnecessary complexity </li><li>  There is no connection with the tracker of tasks (issue tracker). </li></ul><br><p>  We want to introduce you to GitLab flow - a well-defined set of practices that solves these problems.  It integrates into one system: </p><br><ul><li>  <a href="https://ru.wikipedia.org/wiki/Feature_driven_development">Feature Driven Development</a> , </li><li>  Use of <a href="http://martinfowler.com/bliki/FeatureBranch.html">feature-branches (feature branches)</a> , </li><li>  Task tracker. </li></ul><br><a name="habracut"></a><br><p>  This article describes all aspects of GitLab flow, including branching, task integration, continuous integration, and deployment.  Its goal is to help new teams switch to git and immediately implement simple, transparent and effective rules for working with it. </p><br><p><img src="https://docs.gitlab.com/ee/workflow/four_stages.png" alt="Four stages (working copy, index, local repo, remote repo) and"></p><br><p>  In most version control systems, in order to share code with colleagues, you need to do one action - commit to the repository.  In git, the same thing happens in three steps: </p><br><ol><li>  Add changes from the project workspace to the index (prepared files area, staging area); </li><li>  Make a commit based on the index; </li><li>  Push commit to remote repository. </li></ol><br><p>  Mastering these actions is the first step in learning git.  Next is the work with the branches. </p><br><p><img src="https://docs.gitlab.com/ee/workflow/messy_flow.png" alt="Multiple long running branches and merging in all directions"></p><br><p>  If you do not set any rules for working with branches, the entropy begins to grow in the repository: </p><br><ul><li>  There are many long-lived branches, </li><li>  The changes you make are smeared across different branches, </li><li>  It is not clear where to start developing a new feature or where to deploy the code for production. </li></ul><br><p>  To solve these problems, a standard work model is usually implemented, for example, <a href="http://nvie.com/posts/a-successful-git-branching-model/">git flow</a> or <a href="http://scottchacon.com/2011/08/31/github-flow.html">GitHub flow</a> .  We believe that all these models have the potential for improvement, so we developed the GitLab flow. </p><br><h2 id="git-flow-i-ego-ogranicheniya">  Git flow and its limitations </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/gitdashflow.png" alt="Git Flow timeline by Vincent Driessen, used with permission"></p><br><p> The Git flow workflow model was one of the first to emerge and became quite widely known.  It assumes the presence of a <code>master</code> branch, a branch for accumulated changes of <code>develop</code> , as well as separate branches for features, releases, and hotfixes.  Developed changes are merging into <code>develop</code> , from there to release branches, and as a result get into <code>master</code> .  Git flow is quite detailed and clearly defines the workflow, but its complexity creates two problems. </p><br><p>  First, developers should use the <code>develop</code> , not <code>master</code> branch, because the latter is reserved for release code.  This contradicts the usual practice of calling <code>master</code> main branch, from which other branches branch off, and into which the result is merged.  Often, developers mistakenly make some changes only in the <code>master</code> , forgetting to <code>develop</code> .  And the majority of graphical interfaces to git, by default, consider the master branch as the main branch, so they have to switch or configure something every time. </p><br><p>  Secondly, the extra complexity arises because of the release branches and hotfixes.  Most teams, especially small ones, can easily do without them.  Today, most organizations adhere to the practice of continuous delivery (continuous delivery), which assumes that the code from the main branch can be deployed to production. </p><br><p>  Therefore, you can exclude branches of releases and hotfixes and all the extra work that is required for them.  An example of such extra work is the reverse merge of the release branches in <code>master</code> .  To solve this problem, there are special tools, but they also require the study of documentation and only add complexity. </p><br><h2 id="github-flow--bolee-prostoy-variant">  GitHub flow is a simpler option. </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/github_flow.png" alt="Master branch with feature branches merged in"></p><br><p>  In contrast to the complex git flow model, the GitHub flow model was developed.  It has only <code>master</code> and feature branches.  This simplification led to the successful implementation of GitHub flow by many companies.  Atlassian has proposed a <a href="http://blogs.atlassian.com/2014/01/simple-git-workflow-simple/">similar strategy</a> .  But, unlike GitHub, they prefer to do a rebase (not a merge of the branches in the <code>master</code> . </p><br><p>  The merge of all changes to the <code>master</code> and the frequent deployment make it possible not to write code ‚Äúon the table‚Äù, but to immediately release the changes.  This is in line with the ideas of lean manufacturing and continuous delivery.  But a lot of questions remain unanswered: when exactly to deploy and in what environments, how to release releases, how to connect all this with the task tracker.  GitLab flow answers all these questions. </p><br><h2 id="gitlab-flow-vetka-production">  GitLab flow: production branch </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/production_branch.png" alt="Master branch and production branch"></p><br><p>  GitHub flow is built on the assumption that you can deploy your code to production at any time, immediately after the merge of the feature branch in the <code>master</code> .  This is true for SaaS applications, but is incorrect in many other cases.  It happens that you can not affect the exact time of release.  For example, you release an application for iOS and each update must be validated in the AppStore.  Another example is when you can release at a specific time (for example, from 10 to 16 on weekdays, when all employees are at work), but you can take a branch to <code>master</code> at any time. </p><br><p>  To control the release of code in production, GitLab flow suggests using a special branch, <code>production</code> .  Configure automatic deployment of code from this branch with each change in it.  Now for release it is enough to make merge from the <code>master</code> branch in <code>production</code> .  The status of the branch will give you exact information about which version of the code is now released, and the approximate release time can be determined by the time of the creation of the merge commit.  If you need absolute accuracy, you can create a new tag with the timestamp in the description during the deployment process. </p><br><h2 id="gitlab-flow-vetki-dlya-neskolkih-sred">  GitLab flow: branches for several environments </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/environment_branches.png" alt="Multiple branches with the code cascading from one to another"></p><br><p>  It may be useful to have a separate environment (environment) in which the deployment from the <code>master</code> branch occurs.  In this unique case, the name of the medium may differ from the name of the branch. </p><br><p>  Suppose you have several environments: staging, pre-production, and production.  The code from <code>master</code> automatically deployed to styling.  As soon as you are ready to deploy it to pre-production, you create a merge request from <code>master</code> to <code>pre-production</code> .  Accordingly, merge from <code>pre-production</code> to <code>production</code> means final release.  Such a process, when all commits pass through branches in a strictly defined order, ensures that the changes have been tested in all environments. </p><br><p>  If you need to quickly ‚Äúpush‚Äù a hotfix to the production, you can implement it in the usual feature-branch, and then open the merge-request to <code>master</code> without deleting the branch.  Now, if the code in the <code>master</code> passes the tests and is viable (correctly configured continuous delivery should guarantee this), you can hold the hotfix branch consistently in <code>pre-production</code> and <code>production</code> .  If the changes require additional testing, then instead of an immediate merge, you need to open merge-requests in the same branches.  In the ‚Äúextreme‚Äù case, a separate environment can be created for each branch.  This is done, for example, in <a href="https://teatro.io/">Teatro</a> . </p><br><h2 id="gitlab-flow-reliznye-vetki">  GitLab flow: release branches </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/release_branches.png" alt="Master-picks from master"></p><br><p>  You will need release branches only if you release software for external clients.  In this case, each minor version will be stored in a separate branch ( <code>2.3-stable</code> , <code>2.4-stable</code> , etc.). </p><br><p>  Stable (stable) branches should be created from the <code>master</code> branch.  They need to be created as late as possible to minimize the addition of hotfixes to several branches.  After the release branch is created, you can only include fixes for serious bugs.  Follow the "upstream first" rule: whenever possible, first make merge corrections to the <code>master</code> , and only from there - cherry-pick to the release branch.  Thanks to this rule, you will not forget to make cherry-pick patches in <code>master</code> and will not encounter the same bug in the next release.  The "upstream first" rule applies including in <a href="https://www.chromium.org/chromium-os/chromiumos-design-docs/upstream-first">Google</a> and <a href="https://www.redhat.com/about/news/archive/2013/5/a-community-for-using-openstack-with-red-hat-rdo">Red Hat</a> .  Every time a bug fix is ‚Äã‚Äãadded to the release branch, you need to increase the third number in the version number (according to the rules of <a href="http://semver.org/">semantic versioning</a> ).  Mark this version with a new git tag.  Some projects use the <code>stable</code> branch, which always points to the same commit as the last release.  The <code>production</code> branch (or <code>master</code> in git flow rules) is not needed in this case. </p><br><h2 id="gitlab-flow-merzhpull-rekvesty">  GitLab flow: merge / pull requests </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/mr_inline_comments.png" alt="Merge request with line comments"></p><br><p>  Merge-request or pull-request is created in the git-repository management system.  This is a request for merzh one branch to another, like a task assigned to any performer.  GitHub and Bitbucket use the term ‚Äúpull-requote‚Äù, because the first necessary action is to make a pull of the proposed branch.  GitLab and Gitorious use the term "merzh-request", because the final action is, in fact, merge branches.  Later in this article we will call this a merge request. </p><br><p>  If you are working on a branch for more than a couple of hours, it makes sense to share the intermediate result with your colleagues through a merge-request.  Do not assign it to anyone, but just mention (with the <code>/cc @</code> command) your colleagues in the request description or in the comment - they will receive a notification.  This will mean that the request is not ready for merge, but it is already possible to give feedback on it.  You can explicitly indicate that the work on the request is not completed.  To do this, start the request header with <code>[WIP]</code> or <code>WIP:</code> that is, "Work in progress".  Such a merge-request can not even be locked up via the GitLab interface (although you can still manually use git). </p><br><p>  The GitLab interface allows you to leave comments both to the request as a whole and to specific lines of code.  Thus, the Merge-Request already includes tools for reviewing the code, and you will not need any additional tools.  According to the results of the review, anyone can make edits with the following commit to the same branch (usually the author of the request makes it).  All subsequent commits started in the same branch are included in the merge-request, and the diff is updated automatically and works correctly even with <code>push -f</code> . </p><br><p>  When the feature is ready, and the branch can be merged, assign a request to someone who knows the project code well (and who has rights to the merge in the <code>master</code> ).  This person is responsible for the final review and decides whether to hold the result or close the request without merge. </p><br><p>  GitLab has a standard practice - to ‚Äúprotect‚Äù long-lived branches (such as <code>master</code> or <code>production</code> ).  Branch protection does not allow members with a Developer access level to <a href="http://docs.gitlab.com/ce/permissions/permissions.html">push any changes into it</a> . </p><br><p>  Therefore, for a merge to a protected branch, you need to open a merge-request assigned to a participant with a higher level of access. </p><br><h2 id="gitlab-flow-integraciya-s-zadachami-issues">  GitLab flow: integration with tasks (issues) </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/merge_request.png" alt="Merge request with the branch name 15-require-a-password-to-change-it and assignee field shown"></p><br><p>  GitLab flow allows you to explicitly link code and tasks from the tracker. </p><br><p>  Any significant changes in the code must be accompanied by a task in which the requirements and the meaning of the changes are formulated.  It helps to stay within the task, and also gives the team an idea of ‚Äã‚Äãwhat you are doing.  In GitLab, every change in the code base begins after the task is created in the tracker.  If the intended changes are at least somewhat serious (for example, they require more than an hour of work), then the work must begin with the formulation of the task.  Many teams already follow this rule, because they always estimate the time to complete a task before taking it to the sprint. </p><br><p>  Task headers should be formulated to describe the desired state of the system. </p><br><p>  A good example: "As an administrator, I want to be able to delete a user without errors." <br>  A bad example: "Admin can not delete users." </p><br><p>  Starting work on the task, create a new branch from the <code>master</code> branch.  Its name must begin with a ticket number, for example <code>42-admin-can-remove-users</code> . </p><br><p>  When you have completed the task or want to receive an intermediate feedback, open the merge-request.  Remember to be able to send an alert ( <code>/cc @</code> ) to colleagues and mark <code>WIP:</code> </p><br><p>  At the moment when you consider that the work is completed, assign a request to the reviewer and remove the <code>WIP:</code> </p><br><p>  The reviewer can accept (detain) the request both via the command line and through the button in the request interface.  Clicking on the button automatically creates a merge commit, the description of which is formed on the basis of the request description.  A merge commit is useful in that it saves the time and circumstances of merge in history.  Therefore, by default, a commit is always created, even if a "fast-forward merge" was possible, when the <code>master</code> simply switches to the last commit of your branch.  In git, this strategy is called "no fast-forward" and is used with the <code>git merge --no-ff</code> command.  GitLab EE and .com offer a choice of behavior for Merzh, details later in the article. </p><br><p>  The feature branch is usually no longer needed after merge, so the request interface allows you to delete it.  Suppose that the branch was frozen, after which you discovered some flaws and rediscovered the task.  If the old branch is deleted, you can create a new branch with the same name and continue development in it.  As a rule, one task corresponds to no more than one branch, but several tasks can be solved in one branch. </p><br><h2 id="svyazyvanie-zadach-i-merzh-rekvestov">  Binding tasks and merge-requests </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/close_issue_mr.png" alt="Merge request"></p><br><p>  In a commit message, or in the description of a merge request, you can mention the task by its number, using a trigger word, for example: <code>fixes #14</code> , <code>closes #67</code> .  In this case, GitLab publishes a comment in the mentioned task with a reverse link to the commit or request.  And in the merge-request a list of related tasks appears.  When you take the code to the main branch, the associated tasks will be marked as completed.  Please note: triggers are recognized only in English, that is, <code>fixes #14</code> will work, and <code>fixes #14</code> will not. </p><br><p>  If you want to create a link to the task, but do not close it, just write its number: "Duck typing is preferred. # 12". </p><br><p>  If a task covers several repositories, it is best to create the main task in one repository and link separate tasks to it in other repositories. </p><br><h2 id="rebase-i-obedinenie-kommitov">  Rebase and commit committing </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/rebase.png" alt="Vim screen showing the rebase view"></p><br><p>  Git allows you to merge (squash) several commits into one or change their order using the <code>rebase -i</code> command.  In GitLab EE and .com, you can <a href="http://docs.gitlab.com/ee/workflow/rebase_before_merge.html">do this directly before merge</a> through the web interface.  It makes sense if you made several small commits in the process of work, but you want to get one into <code>master</code> , or if you want to build commits in a logical order. </p><br><p>  Remember that commits that are already in the remote repository and, moreover, in a stable branch, cannot be re-booted.  The reason for this is that something could leave a link to them or pull (cherry-pick) into its branch.  Rebeyz changes identifiers (SHA-1) commits, because it actually creates new commits from them.  As a result, your changes appear in git history with several different identifiers, which leads to confusion and errors.  Rebeyz also makes it difficult to review the code, because information is lost about what changes were made after the review.  If commits of different authors are combined, then the information about authorship will also be lost.  This deprives the authors of an indication of their authorship, but also hinders the work of <code>git blame</code> (it shows in which commit and by whom each row was changed). </p><br><p>  Regularly doing commits and pushing them to a remote repository is a good practice that allows colleagues to see what you are working on.  But with this approach, one task is spread over many commits, so the development history becomes quite difficult to view.  These small commits could be merged into one, but this will lead to the loss of identifiers.  Instead, you can view the history on merge commits: they always explain the essence of the changes and indicate the moment of the merge of the whole branch. </p><br><p>  Changes that have already entered the <code>master</code> cannot be erased from the history and it is not so easy to undo with <code>git revert</code> .  If all the commits were merged into one with a <code>rebase</code> , you can <code>revert</code> to that single commit.  However, we are convinced that merging commits does more harm than good.  Fortunately, git can <a href="https://git-scm.com/blog/2010/03/02/undoing-merges.html">cancel merge commits</a> .  If you change your mind and want to return the canceled merge commit, then apply <code>revert</code> to the commit created as a result of the first <code>revert</code> .  Git will not let you commit the same commit twice anyway. </p><br><p>  To make this possible, you must first create this merge commit.  Therefore, if you manually add the option <code>--no-ff</code> .  The repository management system will do it for you at the time of the Merge-Requests. </p><br><h2 id="ne-menyayte-poryadok-kommitov-s-pomoschyu-rebase">  Do not change the order of commits using rebase </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/merge_commits.png" alt="List of sequential merge commits"></p><br><p>  Git allows you to rebuy feature-branches to <code>master</code> , as a result of which this branch‚Äôs commits appear in the history after commits to <code>master</code> .  This allows you to make merge without merge commit and as a result you get a simple linear history.  But the same rule applies here as with the merging of commits: don‚Äôt touch what has already got into the remote repository.  We recommend that you do not even re-intermediate the interim results of your work, which were submitted for review via merge-requisition. </p><br><p>  Using <code>rebase</code> <a href="https://blogs.atlassian.com/2013/10/git-team-workflows-merge-or-rebase/">causes you to repeatedly resolve the same conflicts</a> .  In some cases, this can be done with the <code>git rerere</code> (reuse recorded resolutions).  But it is even easier - not to re-raise at all and to resolve conflicts only once, with merge.  The less you encounter any merger conflicts, the better. </p><br><p>  In order to avoid unnecessary conflicts, you should not overload the <code>master</code> in the feature branch too often.  Let's look at the three possible causes of <code>master</code> merge elsewhere: ‚Äúcode pulling‚Äù (leveraging code), merge conflicts, and long-lived branches. </p><br><p>  If you need to ‚Äúpull up‚Äù changes from the <code>master</code> to the feature-branch, you can usually get away with pulling (cherry-pick) of one desired commit. </p><br><p>  A conflict with a feature-merge merge is usually resolved by creating a merge commit.  If the lines of your file can be in random order, then some conflicts can be avoided by setting <a href="http://git-scm.com/docs/gitattributes">gitattributes</a> .  For example, in the <code>.gitattributes</code> file of the <code>.gitattributes</code> repository there is the line <code>CHANGELOG merge=union</code> , and this allows you to merge changes automatically. </p><br><p>  The last situation when it is necessary to <code>master</code> somewhere else is the use of long-lived branches, which periodically need to be updated to the current state.  Martin Fowler, in <a href="http://martinfowler.com/bliki/FeatureBranch.html">his article on feature-branches,</a> discusses the practice of continuous integration (CI).  We in GitLab confuse CI with testing branches a bit. </p><br><p>  To quote Fowler: ‚ÄúI know people who claim to practice CI because they build every branch and every commit and can even use a CI server. What they do is called continuous building. it is also a noble cause, but there is no integration, which means that there is no ‚Äúcontinuous integration‚Äù. " </p><br><p>  The solution is that feature branches should exist for a short time and quickly merge.  You can focus on the period of one working day.  If the developer keeps the branch for the implementation of the task for more than one day, think about splitting the task into smaller parts.  Alternatively, <a href="http://martinfowler.com/bliki/FeatureToggle.html">feature toggles</a> can be used. </p><br><p>  There are two strategies for working with long-lived branches: </p><br><ul><li>  The continuous integration strategy assumes that you merge <code>master</code> into a long-lived branch at the beginning of each day, <br>  to prevent more complicated mergies in the future. </li><li>  The synchronization point strategy (synchronization point strategy) allows merging only strictly defined commits, <br>  for example, tagged releases.  Linus Torvalds <a href="https://www.mail-archive.com/dri-devel%40lists.sourceforge.net/msg39091.html">recommends this way</a> , because the code of the release versions is better studied. </li></ul><br><p>  GitLab EE offers the opportunity to rebase immediately before accepting a merge-request.        ,  <code>Merge Requests Rebase</code> . </p><br><p><img src="https://docs.gitlab.com/ee/workflow/merge_request_settings.png" alt="Merge request settings"></p><br><p>   -   <code>rebase before merge</code> . </p><br><p><img src="https://docs.gitlab.com/ee/workflow/merge_request_widget.png" alt="Merge request widget"></p><br><p> GitLab   rebase  .  rebase   ,    . </p><br><p>      :    -,     .     ,      .         . ,       ‚Äî .     ,         ,        ,    . </p><br><h2 id="ispolzuyte-emodzi-v-zadachah-i-merzh-rekvestah">      - </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/award_emoji.png" alt="Emoji bar in GitLab"></p><br><p>   ‚Äî        +1  -1. <br>  GitLab    , , , ¬´ ¬ª     -. </p><br><h2 id="push-i-udalenie-vetok">     </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/remove_checkbox.png" alt="Remove checkbox for branch in merge requests"></p><br><p>         ,        .      ,   -       . ,    ‚Äî        .      ,        . </p><br><p>     <code>master</code> ,     .  GitLab           .  ,        ,    ,     .           .  ,            -. </p><br><h2 id="delayte-kommity-chasto-i-pishite-k-nim-korrektnye-soobscheniya">          </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/good_commit.png" alt="Good and bad commit message"></p><br><p>            .  ,            ,   .     ,        ,        .       SVN,      ,    .    ,  /-,   . </p><br><p>      ,      ‚Äî     .  ,     . </p><br><p>   : ¬´ ,    ¬ª. </p><br><p>    ,      : ¬´¬ª, ¬´¬ª, ¬´¬ª  ..  ¬´¬ª, ¬´¬ª    ,      "fix" (  )        .     ,    <a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">   Tim Pope</a> . </p><br><h2 id="testirovanie-pered-merzhem">    </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/ci_mr.png" alt="Merge requests showing the test states, red, yellow and green"></p><br><p>         (CI server),  ,      <code>master</code> .       ,    <code>master</code> .  GitLab flow      <code>master</code> ,      ¬´¬ª.   -  ,   .  CI,   GitLab CI  Travis,     (build)   -. </p><br><p>      ,   ,     .      ,     .     ,      ,   <code>master</code>   .    ,   <code>master</code> ,    ,       ,   . </p><br><p>         ,      ,   .   - ,    <code>master</code>  feature- (.. ),     CI     .  feature-  ,   ,       . </p><br><h2 id="merzh-chuzhogo-koda-v-vash-kod">       </h2><br><p><img src="https://docs.gitlab.com/ee/workflow/git_pull.png" alt="Shell output showing git pull output"></p><br><p>     ,   feature-     <code>master</code> .         ,    .       ,       -.         ,     <code>master</code>   .        feature-,      .    <a href="https://lwn.net/Articles/328438/">     feature-,    </a> . </p><br><h2 id="ssylki">  Links </h2><br><ul><li> <a href="http://nvie.com/posts/a-successful-git-branching-model/">Git Flow,  Vincent Driessen</a> </li><li> <a href="https://about.gitlab.com/2014/09/29/gitlab-flow/">    GitLab</a> </li></ul><br><p>     <a href="https://habrahabr.ru/users/nick_volynkin/" class="user_link">nick_volynkin</a>      ¬´  ¬ª, <a href="http://nadmosq.ru/">http://nadmosq.ru</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/316686/">https://habr.com/ru/post/316686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316676/index.html">Front-end and ad blockers (for example, Adblock Plus)</a></li>
<li><a href="../316678/index.html">AngelList crowdfunding platform and Product Hunt platform create a single ecosystem for IT startups</a></li>
<li><a href="../316680/index.html">Web technologies for designers - why and how</a></li>
<li><a href="../316682/index.html">Interview with the designer: Olga Romanova</a></li>
<li><a href="../316684/index.html">Speak the word about Brave React</a></li>
<li><a href="../316688/index.html">‚ÄúDemand for Visual Studio for Mac is big‚Äù - an interview with Alex Thissen</a></li>
<li><a href="../316690/index.html">How IT professionals work. Andrei Shorin, Deputy Director of Operations HeadHunter</a></li>
<li><a href="../316692/index.html">Monolithic Message-Oriented Application (MMOA)</a></li>
<li><a href="../316698/index.html">VKontakte will sell advertising under the new scheme and share revenue with community owners.</a></li>
<li><a href="../316700/index.html">KitchenCI + Ansible for Windows and Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>