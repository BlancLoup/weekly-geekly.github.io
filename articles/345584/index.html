<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Computer response time: 1977‚àí2017</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have an oppressive feeling that modern computers feel slower than the computers I used in childhood. I do not trust this kind of sensation, because ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Computer response time: 1977‚àí2017</h1><div class="post__text post__text-html js-mediator-article">  I have an oppressive feeling that modern computers feel slower than the computers I used in childhood.  I do not trust this kind of sensation, because human perception has proven to be unreliable in empirical research, so I took a high-speed camera and measured the response time of devices that came to me in the last few months.  Here are the results: <br><br><table><tbody><tr><th>  Computer </th><th>  Response <br>  (ms) </th><th>  Year </th><th>  Clock <br>  frequency </th><th>  Qty <br>  transistors </th></tr><tr><td>  Apple 2e </td><td>  thirty </td><td>  1983 </td><td>  1 MHz </td><td>  3,5 thousand </td></tr><tr><td>  TI 99 / 4A </td><td>  40 </td><td>  1981 </td><td>  3 MHz </td><td>  8 thousand </td></tr><tr><td>  Haswell-E <i>165 Hz</i> </td><td>  50 </td><td>  2014 </td><td>  3.5 GHz </td><td>  2 billion </td></tr><tr><td>  Commodore Pet 4016 </td><td>  60 </td><td>  1977 </td><td>  1 MHz </td><td>  3,5 thousand </td></tr><tr><td>  SGI Indy </td><td>  60 </td><td>  1993 </td><td>  0.1 GHz </td><td>  1.2 million </td></tr><tr><td>  Haswell-E <i>120 Hz</i> </td><td>  60 </td><td>  2014 </td><td>  3.5 GHz </td><td>  2 billion </td></tr><tr><td>  ThinkPad 13 <b>ChromeOS</b> </td><td>  70 </td><td>  2017 </td><td>  2.3 GHz </td><td>  1 billion </td></tr><tr><td>  iMac G4 <b>OS 9</b> </td><td>  70 </td><td>  2002 </td><td>  0.8 GHz </td><td>  11 million </td></tr><tr><td>  Haswell-E <i>60 Hz</i> </td><td>  80 </td><td>  2014 </td><td>  3.5 GHz </td><td>  2 billion </td></tr><tr><td>  Mac color classic </td><td>  90 </td><td>  1993 </td><td>  16 MHz </td><td>  273 thousand </td></tr><tr><td>  PowerSpec G405 <b>Linux</b> <i>60Hz</i> </td><td>  90 </td><td>  2017 </td><td>  4.2 GHz </td><td>  2 billion </td></tr><tr><td>  MacBook Pro 2014 </td><td>  100 </td><td>  2014 </td><td>  2.6 GHz </td><td>  700 million </td></tr><tr><td>  ThinkPad 13 <b>Linux chroot</b> </td><td>  100 </td><td>  2017 </td><td>  2.3 GHz </td><td>  1 billion </td></tr><tr><td>  Lenovo X1 Carbon 4G <b>Linux</b> </td><td>  110 </td><td>  2016 </td><td>  2.6 GHz </td><td>  1 billion </td></tr><tr><td>  iMac G4 <b>OS X</b> </td><td>  120 </td><td>  2002 </td><td>  0.8 GHz </td><td>  11 million </td></tr><tr><td>  Haswell-E <i>24 Hz</i> </td><td>  140 </td><td>  2014 </td><td>  3.5 GHz </td><td>  2 billion </td></tr><tr><td>  Lenovo X1 Carbon 4G <b>Win</b> </td><td>  150 </td><td>  2016 </td><td>  2.6 GHz </td><td>  1 billion </td></tr><tr><td>  Next Cube </td><td>  150 </td><td>  1988 </td><td>  25 MHz </td><td>  1.2 million </td></tr><tr><td>  PowerSpec G405 <b>Linux</b> </td><td>  170 </td><td>  2017 </td><td>  4.2 GHz </td><td>  2 billion </td></tr><tr><td>  Package around the world </td><td>  190 </td></tr><tr><td>  PowerSpec G405 <b>Win</b> </td><td>  200 </td><td>  2017 </td><td>  4.2 GHz </td><td>  2 billion </td></tr><tr><td>  Symbolics 3620 </td><td>  300 </td><td>  1986 </td><td>  5 MHz </td><td>  390 thousand </td></tr></tbody></table><a name="habracut"></a>  These are the results of the measurement of the response between keystrokes and the display of the symbol in the console (see the appendix for more information).  Results are sorted from fastest to slowest.  When testing multiple operating systems on a single computer, the operating system is <b>bold</b> .  When testing different update frequencies on the same computer, they are <i>in italics</i> . <br><br>  The last two columns show the clock frequency and the number of transistors on the processor. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For reference, the transmission time of the packet across the globe over fiber from New York to New York via Tokyo and London is given. <br><br>  If you look at the results as a whole, the fastest are ancient machines.  Newer computers are found in all parts of the table.  Intricate modern gaming configurations with an unusually high refresh rate can almost compete with the machines of the late 70s and early 80s, but "ordinary" modern computers are not able to compete with computers 30-40 years old. <br><br>  You can still look at mobile devices.  In this case, measure the scrolling response in the browser: <br><br><table><tbody><tr><th width="300">  Device </th><th width="100">  Response (ms) </th><th width="100">  Year </th></tr><tr><td>  iPad Pro 10.5 "Pencil </td><td>  thirty </td><td>  2017 </td></tr><tr><td>  iPad Pro 10.5 " </td><td>  70 </td><td>  2017 </td></tr><tr><td>  iPhone 4S </td><td>  70 </td><td>  2011 </td></tr><tr><td>  iPhone 6S </td><td>  70 </td><td>  2015 </td></tr><tr><td>  iPhone 3GS </td><td>  70 </td><td>  2009 </td></tr><tr><td>  iPhone X </td><td>  80 </td><td>  2017 </td></tr><tr><td>  iPhone 7 </td><td>  80 </td><td>  2017 </td></tr><tr><td>  iPhone 6 </td><td>  80 </td><td>  2014 </td></tr><tr><td>  Gameboy color </td><td>  80 </td><td>  1989 </td></tr><tr><td>  iPhone 5 </td><td>  90 </td><td>  2012 </td></tr><tr><td>  Blackberry q10 </td><td>  100 </td><td>  2013 </td></tr><tr><td>  Huawei Honor 8 </td><td>  110 </td><td>  2016 </td></tr><tr><td>  Google Pixel 2 XL </td><td>  110 </td><td>  2017 </td></tr><tr><td>  Galaxy S7 </td><td>  120 </td><td>  2016 </td></tr><tr><td>  Galaxy Note 3 </td><td>  120 </td><td>  2016 </td></tr><tr><td>  Nexus 5X </td><td>  120 </td><td>  2015 </td></tr><tr><td>  Oneplus 3T </td><td>  130 </td><td>  2016 </td></tr><tr><td>  Blackberry key one </td><td>  130 </td><td>  2017 </td></tr><tr><td>  Moto E (2G) </td><td>  140 </td><td>  2015 </td></tr><tr><td>  Moto G4 Play </td><td>  140 </td><td>  2017 </td></tr><tr><td>  Moto G4 Plus </td><td>  140 </td><td>  2016 </td></tr><tr><td>  Google pixel </td><td>  140 </td><td>  2016 </td></tr><tr><td>  Samsung Galaxy Avant </td><td>  150 </td><td>  2014 </td></tr><tr><td>  Asus zenfone3 max </td><td>  150 </td><td>  2016 </td></tr><tr><td>  Sony Xperia Z5 Compact </td><td>  150 </td><td>  2015 </td></tr><tr><td>  HTC One M4 </td><td>  160 </td><td>  2013 </td></tr><tr><td>  Galaxy S4 Mini </td><td>  170 </td><td>  2013 </td></tr><tr><td>  LG K4 </td><td>  180 </td><td>  2016 </td></tr><tr><td>  Package </td><td>  190 </td></tr><tr><td>  HTC Rezound </td><td>  240 </td><td>  2011 </td></tr><tr><td>  Palm Pilot 1000 </td><td>  490 </td><td>  1996 </td></tr><tr><td>  Kindle paperwhite 3 </td><td>  630 </td><td>  2015 </td></tr><tr><td>  Kindle 4 </td><td>  860 </td><td>  2011 </td></tr></tbody></table><br>  As before, the results are sorted by response time from fastest to slowest. <br><br>  If we exclude the Gameboy Color, which is a different class of devices, then all the fastest devices are Apple phones or tablets.  Next in response time should be the BlackBerry Q10.  We do not have enough data to explain such an unusually high speed of the BlackBerry Q10 for non-Apple devices, but there is a plausible conjecture that this is due to the presence of physical buttons - it is easier for them to realize a faster response than for a touchscreen and a virtual keyboard.  The other two devices with physical buttons are Gameboy Color and Kindle 4. <br><br>  After the "iPhones" and devices with buttons in the table are a variety of Android devices of different years.  At the very bottom of the ancient Palm Pilot 1000 and a couple of e-books.  The inhibition of Palm is explained by the touchscreen and display from the era when the touchscreen technology provided much lower speed.  Kindle eBooks work on e-ink e-ink, which is much slower than displays in modern phones, so their backlog is not surprising. <br><br><h1>  Why is Apple 2e so fast? </h1><br>  The Apple 2 system greatly benefits modern computers (except the iPad Pro) in input and output speeds, since Apple 2 does not deal with context switching, buffers when switching different processes, etc. <br><br>  If you look at modern keyboards, data entry is usually scanned with a frequency from 100 Hz to 200 Hz (for example, <a href="https://github.com/benblazak/ergodox-firmware">Ergodox claims a frequency of 167 Hz</a> ).  For comparison, Apple 2e effectively scans input at a frequency of 556 Hz.  See appendix for more information. <br><br>  If you look at the other end of the I / O pipeline, on the display, here we can also find the source of the delay.  My display advertises a delay of 1 ms, but if you measure the real time from the beginning of the character output to the screen until it is fully displayed, then 10 ms can easily be there.  This effect manifests itself even on some displays with a high refresh rate, which are sold through advertising its supposedly fast response. <br><br>  At 144 Hz, each frame takes 7 ms.  Changing the picture on the screen causes an additional delay from 0 ms to 7 ms due to waiting for the border of the next frame before drawing it (on average, we expect half of the maximum delay, that is, 3.5 ms).  In addition, even though my home display claims a switching speed of 1 ms, it actually takes 10 ms to completely change the color from the moment this process starts.  If we add up the delay from waiting for the next frame with the delay of the real color change, then we get the expected delay of 7/2 + 10 = 13.5 ms. <br><br>  On older Apple 2e CRT monitors, we expect a delay of half the refresh rate of 60 Hz (16.7 ms / 2), that is, 8.3 ms.  Today, this result is hard to beat: the best ‚Äúgaming monitor‚Äù can reduce latency to about such values, but in terms of market share, such displays are installed on a very small number of systems, and even monitors that are advertised as fast are not always as such. <br><br><h1>  IOS rendering pipeline </h1><br>  If you look at all the processes between input and output, then to list the differences Apple 2e with modern computers will have to write a whole book.  To get a picture of what is happening on modern machines, here is a high-level sketch of what is happening on iOS, from iOS / UIKit engineer <a href="https://andymatuschak.org/">Andy Matuschak</a> , although he calls this description ‚Äúhis outdated memories of outdated information‚Äù: <br><br><ul><li>  Iron has a natural scanning frequency (for example, 120 Hz on the latest touch panels), so this adds a delay of up to 8 ms. </li><li>  Events enter the kernel through the firmware;  This is a relatively fast process, but system scheduling can add a couple of milliseconds here. </li><li> The kernel forwards these events to preferred subscribers (in this case, <code>backboardd</code> ) through the Mach port;  Here, additional shedding losses are likely. </li><li>  <code>backboardd</code> determines which processes should deliver these events;  it requires blocking in relation to the Window Server, which shares this information (again, access to the kernel, additional delay for scheduling). </li><li>  <code>backboardd</code> sends the event to the desired process;  additional delay on sheduling before processing. </li><li>  Events are removed from the queue in the main thread;  and there may be something else happening (for example, as a result of network activity or timer events), which may add a delay, depending on the activity. </li><li>  UIKit adds up to 1-2 ms per event handling, depending on the processor speed (CPU bound). </li><li>  The application decides what to do with the incoming event;  applications are poorly written, so it usually takes many milliseconds, then the results are assembled into an update (data-driven update) and sent to the rendering server via IPC. <br><ul><li>  If, as a result of event processing, the application requires a new video buffer in shared memory, which happens in any non-trivial situation, then another IPC data exchange with the rendering server takes place;  This is an additional delay for scheduling. </li><li>  (Trivial things are those that the rendering server can handle on their own, such as changing affine transformations or changing the color of layers; non-trivial include any text operations, most of the rasterization operations and vector operations). </li><li>  Updates of this kind often create a triple buffer: a GPU can use one buffer for the current rendering;  render server - another buffer for the queue for the next frame;  and the third to draw.  Here are additional locks (cross-processing);  additional data exchanges with the kernel. </li></ul></li><li>  The rendering server adds the received updates to the render tree (a few milliseconds) </li><li>  Every <code>N </code> , the rendering tree is flushed to the GPU, from which you want to fill the video buffer. <br><ul><li>  In reality, however, triple buffering of the screen buffer often occurs, for the reasons described above: drawing from the GPU in one buffer, and the other used for reading in the preparation of the next frame. </li></ul></li><li>  Every <code>N </code> this video buffer is replaced with another video buffer, and the display reads directly from this memory. <br><ul><li>  (These <code>N </code> not necessarily ideally combined with <code>N </code> in the previous step) </li></ul></li></ul><br>  Andy says that ‚Äúthe amount of <i>work</i> here is usually quite small.  A couple of milliseconds of CPU time.  The delay after pressing the keys occurs for the following reasons: " <br><br><ul><li>  periodic scans (input device, rendering server, display) are not perfectly combined with each other </li><li>  multiple transfers across process boundaries, each time with a probability of delay due to the processing of some extraneous event in the queue </li><li>  multiple locks, especially at process boundaries, require access to the kernel </li></ul><br>  For comparison, on Apple 2e there are practically no transfers, locks and process boundaries.  A very simple code that writes the result to the display memory works, and it is automatically displayed the next time the screen is updated. <br><br><h1>  Refresh rate and response time </h1><br>  One interesting thing about testing response time on computers is the effect of the screen refresh rate.  In the transition from 24 Hz to 165 Hz, we accelerate by 90 ms.  At 24 Hz, the display of each frame takes 41.67 ms, and at 165 Hz - 6.061 ms.  As we saw above, without buffering, the average delay when updating a frame would be 20.8 ms in the first case and 3.03 ms in the second (since we expect a frame to arrive at a random point, and the wait time is randomly distributed between 0 ms and the maximum wait time ), that is, the difference is about 18 ms.  But in reality, the difference is 90 ms, which implies a delay of <code>(90 ‚àí 18) / (41,67 ‚àí 6,061) = 2</code> frames from the buffer. <br><br>  If you plot response results with different screen refresh rates on the same machine (we don‚Äôt publish it here), it roughly coincides with the ‚Äúbest fit‚Äù curve, assuming that when running PowerShell on this machine, the delay is 2.5 frames, regardless of update frequency.  This allows you to assess what the delay is, if you put a display with an infinite refresh rate on a gaming computer with a short response time - it is expected to be around <code>140 ‚àí 2,5 * 41,67 = 36 </code> , it is almost as fast as on computers 70 and 80s. <br><br><h1>  Complexity </h1><br>  Almost every computer or mobile device today is slower than typical computers of the 70s and 80s.  Gaming desktops with low response time and iPad Pro can be compared with fast machines 30-40 years old, but most commercial models are not even close. <br><br>  If you try to determine the main reason for the increase in response time, then we can say that this is ‚Äúcomplexity‚Äù.  Of course, everyone knows that complexity is bad.  If during the last decade you have attended at least one unscientific or unincorporated technology conference, you have heard with a high probability at least one report that complexity is the main cause of all ills and how you should strive to reduce complexity. <br><br>  Unfortunately, it is much more difficult to do this in reality than to declare from the stage.  Difficulty often gives us certain benefits, directly or indirectly.  When we compare data entry with a modern keyboard and the Apple 2 keyboard, we see unnecessary delays in processing data from the keyboard with a powerful and resource-intensive processor, compared to specialized logic circuits for the keyboard, which are simpler and cheaper.  But the use of the processor makes it easy to customize the keyboard, and also transfers the problem of "programming" the keyboard from the hardware to software, which reduces the cost of production of keyboards.  A more expensive chip increases the cost of production, but taking into account all the costs of the design of these semi-handicraft small-scale keyboards, it looks as a whole that the savings from simple programming outweigh the additional costs. <br><br>  We see this kind of compromise at each stage of the pipeline.  The most striking comparison of the OS on a modern desktop with a cycle on Apple 2. Modern OS allows programmers to write standard code that will work simultaneously with other programs on the same machine, with a fairly reasonable overall performance, but we pay a huge price for this in increasing complexity, and the processes involved in multitasking easily lead to a significant increase in response time. <br><br>  Much of the complexity can be called <a href="http://wiki.c2.com/%3FAccidentalComplexity">random complexity</a> , but it is also present here mainly because of its convenience.  At each level, from the hardware architecture and syscall interface to the I / O framework, we are increasing the complexity, the lion‚Äôs share of which can be eliminated if we sit down and rewrite all the systems and their interfaces today.  But it is too inconvenient to reinvent the Universe to reduce complexity, and economic growth makes a profit, so we live with what we have. <br><br>  For these and other reasons, in practice, the problem of reduced productivity, which has arisen due to "excessive" complexity, is often solved by an even greater complication of the system.  In particular, those achievements that allowed us to get closer to the fastest cars 30-40 years old, were not obtained thanks to following the admonitions about reducing complexity, namely from the additional complication of systems. <br><br>  iPad Pro is a feat of modern engineering, where developers have increased the update rate on devices and input and output, as well as optimized software pipeline to eliminate unnecessary buffering.  Design and production of high-refresh screens that reduce response time is a nontrivially more difficult task in many ways, which were not necessary in the time of the archaic standard 60 Hz displays. <br><br>  In reality, this is common when trying to reduce latency.  The most popular trick for this is to add a cache, but adding a cache to the system increases its complexity.  For systems that generate new data and do not allow the use of cache, even more complex solutions are proposed.  As an example, <a href="https://en.wikipedia.org/wiki/RDMA_over_Converged_Ethernet">large-scale RoCE systems</a> can be cited.  They can reduce the delay in accessing remote data from milliseconds to microseconds, which opens the door to a new class of applications.  But this is done by increasing the complexity.  The development and competent optimization of the first large-scale RoCE systems took dozens of man-years and required tremendous operational support efforts. <br><br><h1>  Conclusion </h1><br>  It looks a bit paradoxical that a modern gaming machine that works 4000 times faster than Apple 2, where there are 500,000 times more transistors on a processor (and 2,000,000 times more transistors on a GPU) hardly produces the same response speed as Apple 2 - and then only in neatly written applications and only on the monitor with a triple update frequency compared to Apple 2. It is even more absurd that in the PowerSpec G405 with the default configuration - the fastest computer for single-threaded calculations until October 2017 - the delay from pressing keys to display n  and the screen (about one meter, maybe three meters of real cable) is longer than the transmission time of a package around the globe (26,000 km from New York via London to Tokyo and back to New York). <br><br>  On the other hand, we are clearly emerging from the dark times of huge delays - and today you can already assemble a computer or buy a tablet with a response time in the same range as standard machines in the 70s and 80s.  This is a bit like the dark times of screen resolutions and pixel sizes, when the CRT monitors of the 90s, until relatively recently, had better performance than standard LCD displays of desktop computers.  Nowadays, 4k displays have finally become common, and 8k displays have dropped to normal prices - this is no match for commercial CRT monitors.  I don‚Äôt know if the same progress will happen with the response time, but let's hope for it. <br><br><h1>  Other articles about measuring response </h1><br><ul><li>  <a href="https://danluu.com/term-latency/">Console response</a> </li><li>  <a href="https://habrahabr.ru/post/345776/">Keyboard response</a> </li><li>  <a href="https://danluu.com/keyboard-v-mouse/">Mouse response versus keyboard</a> (human factors, not device specifications) </li><li>  <a href="https://pavelfatin.com/typing-with-pleasure/">Editor's Response</a> (Pavel Fatin) </li><li>  <a href="http://www.lofibucket.com/articles/dwm_latency.html">Layout Delay in Windows 10</a> (Pekka Vaananen) </li><li>  <a href="http://blogs.valvesoftware.com/abrash/latency-the-sine-qua-non-of-ar-and-vr/">AR / VR Response</a> (Michael Abrasch) </li><li>  <a href="https://danluu.com/latency-mitigation/">Delay Mitigation Strategies</a> (John Carmack) </li></ul><br><h1>  Appendix: Why measure response time? </h1><br>  The response is very important!  In very simple tasks, <a href="https://pdfs.semanticscholar.org/386a/15fd85c162b8e4ebb6023acdce9df2bd43ee.pdf">people are able to distinguish response up to 2 ms or less</a> .  Moreover, the increase in latency is not only noticeable to users, but also <a href="http://www.tactuallabs.com/papers/howMuchFasterIsFastEnoughCHI15.pdf">causes less precise execution of simple tasks</a> .  If you want a visual demonstration of what the delay looks like, and you don‚Äôt have an old computer at hand, <a href="https://www.youtube.com/watch%3Fv%3DvOvQCPLkPt4">here‚Äôs the MSR demo on touchscreen delay</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/vOvQCPLkPt4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://stackoverflow.com/a/39187441/334816">Performance</a> also matters, but it is well understood and often measured.  If you go to almost any site with benchmarks or open a regular review, you will see a huge number of performance measurements, so additional measurements here have no special value. <br><br><h1>  Application: Apple 2 Keyboard </h1><br>  Instead of a programmable microcontroller, the Apple 2e uses a much simpler dedicated chip designed to read the keyboard, the AY 3600, to read keystrokes. The AY 3600 <a href="https://danluu.com/AY3600.pdf">documentation</a> specifies the scan time <code>(90 * 1/f)</code> and the time for the key to be pressed again is <code>strobe_delay</code> .  These parameters are set by several capacitors and a resistor of 47 pF, 100K ohms and 0.022 ŒºF.  If we insert these parameters into the formula from the AY3600 documentation, we get <code>f = 50 </code> , which gives a scan delay of 1.8 ms and a delay of a repeated key press of 6.8 ms (capacitors can degrade with time, so on our old Apple 2e real delays may be less), which gives a delay of 8.6 ms for the internal keyboard logic. <br><br>  If you compare with the keyboard at 167 Hz with <a href="https://www.arduino.cc/en/Tutorial/Debounce">two additional passes to determine repeated presses</a> , the equivalent parameter goes <code>3 * 6  = 18 </code> .  With a scanning frequency of 100 Hz, it turns out <code>3 * 10  = 30 </code> .  Scanning the keyboard in 18-30 ms with an additional delay for repeated pressing of the keys corresponds to <a href="https://habrahabr.ru/post/345776/">preliminary real measurements of the response time of the keyboards</a> . <br><br>  For reference, the Ergodox keyboard has a 16 MHz microcontroller with about 80 thousand transistors, and an Apple 2e computer has a 1 MHz central processor with 3,500 transistors. <br><br><h1>  Appendix: experimental setup </h1><br>  Most measurements were made on a 240 FPS camera (resolution of 4.167 ms).  Devices with response times shorter than 40 ms were re-measured by a 1000 FPS camera (1 ms resolution).  The results in the tables are the result of averaging over the result of several measurements and are rounded to ten to avoid the impression of false accuracy.  For desktops, the response time corresponds to the time from the start of the key movement until the end of the screen update.  Please note that this is different from most key-to-screen-update measurements that can be found on the Internet ‚Äî these benchmarks typically use settings that effectively eliminate any keyboard delay.  As a test from start to finish, this is realistic only if you have a telepathic connection with a computer (although in such measurements there is also a benefit - if you, as a programmer, need a reproducible benchmark, then it‚Äôs good to get rid of factors outside the test your control, but not for end users). <br><br>  People often advocate the measurement of one of the parameters: {pressing a key to the end, triggering a switch}.  In addition to convenience, there are no more specific reasons to measure any of this, but people often give out these results for the ‚Äúreal‚Äù work of the keyboard.  But they do not depend on the real time response of the switch.  The time between pressing and activation, as well as the time between the sensation of response and activation, is arbitrary and available for customization.  When the tester declares that this is a ‚Äúreal‚Äù user experience of keyboard operation, this generally means that the user does not understand the principles of keyboard operation.  Although this is possible, I see no reason to translate one particular misconception about the work of keyboards into a specific metric, where people violently advocate various misconceptions.  For more information on misconceptions regarding keyboards, see <a href="https://habrahabr.ru/post/345776/">this article with measurements of response time</a> . <br><br>  Another important difference is that the measurements were made with the settings as close as possible to the OS default settings, since approximately 0% of users change the display settings to reduce buffering, disable the linker, etc.  Waiting for the end of the screen update is also different from what is measured in most benchmarks - most believe that the update is ‚Äúcomplete‚Äù when any movement on the screen is recorded.  Waiting for completion of the update is similar to the ‚Äúvisual completion‚Äù time in the WebPagetest. <br><br>  The results on computers are obtained in the console ‚Äúby default‚Äù for this system (for example, PowerShell on Windows, LXTerminal on Lubuntu), which can easily mean a difference of 20-30 ms between fast and slow consoles.  Between measurements in the console and measuring the total time from beginning to end, the results in this article should be slower than in other articles on this topic (where time is often measured before the changes on the screen start in games). <br><br>  The basic result of the PowerSpec G405 is obtained on the integrated graphics (the car is sold without a video card), and the result from 60 Hz is obtained with a cheap video card. <br><br>  Results for mobile devices are obtained in the default browser after downloading the site <a href="https://danluu.com/">https://danluu.com</a> and measuring the delay from moving your finger to the first movement of the picture on the screen, which signals the start of scrolling.  In cases where such a test did not make sense (Kindle, Gameboy Color, etc.), other meaningful actions were performed on this platform (turning the page on the Kindle, pressing the joystick in the game for Gameboy Color, etc.).  Unlike measurements on a desktop or laptop, these measurements were before the first change on the screen to avoid many scrolling frames.  For ease of measurement, the finger initially touched the screen, and the timer turned on when it started moving (to avoid problems with determining the time when the finger touched the screen). <br><br>  In the case of "equal" results, the sorting order in the table was determined by the non-rounded delay time, but this should not be considered an important factor.  A difference of 10 ms should not be considered significant either. <br><br>  The Haswell-E car was tested and with the G-Sync option turned on - there was no noticeable difference.  The release year for this computer is set in some sense arbitrary, since the processor was released in 2014, and the display is newer (I think, until 2015, there was no 165 Hz display). <br><br>  The number of transistors on some modern machines is given approximately, because the exact numbers were not disclosed.  Feel free to let me know if you find a more accurate estimate! <br><br>  All results under Linux are made on the kernel <a href="https://lwn.net/SubscriberLink/741878/eb6c9d3913d7cb2b/">before KPTI</a> .  Perhaps KPTI will affect the delay. <br><br>  <i>Work is not finished yet.</i>  <i>I'm going to collect benchmarks from more old computers on my next visit to Seattle.</i>  <i>If you know about older computers that can be tested in the New York area (with original displays or something like that), let me know!</i>  <i>If you have a device that you are willing to donate for tests, you can send to my address:</i> <br><br>  Dan luu <br>  Recurse center <br>  455 Broadway, 2nd Floor <br>  New York, NY 10013 </div><p>Source: <a href="https://habr.com/ru/post/345584/">https://habr.com/ru/post/345584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../345570/index.html">Checklist of troubles that may occur when moving</a></li>
<li><a href="../345574/index.html">Tcl / Tk - creating extensions / packages based on dynamic libraries</a></li>
<li><a href="../345576/index.html">Developing AI for a turn-based game on Node.js (part 1)</a></li>
<li><a href="../345578/index.html">Bitcoin will not become new digital money: limited emission and money functions</a></li>
<li><a href="../345580/index.html">Build and heat applications in Kubernetes using dapp and GitLab CI</a></li>
<li><a href="../345586/index.html">Top 10 examples and anti-examples of developer-audience interaction: Part Two</a></li>
<li><a href="../345588/index.html">From the domination of dwarf Spitz to where a homebody wants to go for a walk (1.5 months in Spain)</a></li>
<li><a href="../345590/index.html">We write Twitter-bot, which predicts the course Bitcoin</a></li>
<li><a href="../345592/index.html">Club of creators of domestic design systems</a></li>
<li><a href="../345594/index.html">Small study: IT in SMB - USA vs Russia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>