<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Filling text templates with model-based data. Implementing on .NET using dynamic functions in bytecode (IL)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue 
 Recently, there was the task of mass mailing of letters, the text of which is formed on the basis of a template in which, in addition to st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Filling text templates with model-based data. Implementing on .NET using dynamic functions in bytecode (IL)</h1><div class="post__text post__text-html js-mediator-article"><h3>  Prologue </h3><br>  Recently, there was the task of mass mailing of letters, the text of which is formed on the basis of a template in which, in addition to static content, there is information about the recipient and fragments of text.  In my case, this is a template for automatically notifying subscribers about the publication of new articles; accordingly, there is an appeal to the addressee and a beautifully executed link to the publication. <br><br>  Immediately the question arose - how to implement it?  Various solutions came to mind, starting from setting certain constant values ‚Äã‚Äãin the template, which would be replaced by these models, and ending with full-fledged Razor views (the site is built on MVC 5). <br><br>  After a brief battle with myself, I came to the conclusion that it‚Äôs time to solve this fairly common task once and for all, and that its solution should not be very difficult (i.e. should not depend on libraries that are not part of the .NET Framework 4), but at the same time functional enough to solve the set task and to have a reserve for expandability. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article I will talk about a solution based on a byte-code generator that meets these requirements, and also comment on the most interesting code fragments. <br><br>  If you are only interested in the template engine, the links below are: <br><br>  Source codes of the template engine (Genesis.Patternizer) and the test console in the SourceForge project: <a href="https://sourceforge.net/projects/open-genesis/%3Fsource%3Dnavbar">https://sourceforge.net/projects/open-genesis/?source=navbar</a> <br>  Or in the archive in one file: <a href="http://sourceforge.net/projects/open-genesis/files/Patternizer.zip/download">Patternizer.zip</a> <br><br><a name="habracut"></a><br><br><h3>  Formulation of the problem </h3><br><br>  To begin with we will be defined with syntax.  Personally, I like the function string.Format, which is widely used for formatting simple values.  We use its syntax to denote the places where values ‚Äã‚Äãare inserted into the template: <br><br><pre><code class="hljs 1c">'{' &lt;&gt; [ ':' &lt;<span class="hljs-built_in"><span class="hljs-built_in"></span></span> &gt; ] [ '|' &lt;<span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span> &gt; ] '}'</code> </pre> <br><br>  Examples: {User.GetFIO ()}, {User.Name | user interface}, {User.Birthdate: dd.MM.yyyy}, {User.Score: 0.00 | nothing}. <br><br>  The default value will be substituted if the desired value is null (null) or absent altogether, i.e.  if the specified property / field / method is not found in the model.  For shielding braces we will use double braces (as in the function string.Format), for escaping characters in the format string and the default value - a slash. <br><br>  Here is an example of a ready-made template that will be used in the test example: <br><br><pre> <code class="hljs actionscript">, {User.GetFIO()|}!   ,   : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrintMyName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{{ Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"My name is {{0}}. I'm {{1}}."</span></span>, <span class="hljs-string"><span class="hljs-string">"{UserName|}"</span></span>, {User.Age:<span class="hljs-number"><span class="hljs-number">0</span></span>}); }}     {Now:dd MMMM yyyy}  {Now:HH:mm:ss}</code> </pre><br><br>  Initially, I assumed that the template would only support the public properties of the model, but during the development process we added support for the fields, as well as methods (with the possibility of passing arguments such as string, number, boolean type and null) and calls to an array of any dimension.  Those.  The following expression will also be a valid pattern: <br><br><pre> <code class="hljs pgsql"> : {<span class="hljs-keyword"><span class="hljs-keyword">User</span></span>.Account[<span class="hljs-number"><span class="hljs-number">0</span></span>].GetSomeArrayMethod("a", <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-number"><span class="hljs-number">8.5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)[<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>].Length:<span class="hljs-number"><span class="hljs-number">0000</span></span>|<span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>}</code> </pre> <br><br><h3>  Decision </h3><br><br><h4>  Parser </h4><br><br>  First you need to understand what to do with the text template.  Of course, you can analyze the pattern data, look up and substitute values ‚Äã‚Äãfor each model substitution call.  But this is a very slow way.  It will be much more effective to break the pattern into separate logical fragments (pattern elements) once and later to operate with these elements.  There are three obvious element types: a <u>string constant</u> (that part of the template that directly goes to the result unchanged), a <u>substitution</u> (what's inside the curly brackets) and a <u>comment</u> (this element is not implemented, but I suppose you understand what this is about ). <br><br>  Based on these arguments, we describe the base class for the template element: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public abstract class PatternElement { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public virtual int EstimatedLength { get { return 0; } } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public abstract string GetNullValue(); }</span></span></code> </pre><br><br>  The meaning of the EstimatedLength property and the GetNullValue () method will be explained below. <br><br>  Next, we will describe specific implementations - a string constant and a substitution (let's call it ‚Äúexpression‚Äù): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">StringConstantElement</span></span> : <span class="hljs-title"><span class="hljs-title">PatternElement</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EstimatedLength { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Value == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : Value.Length; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNullValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Value; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ExpressionElement</span></span> : <span class="hljs-title"><span class="hljs-title">PatternElement</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FormatString { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> DefaultValue { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> EstimatedLength { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Math.Max(<span class="hljs-number"><span class="hljs-number">20</span></span>, DefaultValue == <span class="hljs-literal"><span class="hljs-literal">null</span></span> ? <span class="hljs-number"><span class="hljs-number">0</span></span> : DefaultValue.Length); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetNullValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DefaultValue; } }</code> </pre><br><br>  We also describe the interface of the <b>IPatternParser</b> parser, which accepts a text pattern as input, and outputs a sequence of elements: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IPatternParser</span></span> { <span class="hljs-function"><span class="hljs-function">IEnumerable&lt;PatternElement&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pattern</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><br>  A parser based on curly brackets and let's call it <b>BracePatternParser</b> .  Having no great experience in writing parsers (and this is what parser actually does), I will not delve into its implementation. <br><br><div class="spoiler">  <b class="spoiler_title">BracePatternParser.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Genesis.Patternizer</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">      </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class BracePatternParser : IPatternParser { private object _lock = new object(); private HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment"> PATH_TERMINATOR_CHARS; private HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment"> FORMAT_TERMINATOR_CHARS; private HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment"> PATTERN_TERMINATOR_CHARS; private string pattern; //  private int length; //   private int length_1; //     private int index; //     private StringBuilder constantBuilder; private StringBuilder expressionBuilder; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public BracePatternParser() { PATH_TERMINATOR_CHARS = new HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment">(":|}".ToCharArray()); FORMAT_TERMINATOR_CHARS = new HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment">("|}".ToCharArray()); PATTERN_TERMINATOR_CHARS = new HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment">("}".ToCharArray()); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="chars"&gt;</span></span></span><span class="hljs-comment"> - </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> private string ParsePatternPath(HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment"> chars) { //    expressionBuilder.Clear(); Stack</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment"> brackets = new Stack</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment">(); bool ignoreBrackets = false; for (index++; index </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; length; index++) { char c = pattern[index]; if (c == '(') { brackets.Push(c); expressionBuilder.Append(c); } else if (c == ')') { if (brackets.Peek() == '(') { brackets.Pop(); } else { //   ignoreBrackets = true; } expressionBuilder.Append(c); } else if (c == '[') { brackets.Push(c); expressionBuilder.Append(c); } else if (c == ']') { if (brackets.Peek() == '[') { brackets.Pop(); } else { //   ignoreBrackets = true; } expressionBuilder.Append(c); } else if (chars.Contains(c) &amp;&amp; (ignoreBrackets || brackets.Count == 0)) { //   break; } else { expressionBuilder.Append(c); } } return expressionBuilder.Length == 0 ? null : expressionBuilder.ToString(); } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">     </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="chars"&gt;</span></span></span><span class="hljs-comment"> - </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> private string ParsePatternPart(HashSet</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;char&gt;</span></span></span><span class="hljs-comment"> chars) { //    expressionBuilder.Clear(); for (index++; index </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; length; index++) { char c = pattern[index]; if (c == '\\') { //     if (index &lt; length_1) { expressionBuilder.Append(pattern[++index]); } } else if (chars.Contains(c)) { //   break; } else { expressionBuilder.Append(c); } } return expressionBuilder.Length == 0 ? null : expressionBuilder.ToString(); } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> private ExpressionElement ParsePattern() { string path = ParsePatternPath(PATH_TERMINATOR_CHARS); if (path == null) { //   //      (}) for (; index </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; length; index++) { char c = pattern[index]; if (c == '\\') { index++; } else if (c == '}') { break; } } return null; } else { ExpressionElement element = new ExpressionElement(path); //    if (index &lt; length &amp;&amp; pattern[index] == ':') { //   element.FormatString = ParsePatternPart(FORMAT_TERMINATOR_CHARS); } if (index &lt; length &amp;&amp; pattern[index] == '|') { //    element.DefaultValue = ParsePatternPart(PATTERN_TERMINATOR_CHARS); } return element; } } /// &lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="pattern"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public IEnumerable</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PatternElement&gt;</span></span></span><span class="hljs-comment"> Parse(string pattern) { lock (_lock) { if (pattern == null) { //   yield break; } else if (string.IsNullOrWhiteSpace(pattern)) { yield return new StringConstantElement(pattern); yield break; } //   this.pattern = pattern; //   length = pattern.Length; length_1 = length - 1; index = 0; //  constantBuilder = new StringBuilder(); expressionBuilder = new StringBuilder(); //    for (; index </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; length; index++) { char c = pattern[index]; if (c == '{') { if (index &lt; length_1 &amp;&amp; pattern[index + 1] == c) { //   '{' constantBuilder.Append(c); index++; } else { //    if (constantBuilder.Length != 0) { yield return new StringConstantElement(constantBuilder.ToString()); //   constantBuilder.Clear(); } var patternElement = ParsePattern(); if (patternElement != null) { yield return patternElement; } } } else if (c == '}') { if (index &lt; length_1 &amp;&amp; pattern[index + 1] == c) { //   '}' constantBuilder.Append(c); index++; } else { //      ,     constantBuilder.Append(c); } } else { constantBuilder.Append(c); } } //    if (constantBuilder.Length != 0) { yield return new StringConstantElement(constantBuilder.ToString()); } //   this.pattern = null; constantBuilder = null; expressionBuilder = null; index = length = length_1 = 0; } } } }</span></span></span></span></code> </pre><br></div></div><br><br><h4>  Builder generator </h4><br><br>  The parser described above performs only part of the overall task.  It is not enough to get a set of template elements, we still need to process them.  To do this, we describe another interface that represents the main component of the system, the <b>IBuilderGenerator</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IBuilderGenerator</span></span> { <span class="hljs-function"><span class="hljs-function">Func&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function">, </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateBuilder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">List&lt;PatternElement&gt; pattern, Type modelType</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><br>  To achieve the highest performance, for each new type of model ( <u>modelType</u> ) we will create a new builder and write it into a hash.  The builder itself is a normal function, which takes an object (model) as input and the return string is a filled pattern.  The specific implementation of this interface will be given below, and before that we consider the last component of the system, which links everything together. <br><br><h4>  Template engine </h4><br><br>  The template engine itself is a class that binds the template, the parser and the builder.  Its code also does not represent anything super interesting. <br><br><div class="spoiler">  <b class="spoiler_title">Patternizator.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> BUILDER = System.Func&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Genesis.Patternizer</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> - </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class Patternizator { #region Declarations private PatternizatorOptions _options; //   private string _pattern; //  private List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PatternElement&gt;</span></span></span><span class="hljs-comment"> _elements; //   private Dictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, BUILDER&gt;</span></span></span><span class="hljs-comment"> _builders; //   #endregion #region Properties </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public string Pattern { get { return _pattern; } set { _pattern = value; PreparePattern(); } } #endregion #region Constructors </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public Patternizator() { _options = PatternizatorOptions.Default; _builders = new Dictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, BUILDER&gt;</span></span></span><span class="hljs-comment">(); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="pattern"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public Patternizator(string pattern) { _options = PatternizatorOptions.Default; Pattern = pattern; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="options"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public Patternizator(PatternizatorOptions options) { _options = options; _builders = new Dictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, BUILDER&gt;</span></span></span><span class="hljs-comment">(); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="pattern"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="options"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> public Patternizator(string pattern, PatternizatorOptions options) { _options = options; Pattern = pattern; } #endregion #region Private methods </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void PreparePattern() { //   _elements = _options.Parser.Parse(_pattern).ToList(); //    _builders = new Dictionary</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Type, BUILDER&gt;</span></span></span><span class="hljs-comment">(); //             //string template = string.Join(Environment.NewLine, _elements.Select(e =&gt; System.Text.RegularExpressions.Regex.Replace(e.ToString(), @"\s+", " ").Trim()).ToArray()); } #endregion #region Public methods </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="model"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public string Generate(object model) { //       Type modelType = model == null ? null : model.GetType(); Type modelTypeKey = modelType ?? typeof(DBNull); //      BUILDER builder; if (!_builders.TryGetValue(modelTypeKey, out builder)) { //     builder = _options.BuilderGenerator.GenerateBuilder(_elements, modelType); _builders.Add(modelTypeKey, builder); } //   return builder(model); } #endregion } }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">PatternizatorOptions.cs</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Genesis.Patternizer</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public class PatternizatorOptions { </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public IPatternParser Parser { get; set; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public IBuilderGenerator BuilderGenerator { get; set; } #region Default private static PatternizatorOptions _default; </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public static PatternizatorOptions Default { get { if (_default == null) { _default = new PatternizatorOptions { Parser = new BracePatternParser(), BuilderGenerator = new ReflectionBuilderGenerator(), }; } return _default; } } #endregion } }</span></span></code> </pre><br></div></div><br>  Options ( <b>PatternizatorOptions</b> ) is an optional argument in which you can instruct the template engine to use a specific implementation of the parser or generator of the builder, for example, if you use a template syntax that is different from the standard one. <br><br>  An example of using a template engine in the standard version: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   string pattern = GetPattern(); //   Patternizator patternizator = new Patternizator(pattern); //   User user = new User { Surname = RandomElement(rnd, SURNAMES), Name = RandomElement(rnd, NAMES), Patronymic = RandomElement(rnd, PATRONYMICS), //   1950 - 1990  Birthdate = new DateTime(1950, 1, 1).AddDays(rnd.NextDouble() * 40.0 * 365.25) }; var model = new { User = user, UserName = user.Name, Now = DateTime.Now, }; //     string text = patternizator.Generate(model);</span></span></code> </pre><br><br>  In this example, the model is an anonymous type, but you should not be confused.  Even when generating elements of this type in a loop, the builder will be created only once, when you first call the Generate method.  But let's return to the issue of performance at the end of the article, but now we will consider the most interesting, so to speak, the highlight of this publication. <br><br><h4>  Bytecode builder generator </h4><br><br>  To begin, we will make a small analysis.  How can this problem be solved in theory? <br>  Let me remind you that we have a list of template elements (constants and expressions) and model type.  And we need to get the function <b>Func &lt;object, string&gt;</b> , which substitutes the model of the specified type in the template, receiving the output string. <br><br>  If there are no questions with constants (we just throw them in StringBuilder), then with expressions everything is more complicated. <br>  I see three possible options for how to get the value of an expression from a model: <br><br><ol><li>  Through reflection </li><li>  Generate C # code, compile and link to build </li><li>  Write a dynamic function ( <b>System.Reflection.Emit.DynamicMethod</b> ) with a body bytecode </li></ol><br><br>  The first option clearly suffers from speed, because  reflection always works slowly.  My advice to you is to never use reflection for operations that are performed very often.  The best way to use it is to prepare at the start of the program, i.e.  something like ‚Äúwe ran through the classes, found the necessary information in the attributes, built some kind of connections (delegates, events) and then used them without resorting to reflection again‚Äù.  In general, reflection is clearly not suitable for this task. <br><br>  The second option is very good, initially I wanted to use it.  The code of the builder function would look something like this (for the template given at the beginning): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (input == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    return @", !   ,   : function PrintMyName() { Console.WriteLine("My name is {0}. I'm {1}.", "", 0); }      "; } else { Model model = input as Model; StringBuilder sb = new StringBuilder(); sb.Append(", "); //   if (model.User != null) { var m_GetFIO = model.User.GetFIO(); if (m_GetFIO != null) { sb.Append(m_GetFIO); } else { sb.Append(""); //    } } else { sb.Append(""); //    } sb.Append("!\r\n  ,   :\r\n\r\n ..."); //   \\  .. return sb.ToString(); } }</span></span></code> </pre><br><br>  Of course, the code will be long enough, but who will see it?  In general, this option would be optimal if it were not for anonymous types.  In the code above, we would not be able to declare a model variable: <u>Model model = input as &lt;?&gt;;</u>  if the type of the model did not have a name. <br><br>  So, there is a third option.  Generate the same code directly in bytecode.  When writing a template engine, I myself used dynamic functions and a byte-code generator for the first time, and that was what prompted me to write this article so that you, dear readers, would have fewer problems when you decide to master this technology. <br><br>  Dynamic assemblies, dynamic functions, and a bytecode generator are described in the System.Reflection.Emit namespace, and you do not need to include any additional libraries to use them. <br><br>  The simplest dynamic function is created as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    var genMethod = new DynamicMethod("&lt; &gt;", typeof(&lt; &gt;), new Type[] { typeof(&lt;  1&gt;), typeof(&lt;  2&gt;), ..., typeof(&lt;  N&gt;) }, true); //   - (  IL-  CIL-) var cs = genMethod.GetILGenerator(); //    // ... //   cs.Emit(OpCodes.Ret); //     return genMethod.CreateDelegate(typeof(&lt; &gt;)) as &lt; &gt;;</span></span></code> </pre><br><br>  cs.Emit (OpCodes.Ret);  - this is a write operation command in bytecode.  Who does not know, <a href="https://ru.wikipedia.org/wiki/Common_Language_Runtime">bytecode</a> is something like an assembler for the languages ‚Äã‚Äãof the .NET family. <br><br>  If you have gathered strength and read the article before this paragraph, then you should have a question, how will I generate the byte code if I don‚Äôt know its commands?  The answer is quite simple.  To do this, we will need an additional program (the project is in the archive), the code of which is given under the spoiler. <br><br><div class="spoiler">  <b class="spoiler_title">ILDasm</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Diagnostics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ILDasm</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">region</span></span></span><span class="hljs-meta"> Static static void Main(string[] args) { new Program().Run(); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endregion</span></span></span><span class="hljs-meta"> public void Run() { string basePath = AppDomain.CurrentDomain.BaseDirectory; string exeName = Path.Combine(basePath, AppDomain.CurrentDomain.FriendlyName.Replace(".vshost", "")); Process.Start(@"C:\Program Files (x86)\Microsoft SDKs\Windows\v8.1A\bin\NETFX 4.5.1 Tools\x64\ildasm.exe", string.Format(@"/item:ILDasm.TestClass::DoIt ""{0}"" /text /output:code.il", exeName)); } } public class TestClass { public string DoIt(object value) { StringBuilder sb = new StringBuilder(); return sb.ToString(); } } }</span></span></code> </pre><br></div></div><br><br>  The meaning of the program is that it launches the <b>ildasm</b> disassembler built into the studio and sets it to the <b>DoIt</b> function of the <b>TestClass</b> class.  The byte code of the body of this function is placed in the code.il file, which can then be opened and analyzed.  I quote the byI-code of the DoIt function (too much removed): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0000</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">newobj</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">instance</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[mscorlib]</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">System</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Text</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.StringBuilder</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::.ctor()</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0005</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">stloc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0006</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldloc</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0007</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">callvirt</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">instance</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[mscorlib]</span></span><span class="hljs-selector-tag"><span class="hljs-selector-tag">System</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::ToString()</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_000c</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ret</span></span></code> </pre><br><br>  The substance in the skull box, combined with trial and error, will help generate the code by analogy, i.e.  Write the body of the DoIt function like what we want in our generated function, run the utility, look at the code and implement it in the generator. <br><br><h5>  General information about bytecode </h5><br><br>  Everything is built on the stack. <br>  If we want to perform addition operations <b>a</b> and <b>b</b> , we need to push the value of the variable <b>a</b> to the stack, then push the value of the variable <b>b</b> to the stack, then call the add command.  In this case, the stack is cleared of <b>a</b> and <b>b</b> , and the result of addition is placed on its top.  If after this we want to multiply the sum by <b>c</b> , put its value on the stack (remember, now there is already the sum <b>a + b</b> ) and call the multiplication operation (mul). <br><br>  Final bytecode: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0000</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldarg</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0001</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldarg</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0002</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">add</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0003</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">ldarg</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.3</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">IL_0004</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">mul</span></span></code> </pre><br><br>  And this is what it looks like in C #: <br><br><pre> <code class="cs hljs">cs.Emit(OpCodes.Ldarg_1); cs.Emit(OpCodes.Ldarg_2); cs.Emit(OpCodes.Add); cs.Emit(OpCodes.Ldarg_3); cs.Emit(OpCodes.Mul);</code> </pre><br><br>  Similarly, methods and constructors are called (put the arguments on the stack and call the method / constructor).  In this case, for non-static methods, the first thing to do is to put an instance of the class, the method of which we call. <br><br>  This article is not intended to complete the training byte-code generation, so we continue the reasoning about the generator. <br><br>  The generator core is enclosed in the function that implements its interface ( <b>IBuilderGenerator</b> ): <br><br><div class="spoiler">  <b class="spoiler_title">Generatebuilder</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">    </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="pattern"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="modelType"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;returns&gt;</span></span></span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/returns&gt;</span></span></span><span class="hljs-comment"> public virtual BUILDER GenerateBuilder(List</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;PatternElement&gt;</span></span></span><span class="hljs-comment"> pattern, Type modelType) { if (modelType == null) { //   ,     StringBuilder sb = new StringBuilder(); foreach (PatternElement item in pattern) { string nullValue = item.GetNullValue(); if (nullValue != null) { sb.Append(nullValue); } } string value = sb.ToString(); return (m) =&gt; value; } else { //      string methodName = "Generate_" + Guid.NewGuid().ToString().Replace("-", ""); //    var genMethod = new DynamicMethod(methodName, typeof(string), new Type[] { typeof(object) }, true); //    var cs = genMethod.GetILGenerator(); var sb = cs.DeclareLocal(typeof(StringBuilder)); var m = cs.DeclareLocal(modelType); ReflectionBuilderGeneratorContext context = new ReflectionBuilderGeneratorContext { Generator = cs, ModelType = modelType, VarSB = sb, VarModel = m, }; //   cs.Emit(OpCodes.Ldarg_0); cs.Emit(OpCodes.Isinst, modelType); cs.Emit(OpCodes.Stloc, m); //  StringBuilder      cs.Emit(OpCodes.Ldc_I4, pattern.Sum(e =&gt; e.EstimatedLength)); cs.Emit(OpCodes.Newobj, typeof(StringBuilder).GetConstructor(new Type[] { typeof(int) })); cs.Emit(OpCodes.Stloc, sb); foreach (PatternElement item in pattern) { MethodInfo processor; if (_dicProcessors.TryGetValue(item.GetType(), out processor)) { //   processor.Invoke(processor.IsStatic ? null : this, new object[] { context, item }); } } cs.Emit(OpCodes.Ldloc, sb); cs.Emit(OpCodes.Callvirt, typeof(object).GetMethod("ToString", Type.EmptyTypes)); cs.Emit(OpCodes.Ret); return genMethod.CreateDelegate(typeof(BUILDER)) as BUILDER; } }</span></span></code> </pre><br></div></div><br><br>  This is where the GetNullValue () method and the EstimatedLength property of the template element came in handy. <br><br>  A feature of the generator is its extensibility, because  it is not tied to the template element types described at the beginning - a string constant and expression.  If you wish, you can come up with your own elements and, by inheriting this generator, add functions responsible for generating bytecode for the element types you created.  To do this, in the code, you must describe a function with the <b>PatternElementAttribute</b> attribute, for example, the code generation for a string constant included in the standard generator implementation is described as follows: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">PatternElement(typeof(StringConstantElement))</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateStringConstantIL</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ReflectionBuilderGeneratorContext context, StringConstantElement element</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (element.Value != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { WriteSB_Constant(context, element.Value); } } <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   StringBuilder   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="context"&gt;</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;param name="value"&gt;</span></span></span><span class="hljs-comment">  </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/param&gt;</span></span></span><span class="hljs-comment"> protected virtual void WriteSB_Constant(ReflectionBuilderGeneratorContext context, string value) { if (value != null) { var cs = context.Generator; cs.Emit(OpCodes.Ldloc, context.VarSB); cs.Emit(OpCodes.Ldstr, value); cs.Emit(OpCodes.Callvirt, _dicStringBuilderAppend[typeof(string)]); cs.Emit(OpCodes.Pop); } }</span></span></code> </pre><br><br>  I will not give the code of other methods, since  it is very bulky, but if you have any questions, I will try to answer them separately. <br><br><h4>  Performance test </h4><br><br>  Since  I don't have the opportunity to compare my template with any other, I will make a comparison with a hard-coded template generator based on string.Replace (). <br><br><div class="spoiler">  <b class="spoiler_title">Test function code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">   </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> private void Run() { //   string outputPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Result"); if (!Directory.Exists(outputPath)) Directory.CreateDirectory(outputPath); Random rnd = new Random(0); Stopwatch sw = new Stopwatch(); //   string pattern = GetPattern(); //   string text; double patternTotal = 0; //      () double patternInitialization; //  () double patternFirst = 0; //   () double manualTotal = 0; //      () //   sw.Restart(); Patternizator patternizator = new Patternizator(pattern); sw.Stop(); patternInitialization = sw.Elapsed.TotalMilliseconds; Console.WriteLine(" {0} (v. {1})", patternizator.GetType().Assembly.GetName().Name, patternizator.GetType().Assembly.GetName().Version); //     for (int i = 0; i </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt; COUNT_PATTERNIZATOR; i++) { //   User user = new User { Surname = RandomElement(rnd, SURNAMES), Name = RandomElement(rnd, NAMES), Patronymic = RandomElement(rnd, PATRONYMICS), //   1950 - 1990  Birthdate = new DateTime(1950, 1, 1).AddDays(rnd.NextDouble() * 40.0 * 365.25) }; var model = new { User = user, UserName = user.Name, Now = DateTime.Now, }; //     sw.Restart(); text = patternizator.Generate(model); sw.Stop(); patternTotal += sw.Elapsed.TotalMilliseconds; if (i == 0) { patternFirst = sw.Elapsed.TotalMilliseconds; } //     if (i &lt; COUNT_MANUAL) { // !             //   -      Replace    sw.Restart(); { StringBuilder sb = new StringBuilder(pattern); DateTime now = DateTime.Now; sb.Replace("{User.GetFIO()|}", model.User.GetFIO() ?? ""); sb.Replace("{UserName|}", model.UserName ?? ""); sb.Replace("{User.Age:0}", model.User.Age.ToString("0")); sb.Replace("{Now:dd MMMM yyyy}", now.ToString("dd MMMM yyyy")); sb.Replace("{Now:HH:mm:ss}", now.ToString("HH:mm:ss")); text = sb.ToString(); } sw.Stop(); manualTotal += sw.Elapsed.TotalMilliseconds; } } WriteHeader(""); WriteElapsedTime(" ", patternInitialization); WriteElapsedTime("  ", patternFirst); Console.WriteLine(); WriteElapsedTime(string.Format("    {0} ", COUNT_PATTERNIZATOR), patternTotal); WriteElapsedTime("   ", patternTotal / COUNT_PATTERNIZATOR); WriteHeader(" ()"); WriteElapsedTime(string.Format("    {0} ", COUNT_MANUAL), manualTotal); WriteElapsedTime("   ", manualTotal / COUNT_MANUAL); Console.WriteLine(); Console.WriteLine("    ..."); Console.ReadKey(); }</span></span></span></span></code> </pre><br></div></div><br><br> : <br><img src="https://habrastorage.org/files/6d3/4f2/44a/6d34f244ae9a4608bc93cbf6d0721ba1.png"><br><br><h3>  Instead of conclusion </h3><br><br> ,    ,   ,   ,      .   ,     -     .        . <br><br><h3>    </h3><br><br><ol><li> <a href="http://habrahabr.ru/post/190556/">   .NET   </a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/251765/">https://habr.com/ru/post/251765/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../251749/index.html">FindBugs 3.0.1 released</a></li>
<li><a href="../251751/index.html">Proof of the incorrect sorting algorithm Android, Java and Python</a></li>
<li><a href="../251755/index.html">Visualize it</a></li>
<li><a href="../251757/index.html">Work on the modernization of the explorer in ReactOS completed</a></li>
<li><a href="../251759/index.html">Some interesting and useful things for web developer # 40</a></li>
<li><a href="../251777/index.html">Feedback of the PVS-Studio team on the C ++ Russia conference, 2015</a></li>
<li><a href="../251781/index.html">We master technical vision on the example of Bioloid STEM and HaViMo2.0</a></li>
<li><a href="../251783/index.html">Introduction to developing a slideshow in JavaScript</a></li>
<li><a href="../251793/index.html">Programming Philosophy 5 - Hummingbirds and Reactos</a></li>
<li><a href="../251795/index.html">Visual Studio Extensibility. Part One: MSBuild</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>