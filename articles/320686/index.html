<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The practice of metaprogramming in C ++: binary search tree at compile time</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The creators of templates in C ++ laid the foundation for a whole direction for research and development: it turned out that the C ++ template languag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The practice of metaprogramming in C ++: binary search tree at compile time</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/949/988/20a/94998820a4d14182926c448ff44c6787.png" align="left">  The creators of templates in C ++ laid the foundation for a whole direction for research and development: it turned out that the C ++ template language has <i>Turing completeness</i> , that is, metaprograms (programs designed to work at the compilation stage) C ++ is able to calculate everything <i>computable</i> .  In practice, the power of templates is most often used in the description of generalized data structures and algorithms: STL ( <i>Standard Template Library</i> ) is a living example. <br><br>  However, with the advent of C ++ 11 with its <code>variadic</code> patterns, type_traits library, tuples and <code>constexpr</code> 's, metaprogramming has become more convenient and visual, opening the way to the realization of many ideas that previously could be implemented only with the help of extensions of a specific compiler or complex multi-storeyed macros. <br><br>  In this article, we will develop an implementation of a binary tree of compile-time lookup: a data structure that is a logical "extension" of a tuple.  We will implement a binary tree in the form of a template and practice metaprogramming: transferring recursive and not only algorithms to the C ++ pattern language. <br><a name="habracut"></a><br><h3>  Content </h3><br><ul><li>  <a href="https://habr.com/ru/post/320686/">Some theory</a> </li><li>  <a href="https://habr.com/ru/post/320686/">Warm-up: tuple operations and turning a number into a class</a> </li><li>  <a href="https://habr.com/ru/post/320686/">Binary search tree</a> <br><ul><li>  <a href="https://habr.com/ru/post/320686/">Recursive definition</a> <br><ul><li>  <a href="https://habr.com/ru/post/320686/">Order relationship</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/320686/">Height</a> </li><li>  <a href="https://habr.com/ru/post/320686/"><i>In-order traversal</i></a> </li><li>  <a href="https://habr.com/ru/post/320686/">Search</a> </li><li>  <a href="https://habr.com/ru/post/320686/">Insert</a> </li><li>  <a href="https://habr.com/ru/post/320686/"><i>Breadth-first traversal</i></a> </li><li>  <a href="https://habr.com/ru/post/320686/">Delete?</a> </li></ul></li><li>  <a href="https://habr.com/ru/post/320686/">Application</a> </li><li>  <a href="https://habr.com/ru/post/320686/">What then?</a> </li><li>  <a href="https://habr.com/ru/post/320686/">Literature</a> </li></ul><br><a name="Theory"></a><h2>  Some theory </h2><br>  To begin with, let's recall some definitions and concepts about data structures and algorithms.  You can skip this section and go directly to the implementation details if the reader is familiar with the basics of graph theory and / or represents what binary trees are and how they can be prepared. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Definitions and not only:</b> <div class="spoiler_text">  <b><i>A free tree (a tree without a selected root)</i></b> or simply a <b><i>tree</i></b> is an acyclic undirected graph. <br><br>  <b><i>A tree with a root</i></b> is a free tree in which one vertex is identified, called the <b><i>root</i></b> . <br><br>  <b><i>The</i></b> nodes are the nodes of the tree with the root. <br><br>  <b><i>The parent node</i></b> or <b><i>parent of</i></b> node X is the last node preceding X on the path from the root R to this node X. In this case, the node X is called a <b><i>child of</i></b> the described parent node Y. The root of the tree has no parent. <br><br>  <b><i>A leaf</i></b> is a node that has no child nodes. <br><br>  <b><i>The internal node</i></b> is a node that is not a leaf. <br><br>  <b><i>The degree of node</i></b> X is the number of child nodes of this node X. <br><br>  <b><i>The node depth</i></b> X is the length of the path from the root R to this node X. <br><br>  <b><i>The height of the node</i></b> (height) - the length of the longest simple (no returns) downward path from node to sheet. <br><br>  <b><i>The height of the tree</i></b> - the height of the root of this tree. <br><br>  <b><i>An ordered tree</i></b> is a tree with a root in which the child nodes of each node are ordered (that is, the set of child nodes is mapped to the set of natural numbers from 1 to <i>k</i> , where <i>k</i> is the total number of child nodes of this node).  In simple words, each child node is given a name: ‚Äúfirst‚Äù, ‚Äúsecond‚Äù, ..., ‚Äú <i>k</i> -th‚Äù. <br><br>  <b><i>A binary tree</i></b> (binary tree) is ( <i>recursively</i> ) either an empty set (does not contain nodes), or consists of three disjoint sets of nodes: the <b><i>root node</i></b> , the binary tree, called the <b><i>left subtree</i></b> , and the binary tree, called the <b><i>right subtree</i></b> .  Thus, a binary tree is an ordered tree, in which each node has degree no more than 2 and has ‚Äúleft‚Äù and / or / or ‚Äúright‚Äù child nodes. <br><br>  <b><i>A</i></b> full binary tree is a binary tree, in which each node is either a leaf or has a power of two.  A fully binary tree can be obtained from a binary by adding dummy daughter sheets to each node of degree 1. <br><br>  <b><i>A binary search tree</i></b> is a related data structure implemented through a binary tree, each node of which can be represented by an object containing a <i>key</i> (key) and related data, links to the left and right subtrees and a link to the parent node.  The keys of a binary search tree satisfy the <b><i>property of a binary search tree</i></b> : <blockquote>  if <i>X</i> is a node and <i>Y</i> is in the left subtree of <i>X</i> , then <i>Y.key</i> ‚â§ <i>X.key</i> .  If the node <i>Y</i> is in the right subtree of <i>X</i> , then <i>X.key</i> ‚â§ <i>Y.key</i> . </blockquote>  It is understood that we are able to compare keys (a transitive order relation is set on a set of key values, that is, simply speaking, the operation is ‚Äúless‚Äù) and to talk about equality of keys.  In the implementation without loss of generality, we will operate with strict order inequalities, using only the operation "&lt;" and "==", built on its basis from the relation <blockquote><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><span class="noError" style="display: inline-block;">x&nbsp;=&nbsp;y&nbsp;\;&nbsp;\&nbsp;Leftrightarrow&nbsp;\;&nbsp;\&nbsp;;!&nbsp;(x&nbsp;&lt;y)&nbsp;\:&nbsp;\&nbsp;&amp;&nbsp;\&nbsp;:!&nbsp;(y&nbsp;&lt;x)</span></span><script type="math/tex" id="MathJax-Element-1"> x = y \; \ Leftrightarrow \; \ ;! (x <y) \: \ & \ :! (y <x) </script></blockquote><br>  <b><i>Traversing a tree</i></b> ‚Äî forming a list of nodes; the order is determined by the type of traversal. </div></div><br><a name="Tuples"></a><h2>  Warm-up: tuple operations and turning a number into a class </h2><br>  Before plunging into recursive jungle and enjoying the rampage of angle brackets, let's practice writing metafunctions.  Next, we need the <i>concatenation</i> functions of tuples and the function of <i>adding a type</i> to an existing tuple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">V</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple_concat</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuple</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple_push</span></span></span><span class="hljs-class">;</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">About type operations:</b> <div class="spoiler_text">  Of course, there is no talk of any "concatenation" and "addition" of types in "type containers".  This is a common and important feature of the compile-time world: a <i>certain</i> type (class) cannot be modified in any way, but it is possible to define a new (or among the previously defined, select an existing) type that has the properties we need. <br><br>  The <b>C ++ 11 standard</b> introduces a <code><a href="http://en.cppreference.com/w/cpp/header/type_traits">type_traits</a></code> header file (as part of a type support library) containing a collection of useful meta-functions.  All of them are patterns of structures, and after instantiation, they locally define some <code>type</code> or a numeric <code>value</code> constant (or nothing, as in the case of disconnecting the overload using <code>std::enable_if</code> ).  We will adhere to the same design principles of meta-functions. </div></div><br>  The first function accepts two tuples as arguments of the template, the second - a tuple and the type that must be added to the tuple.  The substitution of unsuitable types as arguments (for example, when attempting to concatenate <code>int</code> and <code>float</code> ) is a meaningless operation, so the basic pattern of these structures is not defined (this will prevent it from being instantiated for arbitrary types), and all the useful work is done in <i>partial specializations</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Alist</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Blist</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple_concat</span></span></span><span class="hljs-class">&lt;T&lt;Alist...&gt;, T&lt;Blist...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = T&lt;Alist..., Blist...&gt;; }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">...&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Tuple</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class">... </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Args</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tuple_push</span></span></span><span class="hljs-class">&lt;Tuple&lt;Args...&gt;,T&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = Tuple&lt;Args..., T&gt;; };</code> </pre><br>  An approximate translation into the human language specialization <code>tuple_concat</code> : <br><br>  <i>If the template arguments are two classes that in turn are the results of instantiating <b>the same</b> class template ( <code>T</code> ) with a variable number of arguments, and they were instantiated with the <code>Alist</code> and <code>Blist</code> parameter <code>Blist</code> , then locally define the pseudonym <code>type</code> as instantiated the version of the same template of class <code>T</code> with a concatenated list of arguments, i.e.</i>  <i><code>T&lt;Alist..., Blist...&gt;</code> .</i> <br><br><div class="spoiler">  <b class="spoiler_title">About terminology:</b> <div class="spoiler_text">  Later in the article, the concepts of ‚Äúinstantiating the template structure of metafunction‚Äù (more correct and more sophisticated) and ‚Äúcalling metafunction‚Äù (shorter and clearer) will often be identified, essentially meaning the same thing: ‚Äúin this place of the program from the template, the structure will be generated with all the ensuing the consequences: it will become large, pseudonyms and classes will be defined inside, etc.  etc." </div></div><br>  It sounds ominous, but in practice everything is simpler than it seems: when you try to call <code>tuple_concat</code> with two tuples of the same type (for example, with two <code>std::tuple</code> ), the type of the same tuple with the ‚Äústitched‚Äù list of arguments of the input tuples is determined inside the structure.  Other instantiations of instantiation are simply not compiled (the compiler will not be able to infer types for the partial specialization defined above, and instantiating a common pattern will be impossible due to the absence of its body).  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> t1 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> t3 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> conc = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple_concat&lt;t1,t2&gt;::type; <span class="hljs-comment"><span class="hljs-comment">// using err = typename tuple_concat&lt;int,bool&gt;::type; //  static_assert(std::is_same&lt;t3,conc&gt;::value, ""); //  ,  </span></span></code> </pre><br>  In the light of the above, consideration of the <code>tuple_push</code> specialization <code>tuple_push</code> not be a big deal.  Additionally, for convenience, we define the corresponding <i>template aliases</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_concat_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple_concat&lt;U,V&gt;::type; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tuple, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">tuple_push_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> tuple_push&lt;Tuple,T&gt;::type;</code> </pre><br>  This convenient feature appeared in the language in the C ++ 11 standard: for example, it allows you to simply <code>typename tuple_concat&lt;t1,t2&gt;::type</code> <code>tuple_concat_t&lt;t1,t2&gt;</code> to access <code>type</code> instead of the <code>typename tuple_concat&lt;t1,t2&gt;::type</code> . <br><br><div class="spoiler">  <b class="spoiler_title">About concatenation:</b> <div class="spoiler_text">  The standard <code>tuple</code> header contains a definition (not a meta-) of the <code>tuple_cat()</code> ) function, which constructs a tuple by concatenating an unspecified number of <code>std::tuple</code> 'passed to it as arguments.  An attentive reader may notice that <code>tuple_concat</code> can be more easily implemented by outputting the result type <code>decltype(tuple_cat(...))</code> , however, firstly, the implementation obtained above is not limited to the type of the <code>std::tuple</code> , and secondly, it was warm-up exercise for the gradual immersion in more complex type arithmetic. </div></div><br>  Last preparations: not for business, but for the <s>soul of</s> debug, we will learn to turn whole <i>numbers into types</i> : you need to store something in the nodes of the tree, but what could be simpler and more convenient for debugging than storing ordinary numbers in them?  But since the tree is not simple, but with types (and compile time), then the numbers should be difficult.  In fact, the implementation is extremely simple and well known: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// - STL-like  template&lt;size_t number&gt; struct num_t : std::integral_constant&lt;size_t, number&gt; {}; //      template&lt;size_t number&gt; struct num_t { enum : size_t { value = number } };</span></span></code> </pre><br>  The meaning of both definitions is the same: instantiating a template with different numerical arguments will lead to the definition of different types: <code>num_t&lt;0&gt;</code> , <code>num_t&lt;13&gt;</code> , <code>num_t&lt;42&gt;</code> , etc.  No more than for convenience, we endow this structure with a static numeric <code>value</code> , which will allow us to explicitly get back a number from the template argument (by accessing <code>some_num_type::value</code> ) without resorting to type inference. <br><br><a name="Tree"></a><h2>  Binary search tree </h2><br>  Recursive definition of a binary search tree is convenient for direct implementation in the form of a template.  Simplified definition <br><br><pre>  <b>WOOD: NIL |</b>  <b>[TREE, DATA, TREE]</b> </pre><br>  can be rephrased as ‚Äúa tree is an empty set OR a set of three elements: a tree (the so-called left subtree), data, a tree (the so-called right subtree)‚Äù. <br><br>  In addition, as already mentioned, a binary search tree requires specifying an order relation on the set of values ‚Äã‚Äãstored in the nodes of the tree (we must be able to somehow compare and order the nodes, that is, have the operation ‚Äúless‚Äù).  The canonical approach is to partition the node data into a <i>key</i> and a <i>value</i> (we compare the keys, simply store the values), but in our implementation, in order to simplify the structure without loss of generality, we will consider the node data as a single type, to specify the same order relation, we use a special type <code>Comp</code> ( <i>comparator</i> , <i>let</i> 's talk about it further). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///   struct NIL {}; ///  template&lt;typename T, typename Left, typename Right, typename Comp&gt; struct node { using type = T; // node value using LT = Left; // left subtree using RT = Right; // right subtree using comp = Comp; // types comparator }; /// :    ( ) template &lt;typename T, typename Comp&gt; using leaf = node&lt;T,NIL,NIL,Comp&gt;;</span></span></code> </pre><br>  Despite the fact that the order relation is still defined on the set of types stored in nodes, it is convenient to attribute it to the tree itself and to store it as part of the type of this tree: when calling metafunctions for searching, inserting and traversing a non-empty tree, there is no need for additional indication of the comparator. <br><br><div class="spoiler">  <b class="spoiler_title">About fathers and children:</b> <div class="spoiler_text">  The attentive reader will notice that the presented structure lacks one element that is important for the implementation of most algorithms: references to the parent node (in our case, aliases of the type of the parent tree).  Noticing this and trying to correct this injustice, the reader sooner or later in horror realizes that in this case there will be a <i>cyclical dependence of pseudonyms</i> . <br><br>  The situation itself is not critical and has a workaround in the form of separating declarations and type definitions: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;...&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">one</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">two</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> three = one&lt;two, ...&gt;; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">two</span></span></span><span class="hljs-class"> :</span></span> one&lt;three, ...&gt; {}; };</code> </pre><blockquote>  <i>Note: it was</i> experimentally found that such structures are compiled and instantiated by modern gcc and clang, however, I have not yet verified the strict adherence to the standard for declarations of such unusual patterns. </blockquote>  However, in practice it is very, VERY difficult to work with such entities and create them.  The reciprocal reference to the parent element produces an interesting effect: in fact, our "simply connected tree" turns into a real graph (tasty!), Which, with any modification, must instantiate itself <i>"at a time", again and completely</i> (sadly).  A deeper analysis of this situation is beyond the scope of this article and is among my future plans for exploring the possibilities of metaprogramming in C ++. </div></div><br>  This is not the only way to implement and represent a tree (for example, you can store nodes in a tuple and index them), but this description is more intuitive and convenient for directly applying tree-working algorithms. <br><br><a name="Comp"></a><h3>  Order relationship </h3><br>  The <code>Comp</code> structure must contain type comparison metafunctions (i.e., less than and equal to operation patterns).  Let us write an example of such a comparator based on the <code>sizeof</code> 'ah types (perhaps, the only numerical characteristic defined for all full types): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sizeof_comp</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lt</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(U) &lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(V))&gt; {}; <span class="hljs-comment"><span class="hljs-comment">//  template &lt;typename U, typename V&gt; struct eq : std::integral_constant&lt;bool, (sizeof(U) == sizeof(V))&gt; {}; //  };</span></span></code> </pre><br>  Here everything should be transparent: <code>lt</code> is a ‚Äúless‚Äù metafunction for types, <code>eq</code> is an ‚Äúequal‚Äù metafunction.  The approach shown earlier for determining the types of numbers was used: inheritance from <code>std::integral_constant</code> will endow the instantiated <code>lt</code> and <code>eq</code> static Boolean values. <br><br>  In practice, concrete trees of specific types should be supplied with a comparator specific for this task.  For example, we write a comparator for the class of ‚Äúnumeric types‚Äù described earlier: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">num_comp</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lt</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, (U::value &lt; V::value)&gt; {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> V&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">eq</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::integral_constant&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>, (U::value == V::value)&gt; {}; };</code> </pre><br>  Such a comparator, generally speaking, is universal and can compare any types containing a static value <code>value</code> . <br><br><div class="spoiler">  <b class="spoiler_title">About generating a comparator using CRTP:</b> <div class="spoiler_text">  Earlier in the theoretical section it was mentioned that the operation ‚Äúless‚Äù is generally enough to intuitively determine the operation ‚Äúequal‚Äù.  We use an approach similar to CRTP ( <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern"><i>Curiously recurring template pattern</i></a> ) to determine the full comparator based only on the comparator containing the ‚Äúless‚Äù operation (metafunction): <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///        template &lt;typename lt_traits&gt; struct eq_comp { template &lt;typename U, typename V&gt; struct lt : std::integral_constant&lt;bool, lt_traits::template lt&lt;U,V&gt;::value&gt; {}; template &lt;typename U, typename V&gt; struct eq : std::integral_constant&lt;bool, (!lt&lt;U,V&gt;::value &amp;&amp; !lt&lt;V,U&gt;::value)&gt; {}; }; ///   sizeof,     eq_comp::eq struct sizeof_comp : public eq_comp&lt;sizeof_comp&gt; { template &lt;typename U, typename V&gt; struct lt : std::integral_constant&lt;bool, (sizeof(U) &lt; sizeof(V))&gt; {}; }; ///   num_t struct num_comp : public eq_comp&lt;num_comp&gt; { template &lt;typename U, typename V&gt; struct lt : std::integral_constant&lt;bool, (U::value &lt; V::value)&gt; {}; };</span></span></code> </pre>  The size of the definition has decreased and a mathematical background has appeared - isn't it beautiful? </div></div><br>  Now we have everything to define the first type tree: ‚Äúhands‚Äù; <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> t1 = node&lt; <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, node&lt; <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, leaf&lt;<span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;&gt;, leaf&lt;<span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;&gt; &gt;, node&lt; <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;, NIL, leaf&lt;<span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt;&gt; &gt; &gt;;</code> </pre><blockquote>  <i>Note:</i> Here and hereinafter in the examples, the default is to compare <code>num_comp</code> , explicitly indicating it in the list of template arguments is omitted.  In general, after the development of the <code>insert</code> operation, we will not have to build trees in this way (by definition). </blockquote><div style="text-align:center;"><img src="https://habrastorage.org/files/d9a/828/b54/d9a828b546014ba0a14a7db1744d1315.png"></div>  The described tree is shown in the picture. <br><br><div class="spoiler">  <b class="spoiler_title">About debugging at compile time:</b> <div class="spoiler_text">  How do we make sure that the class we define accurately describes what we have in mind? <br><br>  This separate interesting topic for discussion and research is the debugging of metaprograms.  We have no call stack, no variables, no fucking banal <code>printf/std::cout</code> .  There are techniques that allow typing readable inferred types inside the compiler error messages, and, in principle, this is quite a useful feature for checking generated structures (for example, after modifying a tree). <br><br>  We will not deal here with the issue of multi-megabyte error messages simply in the case of an incorrect program: after some practice this ceases to be a problem, since in the overwhelming majority of cases only the first instantiation error leads to a cascade of further errors: debugging in this case is carried out using the ‚Äúsuccessive approximation method‚Äù. <br><br>  But, as paradoxical as it sounds, what to do if the program was compiled successfully?  Here the author is more free to choose debugging methods.  The type of the result of metafunctions, like those defined in <code>type_traits</code> can be simply printed as <code>typeid(t).name()</code> (starting from C ++ 11, you can legally look into RTTI).  Simple data structures can be displayed on the screen with special metafunctions with tail recursion; for complex ones, printers will have to be built, comparable in complexity to operations on the structure itself. <br><br>  The library of trees contains such a printer and examples of its use; the reader can get acquainted with them through the link to github at the end of the article.  For example, the printed tree from the example above: <br><blockquote><pre>                   / - {2}  
          / - {3} - &lt;
                   \--{four}  
 - {5} --- &lt;
          \ - {7} - \
                   \--{eight}
</pre></blockquote></div></div><br><a name="Height"></a><h2>  Height </h2><br>  Let's look at the recursive function of calculating the height of a binary tree: <br><br><pre>  /// Input: T - tree, exit: h - height </pre><pre> <b>
</b>  <b>HEIGHT (T):</b> <b>
    </b>  <b>IF T == NIL</b> <b>
        </b>  <b>OUTPUT 0</b> <b>
    </b>  <b>ANYWAY</b> <b>
        </b>  <b>OUTPUT 1 + MAX (HEIGHT (T.LEFT), HEIGHT (T.RIGHT))</b> <b>
</b> </pre><br>  She is beautiful.  Just take and transfer this function to C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///    template &lt;typename Tree&gt; struct height; ///  : " T == NIL" template &lt;&gt; struct height&lt;NIL&gt; : std::integral_constant&lt;size_t, 0&gt; {}; ///    () template &lt;typename Tree&gt; struct height { static constexpr size_t value = 1 + max( height&lt;typename Tree::LT&gt;::value, height&lt;typename Tree::RT&gt;::value ); };</span></span></code> </pre><blockquote>  <i>Note:</i> we deliberately went for a small simplification, because of which the calculated tree height will be 1 more than its mathematical definition (the height of the empty set is not defined).         ,         1    ,      <code>height</code>   . </blockquote>   :    <code>height</code>       ,   <code>value = 0</code> ,      ,        (     <code>NIL</code> ),     .         C++:    <i> </i> ,       (       ),                (            <code>Tree::LT</code> ,  <code>Tree</code>      <code>NIL</code> ). <br><br>      <code>max</code> .    <code>constexpr</code> (  ,     ),     : <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">max</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T a, T b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b ? b : a; }</code> </pre> <br> ,   <code>height</code> : <br><br><pre> <code class="hljs lisp">static_assert(<span class="hljs-name"><span class="hljs-name">height&lt;t1&gt;</span></span>:<span class="hljs-symbol"><span class="hljs-symbol">:value</span></span> == <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br>   ¬´¬ª  <code>height</code> :  <b>n</b> ,  n ‚Äî   ;    <b>h</b> ‚Äî ..  . <br><br><div class="spoiler"> <b class="spoiler_title">      ?!</b> <div class="spoiler_text">   , ,        ,    :         <i> </i> (!),  -          ,     .   ,     :        ,   <code>constexpr</code> -   variadic- . <br><br>           : , gcc-5.4 ¬´ ¬ª (  )     900 .     ,     <i> </i> (     ). ,  <code>height</code>     gcc,     &gt; 900.    <b>O</b> -    (        ),       . <br><br> ,   C++14        ( <code>std::integer_sequence</code> ):     N    0..N-1,     ,          .   ,        ,       (  ,     30-     9000-   ). <br><br>         ,    (..  )     :        .      (  ,     ..),    ,   ‚Äî   ,    ‚Äî   API    ,       ,      ‚Äî    (   ¬´     24 ¬ª!). </div></div><br><br><a name="Inorder"></a><h2>   ( <i>in-order traversal</i> ) </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The task of traversing is to form a list of nodes in a certain way (or data from nodes, a question of terminology and matters in practice). </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A centered (symmetric) bypass</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a bypass in which the root of the tree takes place between the results of the corresponding bypass of the left and right subtrees. </font><font style="vertical-align: inherit;">Together with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">property of a binary search tree</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (which is about inequalities, see theory), this suggests that a centered search of a binary search tree will form a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sorted list of nodes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for us </font><font style="vertical-align: inherit;">- cool! </font><font style="vertical-align: inherit;">Here's what a walk through a previously defined tree would look like:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/08c/4dc/dce/08c4dcdce7504c98a2fb95a5e3ecc000.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The recursive traversal algorithm is fairly simple: </font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /// Input: T - tree, output: w - list of data from in-order bypass nodes </font></font></pre><pre> <b><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INORDER (T):</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    IF T == NIL</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        CONCLUSION {}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    ANYWAY</font></font><font></font>
         INORDER(T.LEFT) + {T.KEY} + INORDER(T.RIGHT)<font></font>
</b> </pre><br>  "+"      . -,   ,      ,    ‚Äî       .   ‚Äî     : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///    template &lt;typename Tree&gt; struct walk; ///  : " T == NIL" template &lt;&gt; struct walk&lt;NIL&gt; { using type = std::tuple&lt;&gt;; }; ///    () template &lt;typename Tree&gt; struct walk { private: //    using accL = typename walk&lt;typename Tree::LT&gt;::type; //   using accX = tuple_push_t&lt;accL, typename Tree::type&gt;; //      using accR = tuple_concat_t&lt;accX, typename walk&lt;typename Tree::RT&gt;::type&gt;; public: //  using type = accR; };</span></span></code> </pre><br>            <code>private</code> :          ,     ,      .      ,   ? <br><br>   <code>walk</code> : <b>O(n)</b> ,  n ‚Äî    ( <b>O</b> -   :     <b>3n</b>     ). ,   <code>tuple_concat</code>  <code>tuple_push</code>     1 ,      (    <code>parameter pack</code> ').  ,     <code>height</code> ,  <b>h</b> ‚Äî  . <br><br><div class="spoiler"> <b class="spoiler_title">  :</b> <div class="spoiler_text">         :    ,   ,            . <br><br>      : , ,    ,             .  ,     : ¬´     ¬ª.       ,              :      ,         . </div></div><br><br><a name="Search"></a><h2>  Search </h2><br>            (    ).       ,         <code>Comp</code> .   : <br><br><pre> /// : T - , k - -,<font></font>
/// : N - ,   k` == k    </pre><pre> <b><font></font>
SEARCH(T,k):<font></font>
     T == NIL  k == T.KEY<font></font>
         T<font></font>
    <font></font>
         k &lt; T.KEY<font></font>
             SEARCH(T.LEFT, k)<font></font>
        <font></font>
             SEARCH(T.RIGHT, k)<font></font>
</b> </pre><br>      : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">///    template &lt;typename Tree, typename T&gt; struct search; ///     template &lt;typename T&gt; struct search&lt;NIL,T&gt; { using type = NIL; }; ///    template &lt;typename Tree, typename T&gt; struct search { using Comp = typename Tree::comp; using type = typename std::conditional&lt; Comp::template eq&lt;T, typename Tree::type&gt;::value, // k == T.KEY ? Tree, //  , : typename std::conditional&lt; Comp::template lt&lt;T, typename Tree::type&gt;::value, // k &lt; T.KEY ? typename search&lt;typename Tree::LT, T&gt;::type, //     typename search&lt;typename Tree::RT, T&gt;::type //  --   &gt;::type &gt;::type; };</span></span></code> </pre><br>   ,  : -,      (   ), -,         ,          ,    .    : <br><br><ul><li>        : <code>Tree::comp</code> ,  :       ,     (  , ),            ( <code>node&lt;&gt;</code> ). </li><li>    <i>,    </i> ( <code>Tree::comp::eq&lt;...&gt;</code>  <code>Tree::comp::lt&lt;...&gt;</code> ),     <code>template</code> . </li><li>         <code>std::conditional</code> ‚Äî  ,         (    <b>?:</b>  ).        ‚Äî . ,     ‚Äî  <i></i>  . </li></ul><br>    <code>search</code> ‚Äî - <b>O(n)</b> ,  ‚Äî <b>h</b> ( ). ¬´!¬ª ‚Äî   , ‚Äî ¬´        ?¬ª <br><br> -      <code>std::conditional</code>        <b>?:</b> :   <i> </i>  ,      (,             ,          ). <code>std::conditional</code>  <i>   </i> (  ),     <code>std::conditional</code>    ,        . <br><br>   ‚Äî  ,        .         - ¬´¬ª        ,       (       ),     <b>O(h)</b> , ,   ,             <i> </i> . <br><br>   (  ,   .  ): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> found3 = <span class="hljs-keyword"><span class="hljs-keyword">search_t</span></span>&lt;NIL, <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, num_comp&gt;; <span class="hljs-comment"><span class="hljs-comment">//    using found4 = search_t&lt;t1, num_t&lt;5&gt;, num_comp&gt;; //    using found5 = search_t&lt;t1, num_t&lt;8&gt;, num_comp&gt;; //    static_assert(std::is_same&lt;found3, NIL&gt;::value, ""); //   static_assert(std::is_same&lt;found4, t1&gt;::value, ""); //   static_assert(std::is_same&lt;found5, leaf&lt;num_t&lt;8&gt;&gt;&gt;::value, ""); // </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This may seem strange: we are looking for a node in the tree with a type ... which is actually already specified as an argument - why? </font><font style="vertical-align: inherit;">In fact, there is nothing unusual in this - we are looking for a type that is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equal to the argument in terms of the comparator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The STL ( </font></font><code>std::map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">trees are </font><font style="vertical-align: inherit;">also stored in the nodes of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pair</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><code>std::pair</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and the first element of the pair is considered the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which, in fact, participates in comparisons. </font><font style="vertical-align: inherit;">It is enough to keep the same in our tree </font></font><code>std::pair</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and make the comparator </font></font><code>Comp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compare pairs of the first type in a pair - and get a classic associative (meta) container! </font><font style="vertical-align: inherit;">We will return to this idea at the end of the article.</font></font><br><br><a name="Insert"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Insert </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is time to learn how to build trees with the help of metafunctions (it wasn‚Äôt all for the same thing to draw trees with your hands the way we did before?). </font><font style="vertical-align: inherit;">Our recursive insertion algorithm will create a new tree:</font></font><br><br><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> /// Input: T is a tree, k is a key type for insertion,</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
/// exit: T 'is a new tree with an inserted element </font></font></pre><pre> <b><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INSERT (T, k):</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    IF T == NIL</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        CONCLUSION {NIL, k, NIL}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    ANYWAY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        IF k &lt;T.KEY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            OUTPUT {INSERT (T.LEFT, k), T.KEY, T.RIGHT}</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
        ANYWAY</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
            CONCLUSION {T.LEFT, T.KEY, INSERT (T.RIGHT, k)}</font></font><font></font>
</b> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us explain its work: if the tree into which the insertion occurs is empty, then the inserted element will create a new tree </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{NIL, k, NIL}</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , i.e. just a sheet with this element (bottom of recursion). If the tree is not empty, then we must recursively fall to an empty tree (i.e., until the left or right subtrees are empty), and eventually form the same sheet </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{NIL, k, NIL}</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in this subtree </font><font style="vertical-align: inherit;">instead </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NIL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , on the way ‚Äúhanging up‚Äù itself in the form of a new left or right subtree. In the world of types, we cannot change existing types, but we can create new ones - this happens at every step of recursion. Implementation:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Comp = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::comp&gt; struct insert; <span class="hljs-comment"><span class="hljs-comment">///   template &lt;typename T, typename Comp&gt; struct insert&lt;NIL,T,Comp&gt; { using type = leaf&lt;T,Comp&gt;; }; ///   template &lt;typename Tree, typename T, typename Comp&gt; struct insert { using type = typename std::conditional&lt; Comp::template lt&lt;T, typename Tree::type&gt;::value, // k &lt; T.KEY? node&lt;typename Tree::type, //   {INSERT(T.LEFT,k), T.KEY, T.RIGHT} typename insert&lt;typename Tree::LT, T, Comp&gt;::type, typename Tree::RT, Comp&gt;, node&lt;typename Tree::type, //   {T.LEFT, T.KEY, INSERT(T.RIGHT,k)} typename Tree::LT, typename insert&lt;typename Tree::RT, T, Comp&gt;::type, Comp&gt; &gt;::type; };</span></span></code> </pre><br>           <code>Comp</code> ;     ,   -     <abbr title=",      (  ),      .">*</abbr> . <br><br>   : <b>O(n)</b>  (n ‚Äî    ),    <b>h</b> (h ‚Äî  ).   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> t2 = leaf&lt;<span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, num_comp&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> t3 = <span class="hljs-keyword"><span class="hljs-keyword">insert_t</span></span>&lt;t2, <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> t4 = <span class="hljs-keyword"><span class="hljs-keyword">insert_t</span></span>&lt;t3, <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(height&lt;t4&gt;::value == <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  2  using t5 = insert_t&lt;insert_t&lt;insert_t&lt;t4, num_t&lt;2&gt;&gt;, num_t&lt;4&gt;&gt;, num_t&lt;8&gt;&gt;; static_assert(std::is_same&lt;t5, t1&gt;::value, ""); //   </span></span></code> </pre><br>      <code>insert_tuple</code> ,        (     <code>insert</code>  ), : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> t6 = <span class="hljs-keyword"><span class="hljs-keyword">insert_tuple_t</span></span>&lt;NIL, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt; <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">7</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">num_t</span></span>&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; &gt;, num_comp&gt;; <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_same&lt;t1, t6&gt;::value, <span class="hljs-string"><span class="hljs-string">""</span></span>);</code> </pre><br><a name="Breadth"></a><h2>    ( <i>breadth-first traversal</i> ) </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traversing the width of a binary tree (or a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">search for width</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from graph theory) generates a list of nodes in order ‚Äúby level‚Äù ‚Äîfirst it outputs the root, then the nodes with a depth of 1, then with a depth of 2, etc. </font><font style="vertical-align: inherit;">The algorithm for this traversal uses a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue of</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nodes for further output (and not a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stack</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), so it is difficult to "convert" into recursive. </font><font style="vertical-align: inherit;">Under the spoiler further interested reader will find a workaround. </font><font style="vertical-align: inherit;">Here we note only the useful fact that a tree ‚Äúparsed‚Äù by a wide walk can be assembled back into </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactly the same</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> successive insertion of elements from the tuple of the walk result. </font><font style="vertical-align: inherit;">The figure shows a walk around the width of our test tree:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e62/8d6/094/e628d609440142cc88825ef1fd936492.png"></div><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recursive wide bypass:</font></font></b> <div class="spoiler_text">  :    0    h          .      : <br><br><pre> /// : T - , l -   ,<font></font>
/// : t -     </pre><pre>COLLECT_LEVEL(T,l):<font></font>
     T == NIL<font></font>
         {}<font></font>
    <font></font>
         l == 0<font></font>
             {T.KEY}<font></font>
        <font></font>
             COLLECT_LEVEL(T.LEFT,l-1) + COLLECT_LEVEL(T.RIGHT,l-1)<font></font>
</pre><br>         .       ,       <b>O(nh)</b>  -     (,      ,    <code>collect_level</code>      ). </div></div><br><br><a name="Delete"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Delete? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deleting a node is not a trivial task. The classical approach considers 3 cases (by the number of child nodes), and the algorithm uses the concepts of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subsequent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> node. Without a reverse link to the parent node (see the ‚ÄúAbout Fathers and Children‚Äù spoiler), it is problematic to implement the algorithm effectively: each lifting operation up the tree will have to have </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (n)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> complexity </font><font style="vertical-align: inherit;">. A naive implementation of such a deletion will lead to a ‚Äúcombinatorial explosion‚Äù in the number of instantiations (the complexity is something around </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (n </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). The development of the node deletion metafunction is included in future plans to improve the library. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See UPD2 at the end of the article.</font></font></b> <br><br><a name="Usage"></a><h2>  Application </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's take a breath and finally pay attention to the question, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">why might a binary search tree need compile time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">There are three answers: </font></font><br><br> <u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nonconstructive:</font></font></i></u> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * Picture with trolleybus *. </font><font style="vertical-align: inherit;">Omit. </font></font><br><br> <u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evident:</font></font></i></u> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... for those with a research interest</font></font></b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f49/e8d/8ce/f49e8d8ce98b4594ba62021121ae5bda.png"></div></div><br> <u><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constructive:</font></font></i></u> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Let us give examples of possible applications of such a structure:</font></font><br><br><ul><li> <b> :</b>        ,     .         ¬´¬ª  .      ‚Äî     ( ‚Äî <b>O(n <sup>2</sup> )</b> ),      ‚Äî     . <br><br></li><li> <b> runtime  :</b>               ,   -.        <code>std::tuple</code> ‚Äî   . ,  runtime      ,           ,             ( <code>std::get</code>    <code>std::tuple</code> ). <br><br></li><li> <b>   compile-time:</b>          <code>std::map</code> (  <code>std::set</code> ) ‚Äî  ,    (,  )       (      ‚Äî ,    ..),         compile-time,       runtime    . :  ,   ,  .  :     ? <br><br></li><li> <b> :</b>     ¬´ ¬ª,        .  <i>  </i>    , , ,       . </li></ul><br><div class="spoiler"> <b class="spoiler_title"> :</b> <div class="spoiler_text">   <i>¬´Modern C++ Design: Generic Programming and Design Patterns Applied¬ª</i> (     <i>¬´   ++¬ª</i> , .  )       <i> </i>    : ¬´         ¬ª.    <code>static_assert</code>  ,  <s>  </s>      C++11,     <i></i> ( <i></i> , <i>policy</i> ),       STL,     C++98   (¬´ ¬ª)           (       ,       ,      , <i>  </i>    ). <br><br> ,        :        compile-time ‚Äî      ,      (      ,       ),             (     ¬´¬ª,   ,         - ). </div></div><br>        ,       .          (  ),  ,    .. <i> </i> ,     ¬´  ¬ª .  ,      ‚Äî   (     ) compile-time    (          ), ,   ,    . <br><br><a name="Plans"></a><h2>  What then? </h2><br><div class="spoiler"> <b class="spoiler_title">: ...</b> <div class="spoiler_text">         ,       (, ,  )   .   ‚Äî      ,    (, - ), <code>std</code> -  (  ‚Äî  tutorial      ).  ,           . <br><br>    ! </div></div><br><a name="Books"></a><h2>  Literature </h2><br><ul><li> <i>, ., , ., , ., , .</i> :    = Introduction to Algorithms. ‚Äî 2-. ‚Äî .: , 2005. ‚Äî 1296 . </li><li> <i> .</i>    ++:       = Modern C++ Design: Generic Programming and Design Patterns Applied. ‚Äî . .: , 2008. ‚Äî 336 . ‚Äî (++ in Depth). </li><li> <i> .,  .</i>    ++.  ¬´C++ In-Depth¬ª = C++ Coding Standards: 101 Rules, Guidelines and Best Practices (C++ In-Depth). ‚Äî .: ¬´¬ª, 2014. ‚Äî 224 . </li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gottshling P.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modern C ++ for programmers, engineers and scientists. </font><font style="vertical-align: inherit;">C ++ In-Depth series = Discovering Modern C ++: A Concise Introduction for Scientists and Engineers (C ++ In-Depth). </font><font style="vertical-align: inherit;">- M .: "Williams", 2016. - 512 p.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí </font><b><font style="vertical-align: inherit;">UPD </font></b></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">repository </font></font></a> <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b> <div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rehab std :: conditional:</font></font></b> <div class="spoiler_text">  <a href="https://habrahabr.ru/users/izvolov/" class="user_link">izvolov</a>       <code>std::conditional</code> .   <code>search</code>      <b>O(h)</b> : <br><blockquote><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Node, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Comp&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">search</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; Comp::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> eq&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Node::type&gt;::value, Node, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> search&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; Comp::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> lt&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Node::type&gt;::value, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Node::LT, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Node::RT &gt;::type, T, Comp&gt;::type &gt;::type; };</code> </pre> </blockquote>    (+ <code>insert</code> )  . <br></div></div><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD2:</font></font></b> <div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The implementation of remove and fix insert and search for O (h):</font></font></b> <div class="spoiler_text">  ,    <code>insert</code>  <code>search</code>     <code>remove</code>     <b>O(h)</b>  (    <code>insert</code> ).      <i><a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a></i> + <code>decltype</code>          (            , . <a href="https://habrahabr.ru/post/205772/"></a> ).    <code>remove</code> : <blockquote><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">remove</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> { is_less = Tree::comp::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> lt&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::type&gt;::value }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> { is_equal = Tree::comp::<span class="hljs-keyword"><span class="hljs-keyword">template</span></span> eq&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::type&gt;::value }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> { children = children_amount&lt;Tree&gt;::value }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> key = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">min_node_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; is_equal &amp;&amp; children == <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::RT, leaf&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::comp&gt; &gt;::type &gt;::type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> recursive_call = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> remove&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; is_less, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::LT, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; !is_equal || children == <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::RT, NIL &gt;::type &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; is_equal, key, T &gt;::type &gt;::type; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::<span class="hljs-function"><span class="hljs-function">RT </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root_dispatcher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Bush&gt; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt; <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Bush::LT::type), <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Bush::LT &gt;::<span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">root_dispatcher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bush&amp;&amp;)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; is_equal &amp;&amp; (children &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(root_dispatcher(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;Tree&gt;())), node&lt; key, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; is_less, recursive_call, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::LT &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::conditional&lt; !is_less, recursive_call, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::RT &gt;::type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Tree::comp &gt; &gt;::type; };</code> </pre> </blockquote>    , ,  .   ,   ,  , , <a href="http://neerc.ifmo.ru/wiki/index.php%3Ftitle%3D%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0,_%25D0%25BD%25D0%25B0%25D0%25B8%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2580%25D0%25B5%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F"></a> . <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/320686/">https://habr.com/ru/post/320686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320674/index.html">Automatic visualization of the python code. Part Two: Implementation</a></li>
<li><a href="../320676/index.html">Dagger 2. Part Three. New facets of the possible</a></li>
<li><a href="../320678/index.html">Correct problem detection with Zabbix</a></li>
<li><a href="../320682/index.html">Nested logical expressions</a></li>
<li><a href="../320684/index.html">A little about Swift runtime or where NSObject disappeared</a></li>
<li><a href="../320690/index.html">Notify at any cost about the fall of the site. Practical advice</a></li>
<li><a href="../320692/index.html">Three product lines and version control</a></li>
<li><a href="../320694/index.html">Hack.me: Another platform for honing skills in the field of information security</a></li>
<li><a href="../320696/index.html">Native Android and iOS code in Qt using the status bar example</a></li>
<li><a href="../320698/index.html">Rspamd mail anti-spam integration with opensmtpd</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>