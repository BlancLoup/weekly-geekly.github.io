<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Substitution Benefit Criterion and Dynamic Profiling</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I continue the topic of interprocedural optimizations, the introduction to which can be found in the previous post . Today, I want to speculate a bit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Substitution Benefit Criterion and Dynamic Profiling</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b23/738/68d/b2373868d08443c59735df24bbdd032f.png" alt="image"><br><br>  I continue the topic of interprocedural optimizations, the introduction to which can be found <a href="http://habrahabr.ru/company/intel/blog/199112/">in the previous post</a> .  Today, I want to speculate a bit about function substitution (inlining) and how substitution affects application performance. <br><a name="habracut"></a><br>  Periodically it is necessary to analyze cases when the same application compiled by different compilers shows different performance.  Often the reason is the difference in substitution, which is performed automatically.  Suddenly it turns out that in one case one set of calls is substituted, and in the other one it is somewhat different.  As a result, the analysis of competing compilers is greatly complicated, since it becomes impossible to directly compare any hot functions.  The time of their execution depends heavily on what calls have been placed. <br>  The substitution is the most popular interprocedural optimization, which instead of calling a function inserts its body into the body of the calling function.  What tasks does the compiler have to solve when deciding on substitution and how can a programmer improve application performance with this optimization?  As the inlining decision is made by the Intel compiler, I approximately know, but it is interesting to check the proposed methods on the gcc compiler. <br><br><h4>  Why do substitutions improve performance? </h4><br><ul><li>  The overhead of calling a function disappears, i.e.  there is no need to allocate space on the stack to store the call arguments or write arguments to registers. </li><li>  Improved code locality.  Instead of switching to the instructions of the called procedure, which may not be in the cache, the control ‚Äúsmoothly flows‚Äù to the lines of code inserted as a result of the substitution. </li><li>  Most compiler optimizations are related to control flow graph (CFG) processing.  Therefore, such optimizations work at the procedure level.  The substitution allows you to use the entire context of the calling procedure to optimize the body of the substituted procedure.  Due to this, after substitution, a gain can be obtained, for example, from constant pulling, from cycle optimization, etc. </li></ul><br>  Can the substitution have a negative impact on performance?  Easy.  Due to the substitution, the size of the procedure code, the number of local variables placed on the stack can increase.  Both of these factors may affect the principle of code localization.  Those.  Because of the increase in the amount of executable code, the necessary instructions and data are less often cached and execution slows down.  In addition, the sprawl of code negatively affects the compilation time and the size of the executable files (which can be especially critical for mobile architectures).  The ‚Äúsmall‚Äù functions are a good exception for substitution, i.e.  those whose body contains fewer instructions than the cost of calling such functions.  Thus, like most optimizations, substitution is a double-edged sword.  Both the compiler and the programmer need criteria that determine which functions should be aimed at substituting in the first place, which in the second, and which should not be substituted at all. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Auto Subassembly </h4><br>  So, you can improve performance through substitution.  Naturally, such a fertile area for improving application performance can not be under the scrutiny of optimizing compilers.  Compilers can make substitutions automatically.  The user adds one option, and the optimizing compiler chooses which calls to leave intact and which ones to substitute. <br><br>  If you look at the Intel compiler options (icc ‚Äìhelp), then it is easy to find the enable button for this mechanism. <br><br><pre><code class="bash hljs">-inline-level=&lt;n&gt; control inline expansion: n=0 <span class="hljs-built_in"><span class="hljs-built_in">disable</span></span> inlining n=1 inline <span class="hljs-built_in"><span class="hljs-built_in">functions</span></span> declared with __inline, and perform C++ inlining n=2 inline any <span class="hljs-keyword"><span class="hljs-keyword">function</span></span>, at the compiler<span class="hljs-string"><span class="hljs-string">'s discretion</span></span></code> </pre> <br>  From this description of the options it is clear that there are several modes of operation.  In general, prohibit substitution, use directives for the compiler set by the programmer, allow the compiler to choose the objects for optimization.  Those.  The option <i>‚Äìinline-level = 2</i> is what we need, and it is this option that is used by default.  Also in this list is a huge number of options of the form: <br><br><pre> <code class="bash hljs">inline-max-total-size=&lt;n&gt; maximum increase <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> size <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inline <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> expansion -no-inline-max-total-size no size <span class="hljs-built_in"><span class="hljs-built_in">limit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> inline <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> expansion -inline-max-per-routine=&lt;n&gt; maximum number of inline instances <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> any <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> -no-inline-max-per-routine no maximum number of inline instances <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> any <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> -inline-max-per-compile=&lt;n&gt; maximum number of inline instances <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the current compilation -no-inline-max-per-compile no maximum number of inline instances <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the current compilation -inline-factor=&lt;n&gt; <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> inlining upper limits by n percentage</code> </pre><br>  From this it is clear that the statement of the problem for an automatic substitute is to implement substitution of functions in such a way as to achieve the best performance and fit within a certain framework of increasing the program code.  It can be seen that there are options in the list that control the sprawl of the program code as a whole, and the sprawl of each procedure. <br><br><h4>  Substitution Utility Criteria </h4><br>  Let's try to evaluate the quality of the compiler's performance when performing automatic substitution.  To do this, it is necessary to develop some obvious criterion for the usefulness of the substitution and understand whether it can be used. <br><br>  In my opinion, we can formulate the following approximate criterion for the advantage of substitution.  Each substitution carries some costs that degrade the quality of the entire program as a whole, but it also improves the quality of the particular code fragment where the substitution is made. <br>  The simplest case, when the substitution is unprofitable, in my opinion, looks like this: <br><br><pre> <code class="cpp hljs">If (almost_always_false) { Foo(); }</code> </pre><br>  In this case, we received all the negative consequences of the substitution of the function Foo, ‚Äúlocalized‚Äù on the stack of the calling function its local variables, increased the size of the code of the calling function.  But the function is almost never called and our locally enhanced code snippet is not used, that is, the costs do not pay off.  Thus, when making a substitution decision, it would be good to know how hot a particular challenge is.  The proposed criterion is the following: the more often a function is called when it is executed, the more profitable it is to inline it.  The second obvious factor is the size of the function.  The smaller the size of the function, the more profitable it is to substitute, since in this case we will be able to accommodate more substitutions in the boundaries determined by the expansion threshold of the program. <br><br>  It is obvious that you can come up with many more different criteria for the substitution utility, for example, to consider that it is more profitable to inline calls within cycles, if inlineing helps vectorization or it is more profitable to inline a call with constant arguments, etc.  It is not entirely clear how the compiler can obtain this knowledge before making the decision on inlining without complicating the analysis and increasing the compilation time.  Some cases where substitution is beneficial are not obvious until this benefit is obtained.  For example, in the interprocedural analysis, we are unlikely to understand that thanks to the substitution, we are guaranteed to benefit from vectorization.  Because for this you need to do almost all the work that is done during the optimization of the procedure, before making a decision about inlining. <br><br>  If there are restrictions on the growth of the code, the order in which the decision about inlining is made becomes very important.  The compiler bypasses all calls in a certain order and makes a decision about the substitution.  At the same time, it changes the size of the calling function and checks whether the code sprawl limit has been exceeded.  If at first some substitutions were made inside the called function, then the size of its code is no longer equal to the original at the moment of the decision to make the substitution.  It is possible to manipulate heuristics that make decisions about profitability, but if at the moment of making a decision the limits of code expansion are already exceeded, then the compiler will not inline such a function.  For quite large projects, the situation of reaching the limits of code sprawl is very ordinary. <br><br><img src="https://habrastorage.org/files/d23/b42/523/d23b4252329b4f70b8cde15d73ce6f73.png" alt="image"><br><br>  It is easy to calculate the size of the code of the function being injected, although it can change a lot after substitution or some optimizations, but the compiler does not have knowledge of which parts of the code of the calling function are ‚Äúhot‚Äù and which are not at compile time.  The compiler has a profiler who ‚Äúthoughtfully looking at‚Äù the procedure code tries to estimate the probability of a particular transition, and, thanks to his work, a certain weight is assigned to each continuous fragment of the procedure being processed.  Unfortunately, the profiler estimates are very approximate and cause an analogy with a well-known anecdote about a blonde who was asked about the likelihood of meeting a dinosaur.  "50 to 50, or an appointment or not," replied the blonde.  And it was absolutely right in terms of logic and optimizing compiler!  The authors of the anecdote suggest that the blonde should know something about dinosaurs.  But if there is no knowledge, then the answer is quite logical.  Almost all if transitions get a 50% chance.  Well, you can still tell fortunes on the coffee grounds on how many iterations the average statistical cycle has for non-constant lower and upper bounds. <br><br>  In general, the task of determining the weight of a code is already complex at the level of a single function.  And what can be said about the weight of a particular call within the framework of the entire program?  It may be that the function has a very ‚Äúhot‚Äù challenge inside.  Yes, it can only happen that the function itself is terribly ‚Äúcold‚Äù and almost never gets control.  It turns out that, in a good way, you need to have a method for estimating the importance of each call within the program, which would analyze both the call graph and the control flow graph for each function, and put the weight for each arc in the call graph on the basis of such an analysis.  But such estimates may be completely inaccurate.  The real weight of each call is very much dependent, for example, on the set of input data. <br><br>  Actually, this idea is illustrated by drawing to my post.  Here, based on the CFG analysis, I tried to highlight the cold and hot calls (the faces of the call graph).  Red color means ‚Äúhot‚Äù areas within the procedure, and red arrows are hot calls.  Unfortunately, as already emphasized, all of this coloring can be different for different input data sets.  Placing a believable weight when compiling is very difficult. <br><br><h4>  Criterion Testing </h4><br>  Nevertheless, the proposed criterion is quite simple and in accordance with it it can be said that, other things being equal, it is more advantageous to substitute the calls occurring in cycles.  It is less profitable to substitute the challenges encountered after checking various conditions.  It seems that this is obvious?  Let's check if compilers use this consideration?  Let's write something extremely obvious.  In this example, the same function is substituted, so from the point of view of the size of the called function, all calls are the same.  The frequency with which calls are used depends on which constants the user enters. <br><br><pre> <code class="cpp hljs">Cat main.c <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; static void inline foo(int i) { printf("foo %d\n",i); } int main() { int n,k,m; printf("Enter 3 integer numbers\n"); scanf("%d",&amp;n); scanf("%d",&amp;k); scanf("%d",&amp;m); foo(1); for(int i=0; i&lt;n; i++) { foo(2); } for(int i=0; i&lt;n; i++) { for(int j=0; j&lt;m; j++) { foo(3); } } foo(4); foo(5); if(n&lt;k) foo(6); if(n&lt;m) if(k&lt;m) foo(7); foo(8); foo(9); }</span></span></span></span></code> </pre><br>  It is interesting to see in what order the Intel compiler will inline these calls.  It is easy to investigate by adding the <i>‚Äìinline-max-total-size = XX</i> option to the compilation line and gradually changing the value of this variable from 0 upwards. <br><br><pre> <code class="bash hljs">icc -std=c99 -inline-max-total-size=XX -ip main.c init.c</code> </pre><br><br>  It turns out that the order of substitutions in main will be the following: foo (7), foo (9), foo (8), foo (6), foo (3), foo (5), foo (2), foo (4), foo (1). <br>  It is seen that in this case, the considerations on the "weight" of each call are not used.  The compiler does not try to guess which calls occur more often. <br><br>  I have done a similar procedure with gcc. <br>  The compilation line was as follows: <br><br><pre> <code class="bash hljs">gcc ‚ÄìO2 --param large-function-insns=40 --param large-function-growth=XX -std=c99 main.c init.c -o aout_gcc</code> </pre><br><br>  The <i>‚ÄìO2</i> option includes <i>-finline-small-functions</i> , and in this case gcc substitutes ‚Äúsmall‚Äù functions, the substitution of which, in theory, does not greatly affect the size of the calling function. <br>  The <i>‚ÄìO3</i> option includes <i>-finline-functions</i> when all functions are considered candidates for substitution. <br>  I set the <i>large-function-insns parameter</i> so that my main function becomes ‚Äúbig‚Äù and its expansion is controlled by the <i>large-function-growth</i> parameter.  Increasing the numerical value starting from zero, we get the order in which the gcc substitutions for _O2 do: foo (9), foo (8), foo (7), foo (6), foo (5), foo (4), foo (3), foo (2), foo (1).  Those.  gcc makes substitutions strictly in order.  With ‚ÄìO3, the order is: foo (3), foo (9), foo (2), foo (8), foo (7), foo (6), foo (5), foo (4), foo (1) .  I like this order more.  At the very least, gcc has shown respect for the calls within the cycles. <br><br><h4>  Test results.  Can you help the compiler? </h4><br>  This experiment showed that the order in which compilers perform substitution may not be optimal.  The compiler can substitute "unfavorable" calls, then reach the threshold for expanding the function being processed and stop its work with it.  As a result, performance will suffer.  If, when analyzing your application, you see some small non-inline functions in a hot spot, then there are two reasons for this situation: the compiler did not find a specific call to be beneficial for the substitution or the substitution decision was not made due to exceeding the code extension threshold.  This can be affected by changing the threshold values ‚Äã‚Äãor by placing attributes of the <i>inline</i> type on the function.  Since changes in threshold values ‚Äã‚Äãcannot be made for a specific function, such a change will increase the size of the entire application.  The same can be said about the <i>inline</i> attribute.  The attribute will affect both ‚Äúhot‚Äù and ‚Äúcold‚Äù calls.  In this case, inline does not guarantee substitution if the code expansion thresholds are already exceeded.  A more powerful attribute is always_inline.  In this case, the function will always be inline. <br><br>  More targeted substitution can be influenced by pragmas.  Pragmas affect a specific call, and they can be used to achieve more accurate targeting of what exactly is inline.  There are <i>#pragma inline, #pragma noinline, #pragma forceinline</i> .  <i>#pragma inline</i> affects the compiler solution and helps, if the code sprawl threshold is not yet exceeded, but the compiler does not consider substitution beneficial.  <i>#pragma forceinline</i> - obliges the compiler to make a substitution. <br><br>  Returning to our example.  Substitution of the <i>inline</i> attribute does not help in this example.  You can ask the compiler to make the substitution more aggressively and substitute the definition of the function foo with the attribute <i>always_inline</i> : <br>  <i>static void inline foo (int) __attribute __ ((always_inline));</i> <br>  This will lead to the fact that all calls will be substituted (despite the violation of expansion thresholds).  This method has an obvious disadvantage - both cold and hot calls will be substituted.  More optimal is the use of pragmas.  I rewrite the code of the main function in this form: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n,k,m; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Enter 3 integer numbers\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">scanf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,&amp;n); <span class="hljs-built_in"><span class="hljs-built_in">scanf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,&amp;k); <span class="hljs-built_in"><span class="hljs-built_in">scanf</span></span>(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>,&amp;m); foo(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; i++) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> forceinline foo(2); } for(int i=0; i&lt;n; i++) { for(int j=0; j&lt;m; j++) { #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> forceinline foo(3); } } foo(4); foo(5); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(n&lt;k) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> noinline foo(6); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(n&lt;m) </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(k&lt;m) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> noinline foo(7); foo(8); foo(9); }</span></span></code> </pre><br>  Those.  It turned out a working algorithm to improve application performance: <br><ul><li>  Build the app. </li><li>  Gather information about hot parts of the application using, for example, Vtune Amplifier. </li><li>  Check whether there are non-submitted calls on these sites and zainlaynit them using pragmas. </li><li>  Check how it affected the performance of the application. </li></ul><br><br><h4>  Substitution profitability criterion and dynamic profiler </h4><br>  It is clear that this method is resource-intensive, especially because of the use of the Amplifier and the need to examine something with my eyes.  Fortunately, there is a fairly reliable means of optimizing substitutions - a dynamic profiler.  The dynamic profiler is used to get an idea of ‚Äã‚Äãthe hot parts of the program and to estimate the frequency of calls to certain functions. <br>  I am conducting the following experiment with the original text of my mini-program: <br><br><pre> <code class="bash hljs">icc -std=c99 init.c main.c -prof_gen -o prof_a ./prof_a &lt; 345.txt &gt;&amp; prof_out</code> </pre><br><br>  Here, an instrumented application was created using the <i>‚Äìprof_gen</i> option.  Then this application was launched, as a result of its work, a file with the dyn extension appeared, containing collected statistics on the application operation.  Running the compiler with the <i>‚Äìprof_use</i> option allows you to use these statistics to optimize the application.  File 345.txt contains input constants 3,4,5.  <i>By</i> manipulating the <i>‚Äìinline-max-total-size</i> option, I get the order in which the compiler substitutes functions. <br><br><pre> <code class="bash hljs">icc -std=c99 -prof-use -inline-max-total-size=XX -ip main.c init.c</code> </pre><br>  The order is: foo (3), foo (2), foo (7), foo (9), foo (8), foo (7), foo (6), foo (5), foo (4), foo (one).  If you look at the output of the application, it is clear that most of the calls were made 1 time and only foo (3) and foo (2) were called more often.  Thanks to the dynamic profiler, the compiler was able to better determine the order of functions for the substitution. <br>  Now we change the input data for the constants (n = 5, k = 4, m = 3).  In this case, foo (6) and foo (7) are not called.  Delete (!) The previous file with statistics and, repeating the experiment, we get a new order: foo (3), foo (2), foo (9), foo (8), foo (5), foo (4), foo (1 ).  Calls foo (6) and foo (7) were not substituted even with a large code expansion threshold.  (Which certainly pleases). <br>  If you do not delete the file with statistics, then we get a file that reflects the statistics of the two launches. <br><br>  Well, we will do the same for gcc 4.9 in the same way. <br><br><pre> <code class="bash hljs">gcc -O2 -fprofile-generate -std=c99 main.c -o aout_gcc_prof ./aout_gcc_prof &lt; 543.txt</code> </pre><br>  There was a file with statistics with the extension gdca. <br><br><pre> <code class="bash hljs">gcc -O2 -fprofile-use --param max-unrolled-insns=0 --param large-function-insns=40 --param large-function-growth=XX -std=c99 main.c -o aout_gcc</code> </pre><br><br>  By manipulating c XX, one can see that after receiving information from the dynamic profiler, the gcc and icc compilers behave the same, i.e.  do substitution in accordance with the actual weight of each call. <br>  Considering the code with different options and even more so in cases of different compilers is quite interesting.  Here, for example, at the moment when the gcc compiler has already substituted foo (3), but the code expansion threshold did not allow to substitute foo (2), gcc made a clone of the foo function to call from 2. That is, I created a new function without arguments with a constant tightened 2. At the same time, both compilers tried to improve the locality of the code and brought the ‚Äúcold code‚Äù to a separate location.  Icc at the end of the main routine, and gcc created a separate section, main.cold, for this.  When you run the instrumented compiler with 543.txt input data, these sections have foo (6) and foo (7) calls. <br><br><h4>  findings </h4><br>  Of course, the experiment described here is not complete, and it could be expanded by analyzing whether the compiler takes into account, forming a queue of calls for substitution, other factors, for example, the size of the function for substitution.  One could try to understand in what order the call graph, etc., are bypassed.  But in general, the following conclusion was obtained.  Without a dynamic profiler, compilers do not attempt to guess the possible ‚Äúweight‚Äù or possible frequency of a particular call.  Accordingly, the order of substitutions looks quite random.  In the case of dynamic profiling, when the weight of each call is determined experimentally, both compilers use this information, and as a result, the order of substitutions fully corresponds to the criterion proposed here.  Those.  the best substitution benefits can be obtained using a dynamic profiler. <br><br>  Well, developers can effectively use pragmas in their work to tell the compiler which calls should be inlined first.  If it is clear to the programmer that some calculations will be performed rarely, then it makes sense to put them into separate functions and forbid them to be substituted with directives.  This will improve the locality of the executed code and, most likely, will lead to a small performance gain due to more optimal use of the cache subsystem. <br><br>  <i>A beautiful blonde and a dinosaur are borrowed from publicly available Internet resources, not containing references to the authors of these materials and any restrictions for borrowing them:</i> <i><br></i>  <i>1. <a href="http://www.pinterest.com/">www.pinterest.com</a></i> <i><br></i>  <i>2. <a href="http://solnushki.ru/">solnushki.ru</a></i> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/240203/">https://habr.com/ru/post/240203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../240193/index.html">Where to find an incentive, or how we went to the Microsoft hackathon</a></li>
<li><a href="../240195/index.html">Geek competition: how we did it (part 1)</a></li>
<li><a href="../240197/index.html">How to speed up the container: we tune OpenVZ</a></li>
<li><a href="../240199/index.html">Opera Developer Bookmark Sync</a></li>
<li><a href="../240201/index.html">New Wi-Fi for the Internet of Things (Part 1)</a></li>
<li><a href="../240207/index.html">Print outsourcing: how to save on printing with active paper workflow</a></li>
<li><a href="../240209/index.html">Latent semantic analysis: implementation</a></li>
<li><a href="../240213/index.html">How do we cluster gifts in OK</a></li>
<li><a href="../240217/index.html">Lapis: Lua site in Nginx configs</a></li>
<li><a href="../240219/index.html">Expressive JavaScript: An Introduction</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>