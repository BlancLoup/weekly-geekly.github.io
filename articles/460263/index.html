<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Making a really smart search: step by step guide</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Search in the corporate information system - already from the phrase itself gets bogged down in the mouth. Well, if it is at all, you can not even thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Making a really smart search: step by step guide</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>Search in the corporate information system</em> - already from the phrase itself gets bogged down in the mouth.  Well, if it is at all, you can not even think about the positive user experience.  How to turn the attitude of users spoiled by search engines, and create a fast, accurate, half-word product?  It is necessary to take a good piece of Elasticsearch, a handful of intellectual services and mix them in this guide. </p><br><p>  There are already plenty of articles on how to add an Elasticsearch-based full-text search to the existing database.  But the articles on how to do a really smart search are clearly not enough. </p><br><blockquote>  At the same time, the phrase ‚ÄúSmart Search‚Äù has already turned into a buzzword and is used to the site and not.  So what should a search engine do to be considered smart?  Ultimately, this can be described as the output of a result that the user actually needs, even if this result does not quite match the query text.  Popular search engines like Google and Yandex go further and not only find the necessary information, but directly answer user questions. </blockquote><p>  Okay, we will not aim at the ultimatum at once, but what can be done to bring <em>an ordinary</em> full-text search closer to an <em>intelligent one</em> ? </p><a name="habracut"></a><br><h2 id="elementy-intellektualnosti">  Elements of intellectuality </h2><br><p>  Smart search is just the case when quantity can turn into quality and a lot of small and fairly simple features can form a sense of magic. </p><br><ul><li>  Correction of user errors - whether it is a typo, a wrong layout, or maybe a query with a suspiciously small number of results, but similar to a query on which there is much more information. </li><li>  Behind <del>  th </del>  NLP chat (natural language processing, not what you thought) - if the user entered <em><strong>commercial offers for the last year</strong></em> , did he really want to search for these words in the text of all documents or did he really only need commercial offers and only for the last year ? </li><li>  Input prediction based on previous queries or popular documents. </li><li>  Presentation of the result - the usual highlighting of the found fragment, additional information depending on what you were looking for.  Since in the previous paragraph, commercial proposals were needed, then maybe it makes sense to immediately show the subject of the proposal and from which organization did it come? </li><li>  Easy drilldown - the ability to refine the search query using additional filters, facets. </li></ul><br><h2 id="vvodnaya">  Introductory </h2><br><p>  There is an ECM DIRECTUM with a lot of documents in it.  The document consists of a card with meta information and a body, which can have several versions. </p><br><p>  The goal is to quickly and conveniently search for information in these documents in a manner familiar to search engine users. </p><br><h2 id="indeksirovanie">  Indexing </h2><br><blockquote>  In order to search for something well, you need to index it in the beginning. </blockquote><p>  Documents in ECM are not static, users modify text, create new versions, change data in cards;  New documents are constantly being created and sometimes old ones are deleted. <br>  To maintain up-to-date information in Elasticsearch, documents must be constantly re-indexed.  Fortunately, ECM already has its own asynchronous event queue, so when changing a document, it‚Äôs enough to add it to the queue for indexing. </p><br><h3 id="otobrazhenie-dokumentov-ecm-na-dokumenty-elasticsearch">  Displaying ECM documents on Elasticsearch documents </h3><br><p>  The body of a document in ECM can have several versions.  In Elasticsearch, this could be represented as an array of nested objects, but then it becomes inconvenient to work with them - writing queries is complicated, if you change one of the versions, you need to reindex everything, different versions of the same document cannot be stored in different indexes (why is this necessary? in the next section).  Therefore, we will denormalize one document from ECM into several Elasticsearch documents with the same card but different bodies. </p><br><p>  In addition to the card and the body, different service information is added to the Elasticsearch document, in which it is worth mentioning separately: </p><br><ul><li>  list of IDs of groups and users who have rights to the document - for search with consideration of rights; </li><li>  the number of references to the document - for tuning relevance; </li><li>  last indexing time. </li></ul><br><h3 id="sostav-indeksov">  The composition of the indices </h3><br><p>  Yes, indexes are in the plural.  Usually, several indexes for storing information similar in meaning to Elasticsearch are used only if this information is immutable and is tied to a certain time interval, for example logs.  Then the indices are created every month / day or more often depending on the intensity of the load.  In our case, any document can be changed, and it would be possible to store everything in a single index. </p><br><p>  But - documents in the system can be in different languages, and storing multilingual data in Elasticsearch has 2 problems: </p><br><ul><li>  Wrong stemming.  For some words, the base will be found correctly, for some - incorrectly (there will be another word in the index), for some - it will not be found at all (the index will be clogged with word forms).  For some words from different languages ‚Äã‚Äãand having different meanings, the basis will coincide, and then the meaning of the word will be lost.  The use of several stemmers in a row can lead to the computation of the basis of an already computed one. </li></ul><br><blockquote>  Stemming - finding the basis of the word.  The stem does not have to be the root of the word or its normal form.  Usually it is enough that the related words are projected into one base. <br>  Lemmatization is a kind of stemming in which the normal (dictionary) form of a word is considered the basis. </blockquote><br><ul><li>  Incorrect word frequency.  Some of the mechanisms for determining relevance in ES take into account the frequency of the searched words in the document (the more often, the higher the relevance) and the frequency of the searched words in the index (the more often, the lower the relevance).  So, a small blotch of Russian speech in an English document, when the index is mainly English documents, will have a high weight, but it is worth mixing English and Russian documents in the index, and the weight will go down. </li></ul><br><p>  The first problem can be solved for the case when different languages ‚Äã‚Äãuse different character sets (Russian-English documents use Cyrillic and Latin) - language stemmers will only process "their" characters. </p><br><p>  Just to solve the second problem, we used an approach with a separate index for each language. </p><br><p>  Combining both approaches, we obtain language indices, which nevertheless contain analyzers for several non-intersecting language symbol sets at once: Russian-English (and separately English-Russian), Polish-Russian, German-Russian, Ukrainian-English, etc. . </p><br><p>  In order not to create all possible indexes in advance, we used index templates - Elasticsearch allows you to specify a template that contains settings and mappings, and specify the index name pattern.  If you try to index a document into a nonexistent index, whose name matches one of the template patterns, not only will a new index be created, but the settings and mappings from the corresponding template will be applied to it. </p><br><h3 id="struktura-indeksov">  Index structure </h3><br><p>  For indexing, we use two analyzers at once (via multi-fields): default to search for the exact phrase and custom for everything else: </p><br><pre><code class="json hljs"><span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"custom"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span>}</code> </pre> <br><p>  With the lowercase filter, everything is clear, I'll tell you about the rest. </p><br><p>  The russian_morphology and english_morphology filters are designed for morphological analysis of Russian and English text, respectively.  They are not part of Elasticsearch and are put as part of a separate analysis-morphology plugin.  These are lemmatizers using a vocabulary approach in combination with some heuristics and working significantly, SIGNIFICANTLY, better than the built-in filters for the respective languages. </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"russian"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  AND: </p><br><pre> <code class="json hljs">POST _analyze { <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"ru_en_analyzer"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">"   "</span></span> } &gt;&gt;   </code> </pre> <br><p>  Very curious word_delimiter filter.  He, for example, helps to eliminate typos, when there is no space after the dot.  We use the following configuration: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"catenate_all"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_original"</span></span>: <span class="hljs-string"><span class="hljs-string">"true"</span></span> }</code> </pre> <br><p>  yo_filter allows you to ignore the difference between E and E: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"mapping"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"mappings"</span></span>: [ <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span>, <span class="hljs-string"><span class="hljs-string">" =&gt; "</span></span> ] }</code> </pre> <br><p>  ru_en_stopwords filter with type stop - our dictionary of stop words. </p><br><h3 id="process-indeksirovaniya">  Indexing process </h3><br><p>  The bodies of documents in ECM are, as a rule, office files: .docx, .pdf, etc.  To extract the text, use the ingest-attachment plugin with the following pipeline: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"document_version"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"attachment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target_field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_length"</span></span>, <span class="hljs-string"><span class="hljs-string">"content_type"</span></span>, <span class="hljs-string"><span class="hljs-string">"language"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"indexed_chars"</span></span>: <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"lang"</span></span>: <span class="hljs-string"><span class="hljs-string">"painless"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"languages"</span></span>: [<span class="hljs-string"><span class="hljs-string">"ru"</span></span>, <span class="hljs-string"><span class="hljs-string">"en"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"language_delimeter"</span></span>: <span class="hljs-string"><span class="hljs-string">"_"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"remove"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"attachment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"ignore_failure"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } ] } }</code> </pre> <br><p>  From the unusual to the pipeline - ignoring the absence of body errors (this happens for encrypted documents) and determining the target index, based on the text language.  The latter is done in a painless script, the body of which I will give separately, because  due to JSON limitations, it has to be written in one line.  Coupled with the difficulties of debugging (the recommended way is to generate exceptions here and there), it altogether turns into painful. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.languages.contains(ctx.attachment.language)) ctx._index = ctx._index + <span class="hljs-keyword"><span class="hljs-keyword">params</span></span>.language_delimeter + ctx.attachment.language; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content = ctx.attachment.content; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_length != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_length = ctx.attachment.content_length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.content_type != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.content_type = ctx.attachment.content_type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.attachment.language != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) ctx.language = ctx.attachment.language; }</code> </pre> <br><p>  Thus, we always send the document to <em>index_name</em> .  If the language is not defined or not supported, then the document is deposited in this index, otherwise it falls into <em>index_name_language</em> . </p><br><p>  We do not store the original file body itself, but the _source field is enabled, since  it is required to partially update the document and highlight the found. </p><br><p>  If only the card has changed since the last indexing, then to update it we use the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html">Update By Query API</a> without a pipeline.  This allows, firstly, not to pull potentially heavy document bodies from ECM, and secondly, it significantly speeds up the update on the Elasticsearch side - it is not necessary to extract the text of documents from office formats, which is very resource-intensive. </p><br><blockquote>  As such, there is no update of the document in Elasticsearch; technically, when updating from an index, the old document gets, changes and is again fully indexed. </blockquote><p>  But if the body was changed, then the old document is deleted and indexed from scratch.  This allows documents to <em>move</em> from one language index to another. </p><br><h2 id="poisk">  Search </h2><br><p>  For ease of description, here is a screenshot of the final result. </p><br><p><img src="https://habrastorage.org/webt/ni/l4/xm/nil4xm-qrg7meikrjbd16mt_ziq.png"></p><br><h3 id="polnotekst">  Fulltext </h3><br><p>  The main type of query we use is <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html">Simple Query String Query</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"simple_query_string"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"card.d*.*_text"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.d*.*_text.exact"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name.exact^2"</span></span>, <span class="hljs-string"><span class="hljs-string">"content"</span></span>, <span class="hljs-string"><span class="hljs-string">"content.exact"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"default_operator"</span></span>: <span class="hljs-string"><span class="hljs-string">"or"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyze_wildcard"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"minimum_should_match"</span></span>: <span class="hljs-string"><span class="hljs-string">"-35%"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"quote_field_suffix"</span></span>: <span class="hljs-string"><span class="hljs-string">".exact"</span></span> }</code> </pre> <br><p>  where <em>.exact</em> are fields indexed by the <em>default</em> analyzer.  The importance of the name of the document is two times higher than the other fields.  The combination of <code>"default_operator": "or"</code> and <code>"minimum_should_match": "-35%"</code> allows you to find documents that do not have up to 35% of the searched words. </p><br><h3 id="sinonimy">  Synonyms </h3><br><p>  In general, different analyzers are used for indexing and searching, but the only difference in them is the addition of a filter to add synonyms to the search query: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"search_analyzer"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"lowercase"</span></span>, <span class="hljs-string"><span class="hljs-string">"russian_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"english_morphology"</span></span>, <span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>, <span class="hljs-string"><span class="hljs-string">"word_delimiter"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru_en_stopwords"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"char_filter"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"yo_filter"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"tokenizer"</span></span>: <span class="hljs-string"><span class="hljs-string">"standard"</span></span> }</code> </pre> <br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"synonym_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonym_graph"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"synonyms_path"</span></span>: <span class="hljs-string"><span class="hljs-string">"synonyms.txt"</span></span> }</code> </pre> <br><h3 id="uchyot-prav">  Accounting rights </h3><br><p>  To search with rights, the main query is embedded in <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html">Bool Query</a> , with the addition of a filter: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"simple_query_string"</span></span>: {...} } ], <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"rights"</span></span>: [           ] } } ] }</code> </pre> <br><p>  As we remember from the section on indexing, there is a field in the index with the IDs of users and groups that have rights to the document.  If there is an intersection of this field with the transferred array, then there are rights. </p><br><h3 id="tyuning-relevantnosti">  Tuning Relevance </h3><br><p>  By default, Elasticsearch evaluates the relevance of the results using the <a href="https://ru.wikipedia.org/wiki/Okapi_BM25">BM25</a> algorithm using the query and the text of the document.  We decided that three more factors should influence the conformity assessment of the desired and actual results: </p><br><ul><li>  the last time the document was edited - the farther it was in the past, the less likely it is that this document is needed; </li><li>  the number of references to the document - the more, the more likely that this document is needed; </li><li><p>  body versions in ECM have several possible states: developed, active, and obsolete.  It is logical that acting is more important than the others. </p><br><p>  This effect can be achieved with the help of <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html">Function Score Query</a> : </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"function_score"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"functions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"gauss"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"modified_date"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"now"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"scale"</span></span>: <span class="hljs-string"><span class="hljs-string">"1095d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"offset"</span></span>: <span class="hljs-string"><span class="hljs-string">"31d"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"decay"</span></span>: <span class="hljs-number"><span class="hljs-number">0.5</span></span> } } }, { <span class="hljs-attr"><span class="hljs-attr">"field_value_factor"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"access_count"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"modifier"</span></span>: <span class="hljs-string"><span class="hljs-string">"log2p"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"term"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"life_stage_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">1.1</span></span> } ], <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: {...} } }</code> </pre> <br><p>  As a result, other things being equal, it turns out that the result rating modifier is approximately as dependent on the date of its last change X and the number of hits Y: </p><br></li></ul><br><p></p><div style="text-align:center;"> <a href="https://www.wolframalpha.com/input/%3Fi%3Dexp(-max(0,%2Bx%2B-%2B31)%255E2%2B%252F%2B(2%2B*%2B-((365*3)%255E2%2B%252F%2B(2*ln(0.5)))))*%2Blog10(y%2B%252B%2B2)%2Bplot%2B0%2B%253C%253Dx%2B%253C%253D%2B1000,%2B1%2B%253C%253D%2By%2B%253C%253D%2B1000"><img src="https://habrastorage.org/webt/wa/wz/td/wawztd9zvlz-fetkplnfrjw8ddy.png"></a> </div><p></p><br><h3 id="vneshniy-intellekt">  External intelligence </h3><br><p>  For a part of the smart search functionality, we need to extract various <em>facts</em> from a search query: dates with an indication of their application (creation, modification, approval, etc.), names of organizations, types of documents sought, etc. </p><br><p>  It is also desirable to classify the request into a specific category, for example, documents by organization, by employee, regulatory, etc. </p><br><p>  These two operations are performed by the intelligent ECM module - <a href="https://www.directum.ru/ario">DIRECTUM Ario</a> . </p><br><h3 id="process-umnogo-poiska">  Smart search process </h3><br><p>  It is time to take a closer look at what mechanisms are implemented elements of intelligence. </p><br><h4 id="ispravlenie-oshibok-polzovatelya">  Correction of user errors </h4><br><p>  Determining the correctness of the layout occurs on the basis of the trigram language model - for a string it is calculated how likely it is to meet its three-character sequences in texts in English and Russian.  If the current layout is considered less likely, then, firstly, a tooltip with the corrected layout is shown: </p><br><p><img src="https://habrastorage.org/webt/ek/ow/c5/ekowc5ikjiwx1xe87b5wewhoohm.png"></p><br><p>  and secondly, the further stages of the search are performed with the corrected layout: </p><br><p><img src="https://habrastorage.org/webt/ug/dr/tc/ugdrtchejvx024datttkc_zcxxw.png"></p><br><p>  And if nothing is found with the corrected layout, the search starts with the original string. </p><br><p>  Errata corrected using <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-phrase.html">Phrase Suggester</a> .  There is a problem with it - if you execute a query on several indexes at the same time, then suggest may not return anything, while performing only on one index results.  This <em>is treated by</em> setting confidence = 0, but then suggest suggests replacing the words with their normal form.  Agree, it will be strange when searching for ‚Äúletter <strong>a</strong> ‚Äù to get an answer in the spirit: <em>Perhaps you were looking for a letter <strong>about</strong> ?</em> </p><br><p>  This can be bypassed by using two suggesters at once in the request: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"content_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} } }, } }, <span class="hljs-string"><span class="hljs-string">"check_suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"text"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"phrase"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"collate"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {         {{suggestion}} - ({{source_query}}) }, <span class="hljs-string"><span class="hljs-string">"params"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source_query"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span> } }, } } }</code> </pre> <br><p>  Of the common parameters are used </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"confidence"</span></span>: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-string"><span class="hljs-string">"max_errors"</span></span>: <span class="hljs-number"><span class="hljs-number">3.0</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  If the first suggester returns the result, and the second does not, then this result is the original line itself, perhaps with words in other forms, and the hint should not be shown.  In case the prompt is still required, the original search phrase merges with the prompt.  This occurs by replacing only the corrected words and only those that the spell checker (used by Hunspell) deems incorrect. </p><br><p>  If a search on the source line returns 0 results, it is replaced with the merged string and the search is performed again: </p><br><p><img src="https://habrastorage.org/webt/up/r3/wx/upr3wxky4mkbeyy3exjocbwzocy.png"></p><br><p>  Otherwise, the resulting string with hints is returned only as a hint for the search: </p><br><p><img src="https://habrastorage.org/webt/qv/ts/4t/qvts4tauspo9yspwy_itbzcdttq.png"></p><br><h4 id="klassifikaciya-zaprosov-i-izvlechenie-faktov">  Query classification and fact extraction </h4><br><p>  As I already mentioned, we use DIRECTUM Ario, namely the text classification service and the fact extraction service.  To do this, we gave analysts anonymous search queries and a list of facts that interest us.  On the basis of inquiries and knowledge of what documents are in the system, analysts identified several categories and trained the classification service to determine the category according to the query text.  Based on the resulting categories and a list of facts, we formulated the rules for using these facts.  For example, the phrase <em><strong>last year</strong></em> in the category <strong>Everything</strong> is considered the date the document was created, and in the category <strong>By organization</strong> , the date of registration.  At the same time, <em><strong>created in the last year</strong></em> should fall into the creation date in any category. </p><br><p>  From the search side, a config was made, in which categories were assigned, which facts were applied to which facet filters. </p><br><h4 id="avtodopolnenie-vvoda">  Auto-complete input </h4><br><p>  In addition to the aforementioned layout corrections, past user search queries and publicly available documents fall into auto completion. </p><br><p><img src="https://habrastorage.org/webt/zc/52/yo/zc52yohihrkkrnny6ekla80-mro.png"></p><br><p>  They are implemented using a different type of Suggester, the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-completion.html">Completion Suggester</a> , but each has its own nuances. </p><br><h5 id="avtodopolnenie-istoriya-poiskov">  Autocompletion: Search History </h5><br><p>  There are far fewer users in ECM than search engines and to allocate for them a sufficient number of common queries. <del>  why is Lenin a mushroom </del>  does not seem possible.  Show everything in a row is also not worth it for reasons of privacy.  Regular Completion Suggester can search only for the entire set of documents in the index, but <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/suggester-context.html">Context Suggester</a> comes to the rescue - a way to set a certain context for each hint and filter it by these contexts during the search.  If we use user names as contexts, then everyone can only be shown his history. </p><br><p>  You also need to give the user the opportunity to remove the hint for which he is ashamed.  As a key to delete, we used the username and the text of the tooltip.  As a result, the index with hints turned out to be a slightly duplicated mapping: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"mappings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"document"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"properties"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"completion"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"analyzer"</span></span>: <span class="hljs-string"><span class="hljs-string">"simple"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_separators"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"preserve_position_increments"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"max_input_length"</span></span>: <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-attr"><span class="hljs-attr">"contexts"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"user"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"CATEGORY"</span></span> } ] }, <span class="hljs-attr"><span class="hljs-attr">"user"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"keyword"</span></span> } } } }</code> </pre> <br><p>  The weight for each new hint is set to one and increases with each repeated input using the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-update-by-query.html">Update By Query API</a> with a very simple <code>ctx._source.suggest.weight++</code> script. </p><br><h5 id="avtodopolnenie-dokumenty">  Autocompletion: Documents </h5><br><p>  But there are a lot of documents and possible combinations of rights.  Therefore, here we, on the contrary, decided not to do filtering by rights for auto-completion, but to index only publicly available documents.  Yes, and delete individual tips from this index is not necessary.  It would seem that implementation in everything is easier than the previous, if not for two points: </p><br><p>  The first one - Completion Suggester supports only prefix search, and clients so much like to assign nomenclature numbers to everything, and some <code>.01.01   </code> as you type in the query <em><strong>Abbreviation rules are</strong></em> not found.  Here, together with the full name, you can index n-grams derived from it: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"extension"</span></span>: <span class="hljs-string"><span class="hljs-string">"pdf"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"suggest"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">70</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">" "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">80</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">90</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"input"</span></span>: <span class="hljs-string"><span class="hljs-string">".01.01   "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> } ] }</code> </pre> <br><p>  With the story it was not so critical, yet the same user enters about the same line if he searches for something again.  <em>Probably</em> </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bi/rc/dv/bircdvzu2hvcblxhrryvauzajf0.png"></div><br><p>  The second is that by default all the hints are equal, but we would like to make some of them more equal and preferably so that it is consistent with the ranking of the search results.  To do this, approximately repeat the functions gauss and field_value_factor, used in <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html">Function Score Query</a> . </p><br><p>  It turns out such a pipeline: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"dir_public_documents_pipeline"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"processors"</span></span>: [ ... { <span class="hljs-attr"><span class="hljs-attr">"set"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: <span class="hljs-string"><span class="hljs-string">"{{name}}"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"split"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"terms_array"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"separator"</span></span>: <span class="hljs-string"><span class="hljs-string">"\\s+|$"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"script"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: <span class="hljs-string"><span class="hljs-string">"..."</span></span> } } ] } }</code> </pre> <br><p>  with the following script: </p><br><pre> <code class="cs hljs">Date modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Date(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.modified_date != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) modified = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SimpleDateFormat(<span class="hljs-string"><span class="hljs-string">'dd.MM.yyyy'</span></span>).parse(ctx.modified_date); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> dayCount = (System.currentTimeMillis() - modified.getTime())/(<span class="hljs-number"><span class="hljs-number">1000</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">24</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> score = Math.exp((<span class="hljs-number"><span class="hljs-number">-0.7</span></span>*Math.max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dayCount - <span class="hljs-number"><span class="hljs-number">31</span></span>))/<span class="hljs-number"><span class="hljs-number">1095</span></span>) * Math.log10(ctx.access_count + <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = ctx.terms_array.length; ctx.suggest = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(); ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">'input'</span></span>: ctx.terms_array[count - <span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-string"><span class="hljs-string">'weight'</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - count + <span class="hljs-number"><span class="hljs-number">1</span></span>)) ]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = count - <span class="hljs-number"><span class="hljs-number">2</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ; --i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx.terms_array[i].trim() != <span class="hljs-string"><span class="hljs-string">""</span></span>) { ctx.suggest.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>([ <span class="hljs-string"><span class="hljs-string">"input"</span></span>: ctx.terms_array[i] + <span class="hljs-string"><span class="hljs-string">" "</span></span> + ctx.suggest[ctx.suggest.length - <span class="hljs-number"><span class="hljs-number">1</span></span>].input, <span class="hljs-string"><span class="hljs-string">"weight"</span></span>: Math.round(score * (<span class="hljs-number"><span class="hljs-number">255</span></span> - i))]); } } ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'terms_array'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'access_count'</span></span>); ctx.<span class="hljs-keyword"><span class="hljs-keyword">remove</span></span>(<span class="hljs-string"><span class="hljs-string">'modified_date'</span></span>);</code> </pre> <br><p>  Why bother with a painless pipeline instead of writing it in a more convenient language?  Because now with the help of the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-reindex.html">Reindex API</a> into the index for prompts, you can overtake the contents of search indexes (indicating only the required fields, of course) literally into one command. </p><br><p>  The composition of really necessary publicly available documents is not often updated, so this command can be left on manual start. </p><br><h3 id="otobrazhenie-rezultatov">  Results display </h3><br><h4 id="kategorii">  Categories </h4><br><p>  The category determines which facets will be available and what the snippet will look like.  It can be determined automatically by <em>external intelligence</em> or selected manually above the search bar. </p><br><h4 id="fasety">  Facets </h4><br><p>  Facets are such an intuitive thing for everyone, whose behavior, however, is described by very non-trivial rules.  Here are a few of them: </p><br><ol><li><p>  The values ‚Äã‚Äãof the facets depend on the search results, BUT and the search results depend on the selected facets.  How to avoid recursion? </p><br></li><li><p>  Choosing values ‚Äã‚Äãwithin one facet does not affect other values ‚Äã‚Äãof this facet, but affects values ‚Äã‚Äãin other facets: </p><br></li></ol><br><p><img src="https://habrastorage.org/webt/60/ei/g6/60eig601ltskcwvcesh5zno8crc.png"></p><br><ol><li>  The facet values ‚Äã‚Äãselected by the user should not disappear, even if a choice in another facet <em>annihilates</em> them to 0 or they are no longer in the top: </li></ol><br><p><img src="https://habrastorage.org/webt/mu/6u/e-/mu6ue-ybxh3sa9h6ymkj1idn_ti.png"></p><br><p>  In elastica, facets are implemented through an aggregation mechanism, but in order to comply with the described rules, these aggregations have to be invested into each other and filtered by each other. </p><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zd/jt/zu/zdjtzudyw9iei8x-tjarja-a5tm.jpeg"></div><br><p>  Consider the query fragments responsible for this: </p><br><div class="spoiler">  <b class="spoiler_title">Too big piece of code</b> <div class="spoiler_text"><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"post_filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"must"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } } ] } }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} <span class="hljs-string"><span class="hljs-string">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"card.author_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"filter"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.author_value_id"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"1951063"</span></span> ] } }, <span class="hljs-attr"><span class="hljs-attr">"aggs"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"editor_value_id"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"exclude"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"editor_value_id_selected"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"terms"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"editor_value_id"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"2337706"</span></span>, <span class="hljs-string"><span class="hljs-string">"300643"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"missing"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } } } }, ... } }</code> </pre> </div></div><br><p>  What is there that: </p><br><ul><li>  <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-post-filter.html">post_filter</a> allows <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-post-filter.html">you</a> to impose an additional condition on the results of an already executed query and does not affect the results of the aggregations.  The same recursion gap.  Includes all selected values ‚Äã‚Äãof all facets. </li><li>  top-level aggregations, in the example <em>card.author_value_id</em> and <em>editor_value_id</em> .  Each has: <br><ul><li>  filter by the values ‚Äã‚Äãof all other facets except its own; </li><li>  nested aggregation for selected facet values ‚Äã‚Äã- <em>protection against annihilation</em> ; </li><li>  nested aggregation for the remaining facet values.  Showing the top 10, and requesting the top 11 - to determine whether to display the button <strong>Show All</strong> . </li></ul></li></ul><br><h4 id="snippety">  Snipples </h4><br><p>  Depending on the category chosen, the snippet may look different, for example, the same document when searching in a category </p><br><p>  <strong>All</strong> : </p><br><p><img src="https://habrastorage.org/webt/ka/_b/ia/ka_biaaygfgbsk2msyfhu-bnkse.png"></p><br><p>  and <strong>Employees</strong> : </p><br><p><img src="https://habrastorage.org/webt/5i/po/k_/5ipok_qgkc9170ucyidespnnitc.png"></p><br><p>  Or remember, we wanted to see the subject of a commercial offer and from whom did it come? </p><br><p><img src="https://habrastorage.org/webt/-i/7z/g7/-i7zg7dwh7kbs9e9_2yk3fnxc6k.png"></p><br><p>  In order not to drag the entire card from the elastic (this slows down the search), <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-source-filtering.html">Source filtering is used</a> : </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"_source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"includes"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.name"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.card_type_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"card.life_stage_value_id"</span></span>, <span class="hljs-string"><span class="hljs-string">"extension"</span></span>, ... ] }, <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... }</code> </pre> <br><p>  For highlighting the found words in the text of the document, the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html">Fast Vector highlighter</a> is used - as it generates the most adequate snippets for large texts, and for the name - <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html">Unified highlighter</a> - as the least demanding of resources and index structure: </p><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"highlight"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"pre_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"post_tags"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"&lt;/strong&gt;"</span></span> ], <span class="hljs-attr"><span class="hljs-attr">"encoder"</span></span>: <span class="hljs-string"><span class="hljs-string">"html"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"card.name"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"content"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"fragment_size"</span></span>: <span class="hljs-number"><span class="hljs-number">300</span></span>, <span class="hljs-attr"><span class="hljs-attr">"number_of_fragments"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"fvh"</span></span> } } },</code> </pre> <br><p>  In this case, the name is highlighted in its entirety, and from the text we obtain up to 3 fragments with a length of 300 characters.  The text returned by the Fast Vector highlighter is additionally compressed with a homemade algorithm to get the minimized state of the snippet. </p><br><h3 id="kollaps">  Collapse </h3><br><p>  Historically, users of this ECM have become used to having <em>documents</em> returned to them, but in fact Elasticsearch is searching among <em>document versions</em> .  It may happen that several almost identical versions will be found for the same query.  This will clutter up the results and confuse the user.  Fortunately, this behavior can be avoided with the help of the <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-collapse.html">Field Collapsing</a> mechanism - some lightweight variant of aggregation, which works already on the finished results (in this it resembles post_filter, <em>two crutches are a pair</em> ).  The result of the <em>collapse</em> will be the most relevant of the collapsing objects. </p><br><pre> <code class="json hljs">{ ... <span class="hljs-attr"><span class="hljs-attr">"query"</span></span>: {...} ... <span class="hljs-string"><span class="hljs-string">"collapse"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"field"</span></span>: <span class="hljs-string"><span class="hljs-string">"id"</span></span> } }</code> </pre> <br><p>  Unfortunately, the collapse has a number of unpleasant effects, for example, various numerical characteristics of the search result continue to return as if there was no collapse.  That is, the number of results, the number of facet values ‚Äã‚Äã- all will be <em>slightly</em> wrong, but the user usually does not notice this, as well as the tired reader, who has hardly read this sentence. </p><br><p>  The end. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/460263/">https://habr.com/ru/post/460263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460253/index.html">10 reasons to make your skill for voice assistant</a></li>
<li><a href="../460255/index.html">Backdoor on Node.js: why, why, and how it works</a></li>
<li><a href="../460257/index.html">Hello, World! Deep immersion in terminals</a></li>
<li><a href="../46026/index.html">XNA + C # vs DirectX + C ++ v OpenGL. What's better? And why?</a></li>
<li><a href="../460261/index.html">Amazon: 25 years of success in e-commerce</a></li>
<li><a href="../460265/index.html">Creating an Xcode Project Template</a></li>
<li><a href="../460273/index.html">Authorization in Apple Pay for the smallest</a></li>
<li><a href="../460275/index.html">Why don't you need the perfect solution</a></li>
<li><a href="../460279/index.html">The contract for 10 billion: who will deal with the cloud for the Pentagon</a></li>
<li><a href="../46028/index.html">How not to make a login form in the Internet bank</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>