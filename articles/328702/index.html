<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>State synchronization in multiplayer games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The problem of multiplayer games 
 One of the most difficult tasks of multiplayer games is to synchronize the states of all players with the state of ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>State synchronization in multiplayer games</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/efd/24c/d05/efd24cd05378241a2a725f3065992aa4.png" alt="image"><br><br><h2>  The problem of multiplayer games </h2><br>  One of the most difficult tasks of multiplayer games is to synchronize the states of all players with the state of the server.  There are good articles on the Internet on this topic.  However, they lack some details that can confuse newcomers to programming games.  I hope that I can explain everything in this article. <br><br>  I will designate several techniques commonly used to solve such problems.  Before proceeding to the problem, let's briefly consider the principle of multiplayer games. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Usually a game program should simulate the following: <br><br>  <i>changes in the environment, taking into account the time and data entered by players</i> . <br><br>  A game is a program that stores a state, so it depends on time (real or logical).  For example, PACMAN simulates an environment in which ghosts constantly move. <br><br>  Multiplayer is no exception, but because of the interaction of players, its complexity is much higher. <br><a name="habracut"></a><br>  <em>Take, for example, the classic game "Snake":</em> <br><br>  Suppose we use a client-server architecture.  Game logic works as follows: <br><br><ol><li>  Reading the data entered by the player, changing the direction of movement of the snake.  They can have one of the meanings: [‚Üê, ‚Üë, ‚Üí, ‚Üì]. </li><li>  Application of input data if available.  This changes the direction of the snake. </li><li>  Move the snake to one unit of measurement space. </li><li>  Checking the presence of a collision of each of the snakes with the enemy / wall / body, then removing them from the game. </li><li>  Repeat the cycle. </li></ol><br>  This logic should be executed on the server at regular intervals.  As shown below, each cycle is called a <i>frame (frame)</i> or a <i>beat (tick)</i> . <br><br><pre><code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Server</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/** * 1.    ,    : [‚Üê, ‚Üë, ‚Üí, ‚Üì]. * 2.     ,     . * 3.       . * 4.    //    ,    . * 5.      . */</span></span> <span class="hljs-type"><span class="hljs-type">Thread</span></span>.sleep(<span class="hljs-number"><span class="hljs-number">100</span></span>) } } }</code> </pre> <br>  The simplest client reads server updates and renders each received frame for the player. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Client</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onServerUpdate</span></span></span></span>(state: <span class="hljs-type"><span class="hljs-type">GameState</span></span>) = { renderGameState(state) } }</code> </pre> <br><hr><br><h2>  Fixed state update </h2><br><h3>  Concept </h3><br>  To ensure synchronization of all clients, the easiest way is to ensure that the client sends updates to the server at fixed intervals.  For example, take an interval of 30 milliseconds.  The update contains user-entered data, which may also contain a value of <i>no user-entered data</i> . <br><br>  After receiving input from <strong>all users</strong> , the server can proceed to the next cycle, taking into account this data. <br><img src="https://habrastorage.org/getpro/habr/post_images/d9d/0fb/1a8/d9d0fb1a8ca939f9fcef1c8ccf6e3e5c.png"><br><br>  The figure above shows the interaction of a single client with a server.  I hope the problem is as obvious for you as it is for me: the client may be idle on the interval from <strong>T0</strong> to <strong>T1</strong> , waiting for the update to continue from the server.  Depending on the quality of the network, the delay can vary from 50 to 500 ms, and modern players notice delays of more than 100 ms.  Therefore, braking the user interface for 200 ms will be a <em>huge problem</em> for some games. <br><br>  This is not the only complexity of the approach with a fixed interval. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/907/654/24d/90765424d993d0ca48e3b1fa16dbfd70.png"><br><br>  The picture above is a bit more complicated; it demonstrates interaction with a server of several clients.  You can see that client B has a slower network connection, so although A and B send input data to <strong>T0</strong> to the server, the update from B reaches the server at <strong>T2</strong> , and not at <strong>T1</strong> .  Therefore, the server continues to calculate only when it receives all the updates, that is, in <strong>T2</strong> . <br><br>  <strong>What does it mean?</strong> <br>  <i>The delay of the game is now equal to the delay of the ‚Äúlagging‚Äù player.</i> <br>  It turns out that we punish all the players because one of them has a slow connection.  Therefore, sooner or later all the players will leave your game ... <br><br>  Not to mention the fact that there is a possibility of disconnecting the client B, which will block the actions of the server until the connection timeout expires. <br><br><h3>  Discussion </h3><br>  In addition to the two problems mentioned above, there are a few more: <br><br><ol><li>  The client will not respond until it receives a status update from the server (which is terrible from the user's point of view). </li><li>  Responsiveness of the game depends on the most "lagging" players.  Do you play DSL with a friend?  Good luck! </li><li>  The connection will be very "talkative": customers need to regularly send useless data so that the server can confirm that it has all the necessary information to continue, and this is ineffective. </li></ol><br>  First, games of a certain type are immune from these problems, for example, most turn-based games use variations of this model, because the customer has to wait. <br><br>  For slow games, a small delay is also acceptable.  A good example is <strong>Farm Ville</strong> . <br><br>  Another good example is <strong>chess</strong> , in which two players take turns and each turn lasts about 10 seconds. <br><br><ol><li>  Users must wait for each other for 10 seconds.  And they are waiting. </li><li>  Two players take turns in turn, so the delay of one does not affect the other. </li><li>  Each turn takes an average of 5 seconds (one request every 5 seconds is enough). </li></ol><br>  But what about fast games?  For example, for all FPS because of such problems, the solution with fixed intervals is not suitable.  In the rest of this article, we will learn how to solve these problems. <br><br><hr><br><h2>  Customer forecasting </h2><br>  Let's first solve the player response problem.  The game reacts after 500 ms after the player has pressed the button, because of which the game process collapses. <br><br>  <em>How to solve this problem?</em> <br><br><h3>  Concept </h3><br>  Some readers already know the answer: instead of waiting for a server update, the client actually emulates the game by executing the game logic locally (that is, on the client‚Äôs machine). <br><br>  Suppose to calculate the state of a game in <code>Tn</code> we need to know the state in <code>Tn-1</code> and the data entered by the user in <code>Tn-1</code> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/e99/793/201e9979326ae3df209eb75bd9b885e5.png"><br><br>  The idea is simple: let's make a fixed update rate, which in our example is equal to <i>one unit of time</i> . <br><br>  The client sends the input to the server at <strong>T0</strong> to emulate the game state at <strong>T1</strong> , so the client can then render the game without waiting for a status update from the server, which will only be received at <strong>T3</strong> . <br><br>  This approach only works in the following conditions: <br><br><ol><li>  Game state updates are deterministic, i.e.  there is no chance or it is transparent, and the server with the client can play the same game states from the same input data. </li><li>  The client has all the information necessary to execute the game logic. </li><li>  Note: 1 <em>this is not always true,</em> but we can try to make them as similar as possible and ignore small differences, for example, floating-point calculations on different platforms, and use the same seed for a pseudo-random algorithm. </li></ol><br>  Point 2 is also not always true.  I will explain: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/632/7d0/727/6327d07270e5cf1af10135088e9527e9.png"><br><br>  In the picture above, client A is still trying to emulate the state of the game in <strong>T1</strong> using information obtained in <strong>T0</strong> , but client B has already sent input data to <strong>T0</strong> that client A. does not know about. <br><br>  This means that customer A's prediction about <strong>T1</strong> will be wrong.  Fortunately, since client A still receives the <strong>T1</strong> status from the server, it has the ability to correct its error in <strong>T3</strong> . <br><br>  <i>The client side needs to find out if the previous emulation was correct and how conflicts can be resolved.</i> <br><br>  Conflict resolution is usually called <strong>Reconcilation</strong> . <br><br>  The implementation of the <strong>agreement</strong> depends on the specific conditions of use.  I will show the simplest example in which we simply give up the prediction and replace it with the exact state received from the server. <br><br><ol><li>  The client needs to store two buffers: one for forecasts, the other for input data.  It can later be used to calculate forecasts.  Remember that the <strong>state Tn is</strong> calculated from the <strong>state Tn-1</strong> and the <strong>input data Tn-1</strong> , which will first be empty. <br><img src="https://habrastorage.org/getpro/habr/post_images/e76/c2e/91c/e76c2e91c98c5669781ab9e2bb637377.png"></li><li>  When a player presses an arrow key, the input is saved to the InputBuffer, and the client performs the prediction, which is then used for visualization.  The forecast is saved in PredictionBuffer. <br><img src="https://habrastorage.org/getpro/habr/post_images/ff6/1a5/e3d/ff61a5e3dcfc41a1c9a2e4f6a00504fa.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/85e/fa5/1a0/85efa51a0e8ee9848f30d1840267c23f.png"></li><li>  At the time of receiving the <strong>State0</strong> state from the server, it does not match the client‚Äôs <strong>Prediction0</strong> forecast, so we can replace <strong>Prediction0</strong> with <strong>State0</strong> and recalculate <b>Prediction1</b> taking into account <strong>Input0</strong> and <strong>State0</strong> . <br><img src="https://habrastorage.org/getpro/habr/post_images/ecd/63c/c30/ecd63cc30214bd0818ccf93b2768c0b0.png"></li><li>  After negotiation, we can safely remove <strong>State0</strong> and <strong>Input0</strong> from the buffer.  Only after that we can confirm that everything is correct. <br><img src="https://habrastorage.org/getpro/habr/post_images/8c6/55d/8b3/8c655d8b3cf7f85628ccfaf9633d30a2.png"></li></ol><br>  Note: reconciliation has a flaw.  If the server state and the client's forecast are too different, then rendering may cause visual errors.  For example, if we predict that in <strong>T0 the</strong> enemy moves south, but in <strong>T3</strong> we understand that he moved north, then we coordinate the data by simply using the state from the server.  The enemy abruptly changes its direction in order to display the correct position. <br><br>  There are ways to deal with this problem, but they will not be covered in this article. <br><br><h3>  Discussion </h3><br>  Client-side prediction techniques have a huge advantage: the client works with its own update rate (independent of the server update rate), so when the server ‚Äúslows down‚Äù, this does not affect the frame rate on the client side. <br><br>  But this is inevitably associated with a certain complexity: <br><br><ol><li>  We need to handle more states and logic on the client (prediction buffer, state buffer, prediction logic). </li><li>  We need to decide how to resolve conflicts between the forecast and the real state on the server. </li></ol><br>  And we still have old problems! <br><br><ol><li>  Visualization errors due to incorrect predictions. </li><li>  Frequent exchange of useless data. </li></ol><br><h2>  Conclusion </h2><br>  In this part we have considered only two ways to implement a network connection in multiplayer games: <br><br><ol><li>  Fixed state update </li><li>  Client side prediction </li></ol><br>  Each of them has its own set of compromises, and we still have not considered in more detail what is happening on the server side. <br><br><h2>  Interesting related articles </h2><br><ul><li>  <strong>Gabriel</strong> Fast paced multiplayer article series: <br>  <a href="http://www.gabrielgambetta.com/fpm1.html">http://www.gabrielgambetta.com/fpm1.html</a> .  Translation of articles on Habr√©: <a href="https://habrahabr.ru/post/302394/">parts 1 and 2</a> , <a href="https://habrahabr.ru/post/302834/">part 3</a> , <a href="https://habrahabr.ru/post/303006/">part 4</a> . </li><li>  The basics of the <strong>gafferongames</strong> network game: <br>  <a href="http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/">http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/</a> </li><li>  Valve's article: <br>  <a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking">https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking</a> </li></ul><br><h2>  What is the role of the server? </h2><br>  Let's start by defining server actions.  Typical server tasks: <br><br>  a) Connecting point for players <br>  In a multiplayer game, players need a common endpoint to communicate with each other.  This is one of the roles of the server program.  Even in the P2P communication model, there is a connecting point for exchanging network information for setting up a P2P connection. <br>  b) Information processing <br>  In many cases, the server executes the game simulation code, processes all data entered by players, and updates the game state.  It is worth considering that this is not always the case: some modern games shift most of the processing to the client.  In this article, I will assume that it is the server that is responsible for processing the game, that is, for example, for creating game bars. <br>  c) A single source of the true state of the game <br>  In many multiplayer games, the server program also has power over the state of the game.  The main reason for this is protection against cheating.  In addition, it is much easier to navigate when there is a single point for obtaining the correct state of the game. <br><br><h2>  Naive server implementation </h2><br>  Let's start the implementation of the server in the most straightforward way, and then improve it. <br><br>  The core of the game server is a loop that performs a GameState update based on user input.  This cycle is usually called TICK (tact) and is indicated as follows: <br><br> <code>(STATE <sub>n</sub> , INPUT <sub>n</sub> ) =&gt; STATE <sub>n+1</sub></code> <br> <br>  A simplified snippet of server code might look like this: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceivedInput</span></span></span></span>(i: <span class="hljs-type"><span class="hljs-type">UserInput</span></span>) = { storeInputToBuffer(i) } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(!gameEnded) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allUserInputs = readInputFromBuffer() currentState = step(currentState, allUserInputs) <span class="hljs-comment"><span class="hljs-comment">// .. (STATEn , INPUTn) =&gt; STATEn+1 sendStateToAllPlayers(currentState) }</span></span></code> </pre> <br><h3>  Discussion </h3><br>  I hope the code snippet looks intuitive and straightforward for you: the server simply accepts input from the buffer and applies it in the following <code>TICK</code> function to get the new GameState state.  Let's call this approach a <i>greedy game loop</i> , because it tries to process data as quickly as possible.  This is normal, if you do not think about our imperfect Universe, in which sunlight reaches the Earth in eight minutes. <br><br>  Here again, delay becomes important. <br><br>  The fact that the server processes buffer input from each <code>TICK</code> means that GameState depends on network latency.  The diagram below shows why this is becoming a problem. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/73a/bdb/287/73abdb28701f7ba7286067ca40baade3.png"><br><br>  The diagram shows two clients sending input to the server.  We see two interesting facts. <br><br><ol><li>  Requests take different time between different clients and server: <strong>1</strong> unit of time from client A to server, <strong>1.5</strong> units of time from client B to server. </li><li>  Requests take different time for one client: the first request took <strong>1</strong> unit of time, the second - <strong>2</strong> units of time. </li></ol><br>  In short, the delay is variable, even for the same connection. <br><br>  A variable delay combined with a <i>greedy game cycle</i> leads to several problems.  We will look at them below. <br><br><table cellpadding="5"><tbody><tr><td><h4>  Client side prediction does not work </h4><br></td><td>  If we cannot predict the time at which the server will receive the input data (due to a delay), we cannot make predictions with high accuracy. </td></tr><tr><td><h4>  Low latency players take advantage </h4><br></td><td>  If the input data gets to the server faster, they will be processed faster, which creates an unfair advantage for players with fast networks.  For example, if two players shoot each other at the same time, they will have to kill each other at the same time, but player B has a lower delay, so he kills player A before the team of player A is processed. </td></tr></tbody></table>  To smooth out a non-constant delay, there is a simple solution ‚Äî the above-described update with a fixed step.  The server does not continue the calculations until it receives input from all players.  There are two advantages to this approach: <br><br><ol><li>  No client side prediction required </li><li>  All players will have the same delay as the slowest player, eliminating the aforementioned advantage. </li></ol><br>  However, this approach does not work in fast active games due to low responsiveness. <br><br>  In the next section we will talk about how to make the server side work in fast games. <br><br><h2>  Reconcile on server </h2><br>  To solve the problem of inaccurate client-side prediction, we need to make client-server interaction more predictable from the client's point of view.  When a player presses a key on the client side, the client program needs to know when this input will be processed on the server side. <br><br>  One possible way to do this is to <strong>allow the client to suggest when the input should apply</strong> .  Thus, the client side will be able to accurately predict the time of their application.  The term ‚Äúoffer‚Äù is used because the server can reject this offer if it is incorrect, for example, the player tries to cast a spell, although his mana has run out. <br><br>  Input data should be applied almost immediately after data entry by the player, for example, <strong>T <sub>input</sub> + X</strong> , where X is the delay.  The exact value depends on the game, for responsiveness a delay of less than 100 ms is usually required.  Note that X can be zero.  In this case, the data is applied immediately after user input. <br><br>  Let's take X = 30 ms, which is approximately equal to one frame at 30 frames per second.  To transfer data to the server requires 150 ms, then there is a high probability that when the input data reaches the server, the frame for input will already be skipped. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b92/393/832/b9239383223aa7e34411d79039c78c2d.png"><br><br>  Look at the diagram: user A has pressed a key at <strong>T.</strong>  This data should be processed in <strong>T + 30 ms</strong> , but the input data due to the delay is received by the server at <strong>T + 150 ms</strong> , which is already outside of <strong>T + 30 ms</strong> .  We will deal with this problem in this section. <br><br>  <i>How does the server use input that should have happened in the past?</i> <br><br></p><h3>  Concept </h3><br>  You probably remember that forecasting on the client side had the same problem with inaccurate forecasts due to lack of information about opponents.  Incorrect predictions were later corrected by status updates from the server using reconciliation.  The same technique can be used here.  The only difference is that we fix GameState on the server based on data entered by customers. <br><br>  All user input must have a time stamp.  These tags are used to tell the server when to process them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/efd/24c/d05/efd24cd05378241a2a725f3065992aa4.png"><br>  <i>Note: on the first dashed line <strong>Time X</strong> on the client side, but <strong>Time Y</strong> on the server side.</i>  <i>This is an interesting feature of multiplayer games (and many other distributed systems): since the client and server work independently, the time on the client and on the server is usually different.</i>  <i>Our algorithm allows us to cope with this difference.</i> <br><br>  The diagram above shows the interaction between the same client and server. <br><br><ol><li>  The client sends the input with a time stamp, telling the server that this data from client A should occur in Time X. </li><li>  The server receives a request in Time Y. Suppose that Time X is earlier than Time Y. When developing an algorithm, we must accept that Time Y is greater or less than Time X, this will provide us with greater flexibility. </li><li>  <strong>The red field</strong> is the moment of the reconciliation.  The server must apply Input X to the last state of the game, so that input X seems to have occurred in Time X. </li><li>  Transmitted by the GameState server also contains a timestamp, which is necessary for the coordination of both the server side and the client side. </li></ol><br><h4>  Details of coordination ( <strong>red field</strong> ) </h4><br><ol><li>  The server must store <br><br><ul><li>  <strong>GameStateHistory</strong> - the history of the state of the GameState during the time frame <strong>P</strong> , for example, all GameState for the last second. </li><li>  <strong>ProcessedUserInput</strong> - UserInput input data history processed per time frame <strong>P</strong> , for example, the same value as GameStateHistory time frame </li><li>  <strong>UnprocessedUserInput</strong> - received but not yet processed UserInput, also in time frame <strong>P</strong> <br><img src="https://habrastorage.org/getpro/habr/post_images/796/86d/216/79686d216b10f99d4a84b8aa56e78aa4.png"></li></ul><br></li><li>  When the server receives input from a user, it must be inserted into <strong>UnprocessedUserInput</strong> . </li><li>  Then, in the next frame server <br><br><ol><li>  Checks for input to <strong>UnprocessedUserInput</strong> that is older than the current frame. </li><li>  If they are not there, then everything is in order, the game logic is simply executed with the latest GameState and the corresponding input data (if available), and broadcast to customers. </li><li>  If they are, then this means that some of the previously generated game states are erroneous due to missing information, and we need to fix this. </li><li>  First we need to find the oldest raw input, for example, during Time N, (hint: this operation is performed quickly if <strong>UnprocessedUserInput is</strong> sorted). </li><li>  Then we need to get the corresponding GameState state in Time N from the <strong>GameStateHistory</strong> and the processed input data in Time N from <strong>ProcessedUserInput</strong> </li><li>  With these three pieces of data, we can create a new, more accurate Game State. <br><img src="https://habrastorage.org/getpro/habr/post_images/039/e8b/ca5/039e8bca5f53a5e94b95946f4a49fbba.png"></li><li>  Then we move the raw input data Unprocessed Input N to ProcessedUserInput so that it can be used in the future for reconciliation. </li><li>  Update GameState N in <strong>GameStateHistory</strong> </li><li>  Repeat steps 4 through 7 for <code>N+1, N+2 ...</code> until we get the latest GameState. </li><li>  The server sends its last frame to all players. </li></ol></li></ol><br><h3>  Discussion </h3><br>  Server side negotiation suffers from the same problems as client negotiation.  When coordination is needed, it means that we did something wrong, and we correct the mistake by changing the story.  This means that we cannot apply irreversible consequences, such as killing players.  Such irreversible effects can only be applied when they come from a <strong>GameStateHistory</strong> , i.e.  when they can no longer be overwritten. <br><br>  In addition, incorrect GameState sometimes lead to terrible UI jumps.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The diagram below shows how this happens. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/bb5/739/ac2/bb5739ac24980076204ed1af90df0ccf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The object is first located in the upper left corner and moves to the right. After five such he moves to the right, but then the server receives user input, indicating that the object has changed direction in Tick N, so the server coordinates the state of the game. In this case, the object suddenly </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jumps</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to the lower left corner of the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps I exaggerate this influence, sometimes the object moves not so far and the jump is less noticeable, but in many cases it is still obvious. We can control jumps by changing the size of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GameStateHistory</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnprocessedUserInput</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessedUserInput</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The smaller the buffer size, the smaller the jumps will be, because we will be less tolerant of heavily delayed input data. For example, if the entered data is delayed by more than 100 ms, then they are ignored, and a player with a ping for&gt; 200 ms will not be able to play the game. </font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can sacrifice </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tolerance to network delays</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for more </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accurate updating of the game state</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , or vice versa.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> There is one popular technique for dealing with the problem of inaccurate Game State - this is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpolation of objects</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entity Interpolation</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). The idea is to smooth out the jumps by stretching them for short periods of time. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/653/c70/ccb/653c70ccb9d45d2ab18062bc8aa0d7db.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article I will not describe the details of the implementation of </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interpolation of objects</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , however, I will provide useful links at the end. </font></font><br><br><h2>  Summarize </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We discussed how clients and servers work in multiplayer games. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f9/6c3/63d/3f96c363d59f8e4bab1dd33b8293800a.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, a multiplayer game contains three freely connectable cycles: a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">server game cycle</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client prediction cycle,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">client UI rendering cycle</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">By creating a buffer between them, you can divide the process of their execution, which gives us flexibility in creating a better gameplay.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This ends my article on multiplayer games. </font><font style="vertical-align: inherit;">I learned a lot about the topic from specialists in this field; an example of a </font></font><a href="https://github.com/buaya91/scalajs-snake"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple multiplayer game</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> also helped me a lot </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">I showed only one way to implement a multi-user server, there are others. </font><font style="vertical-align: inherit;">Choosing the right one depends on the type of game you are creating. </font><font style="vertical-align: inherit;">I recommend that you explore some of the approaches by creating a simple game. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks for reading, successful hacking!</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Links and additional reading </font></font></h2><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Interpolation of objects] - </font></font><a href="http://www.gabrielgambetta.com/fpm3.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://www.gabrielgambetta.com/fpm3.html</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Interpolation of objects] - </font></font><a href="http://gafferongames.com/networked-physics/snapshots-and-interpolation/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://gafferongames.com/networked-physics/snapshots-and-interpolation/</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Lag compensation] - </font></font><a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking#Lag_compensation</font></font></a> </li></ul><p></p></div><p>Source: <a href="https://habr.com/ru/post/328702/">https://habr.com/ru/post/328702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328690/index.html">SQL vs ORM</a></li>
<li><a href="../328692/index.html">Mitap over SQL Server: waiting only for you</a></li>
<li><a href="../328696/index.html">7 simple steps for successful CRM implementation</a></li>
<li><a href="../328698/index.html">Learning neural network geometry</a></li>
<li><a href="../328700/index.html">Tiled2Unity: export from Tiled Map Editor to Unity</a></li>
<li><a href="../328704/index.html">Why many still do not understand the essence of the blockchain</a></li>
<li><a href="../328706/index.html">Stable income without investments, or How Yandex began the hunt for fake earnings</a></li>
<li><a href="../328708/index.html">Development of a password manager for Android</a></li>
<li><a href="../328710/index.html">Google I / O 2017: notes from the event from the Android developer</a></li>
<li><a href="../328712/index.html">Five books on programming worth reading</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>