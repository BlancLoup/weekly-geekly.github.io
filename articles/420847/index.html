<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>An introduction to programming shaders for web designers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="WebGL has been around for a long time, quite a few articles have been written about shaders, there are a series of lessons. But in the bulk they are t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>An introduction to programming shaders for web designers</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/mx/-v/ry/mx-vryd99xgt73gzsgzhfvcqpe0.jpeg"></p><br><p>  WebGL has been around for a long time, quite a few articles have been written about shaders, there are a series of lessons.  But in the bulk they are too complicated for the maker.  It is even better to say that they cover large amounts of information that a game engine developer needs rather than a layout designer.  They immediately begin with the construction of a complex scene, camera, light ... On a regular site to create a pair of effects with photos, all this knowledge is redundant.  As a result, people make very complex architectural structures and write long-long shaders for very simple actions. </p><br><p>  All this prompted to create an introduction to those aspects of working with shaders, which are most likely to be useful in the work of the typesetter to create various 2D effects with pictures on the site.  Of course, taking into account the fact that they themselves are relatively rarely used in the design of interfaces by themselves.  We will make a starting pattern on pure JS without third-party libraries and consider ideas for creating some popular pixel-based effects that are difficult to make on SVG, but they are easily implemented using shaders. </p><a name="habracut"></a><br><blockquote> It is assumed that the reader is already familiar with <code>canvas</code> , in general terms represents what WebGL is, and has minimal knowledge of mathematics.  Some points will be described in a simplified, non-academic manner, with the goal of giving a practical understanding of the technologies for working with them, rather than a complete theory of their inner kitchen or terms for memorizing.  There are smart books for this. </blockquote><p>  <em>Immediately it should be noted that the editors from CodePen integrated into the article tend to affect the performance of what is being done in them.</em>  <em>So, before writing a comment that something is slowing down on your MacBook, make sure that the problem does not come from them.</em> </p><br><h2 id="osnovnye-idei">  Main ideas </h2><br><p>  <strong>What is a shader?</strong> </p><br><p>  What is a fragment shader?  In essence, this is a small program.  It is executed for each pixel on <code>anvas</code> .  If we have a <code>canvas</code> of 1000x500px, then this program will run 500,000 times, each time getting as its input parameters the coordinates of the pixel for which it is currently running.  This all happens on the GPU in many parallel threads.  On a central processor, such calculations would take much longer. </p><br><p>  The vertex shader is also a program, but it is executed not for every pixel on the <code>canvas</code> , but for every vertex in the figures, of which everything is built in three-dimensional space.  Also parallel for all vertices.  Accordingly, it receives the coordinates of the vertex as input, rather than a pixel. </p><br><p>  Further in the context of our task, the following happens: </p><br><ul><li>  We take a set of coordinates of the vertices of the rectangle, which then will be "drawn" picture. </li><li>  The vertex shader for each vertex counts its location in space.  In our case it will be reduced to a special case - a plane parallel to the screen.  Photos in 3d, we do not need.  The subsequent projection onto the screen plane can be said to do nothing. </li><li>  Further, for each visible fragment, and in our context for all pixel fragments, a fragmentary shader is executed, it takes a photo and current coordinates, counts something and gives out color for this particular pixel. </li><li>  If there was no logic in the fragment shader, then the behavior of all this would resemble the <code>drawImage()</code> method.  But then we add this very logic and get a lot of interesting things. </li></ul><br><p>  This is a very simplified description, but it should be clear who does what. </p><br><p>  <strong>A little about the syntax</strong> </p><br><p>  Shaders are written in GLSL - OpenGL Shading Language.  This language is very similar to C.  It makes no sense to describe the whole syntax and standard methods here, but you can always use the cheat sheet: </p><br><div class="spoiler">  <b class="spoiler_title">Spoiler with pictures</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/id/vb/6e/idvb6ew9k7ackf94bjviuxavhxc.jpeg"><br><img src="https://habrastorage.org/webt/ye/ax/b4/yeaxb44uvcjkhir92ezxcsnc2oo.jpeg"><br><img src="https://habrastorage.org/webt/f7/2q/5q/f72q5qifi99xwv5nsqfnkb2x1au.jpeg"><br><img src="https://habrastorage.org/webt/8c/ty/in/8ctyinenggjs8gutaj484oreep4.jpeg"></p></div></div><br><p>  Each shader has a main function with which its execution begins.  Standard input parameters for shaders and the output of the results of their work are implemented through special variables with the prefix <code>gl_</code> .  They are reserved in advance and are available inside these shaders.  So the vertex coordinates for the vertex shader are in the variable <code>gl_Position</code> , the fragment coordinates (pixel) for the fragment shader are in <code>gl_FragCoord</code> , etc.  You will always find the full list of available special variables in the same cheat sheet. </p><br><p>  The main types of variables in GLSL are fairly straightforward - <code>void</code> , <code>bool</code> , <code>int</code> , <code>float</code> ... If you worked with some C-like language, you have already seen them.  There are other types, in particular vectors of different dimensions - <code>vec2</code> , <code>vec3</code> , <code>vec4</code> .  We will constantly use them for coordinates and colors.  The variables we can create are of three important modifications: </p><br><ul><li>  <strong>Uniform</strong> - Global data in every sense.  Transmitted from the outside, the same for all calls to vertex and fragment shaders. </li><li>  <strong>Attribute</strong> - This data is already transmitted more precisely and for each shader call can be different. </li><li>  <strong>Varying</strong> - Needed to transfer data from vertex shaders to fragment. </li></ul><br><blockquote>  It is useful to prefix u / a / v to all the variables in the shaders to make it easier to understand what data it came from. </blockquote><p>  I believe that it is worthwhile to proceed to a practical example in order to immediately watch all this in action and not load your memory. </p><br><h2 id="gotovim-startovyy-shablon">  Preparing a start template </h2><br><p>  Let's start with JS.  As is usually the case when working with <code>canvas</code> , we need it and the context.  In order not to load the code of the examples, let's make global variables: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> CANVAS = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.canvas); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GL = canvas.getContext(<span class="hljs-string"><span class="hljs-string">'webgl'</span></span>);</code> </pre> <br><p>  Skip the moment associated with the size of the <code>canvas</code> and its recalculation when the browser window is resized.  This code is included in the examples and usually depends on the rest of the layout.  It makes no sense to focus on it.  Let's go straight to the action with WebGL. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">const</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shaders</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PROGRAM</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.vertex)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">attachShader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM, shaders.fragment)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linkProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useProgram</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PROGRAM)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><p>  First, we compile the shaders (will be a little lower), create the program, add both our shaders to it, and link it.  At this stage, the compatibility of shaders is checked.  Remember the varying variables that are passed from the vertex to the fragment?  - In particular, their sets are checked here, so that later in the process it would not turn out that something was not transferred or transferred, but not at all.  Of course, this check will not reveal logical errors, I think this is understandable. </p><br><p>  The coordinates of the vertices will be stored in a special buffer array and will be piece by piece, one vertex, transferred to each shader call.  Next we describe some details for working with these pieces.  First, we will use the coordinates of the vertex in the shader through the variable attribute <code>a_position</code> .  Can be differently called, it does not matter.  We get its location (this is something like a pointer in C, but not a pointer, but rather an entity number that exists only within the program). </p><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vertexPositionAttribute = GL.getAttribLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'a_position'</span></span>);</code> </pre> <br><p>  Next, we indicate that through this variable an array with coordinates will be transmitted (in the shader itself, we will perceive it as a vector).  WebGL will independently figure out exactly which coordinates of which points in our figures are passed to which shader call.  We only set the parameters for the array-vector, which will be transmitted: dimension - 2 (we will transmit coordinates <code>(x,y)</code> ), it consists of numbers and is not normalized.  Last parameters are not interesting to us, we leave zero by default. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.enableVertexAttribArray</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.vertexAttribPointer</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">vertexPositionAttribute</span></span>, 2, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.FLOAT</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>, 0, 0);</code> </pre> <br><p>  Now create the buffer itself with the coordinates of the vertices of our plane, on which the photo will be displayed later.  The coordinates "in 2d" are clearer, and for our tasks this is the most important thing. </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createPlane</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindBuffer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.ARRAY_BUFFER, GL.createBuffer()</span></span></span><span class="hljs-function">); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bufferData</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( GL.ARRAY_BUFFER, new Float32Array([ -1, -1, -1, 1, 1, -1, 1, 1 ])</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">STATIC_DRAW</span></span></span><span class="hljs-function"> ); }</span></span></code> </pre> <br><p>  This square will be enough for all our examples.  <code>STATIC_DRAW</code> means that the buffer is loaded once and then reused.  We will not download anything again. </p><br><p>  Before proceeding to the shaders themselves, let's look at their compilation: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getShaders</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">vertex</span></span>: compileShader( GL.VERTEX_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.vertex).textContent ), <span class="hljs-attr"><span class="hljs-attr">fragment</span></span>: compileShader( GL.FRAGMENT_SHADER, <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(IDs.shaders.fragment).textContent ) }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">compileShader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type, source</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> shader = GL.createShader(type); GL.shaderSource(shader, source); GL.compileShader(shader); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shader; }</code> </pre> <br><p>  Get the shader code from the elements on the page, create a shader and compile it.  In theory, you can store the shader code in separate files and load it during assembly as a string in the right place, but CodePen does not provide such an opportunity for examples.  Many lessons offer to write code directly in a line in JS, but to call it a convenient language does not turn.  Although of course the taste and color ... </p><br><p>  If an error occurs during the compilation, the script will continue execution showing a couple of warnings in the console that do not carry much meaning.  It is useful to look at the logs after compilation so as not to puzzle over what was not compiled there: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">console</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.log</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.getShaderInfoLog</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">shader</span></span>));</code> </pre> <br><blockquote>  WebGL provides several different options for tracking problems when compiling shaders and creating a program, but in practice it turns out that in real time we still can not fix anything.  So often we will be guided by the thought "fell off - it means fell off" and we will not load the code with a bunch of extra checks. </blockquote><p>  <strong>Go to the shaders themselves.</strong> </p><br><p>  Since we will have only one plane, with which we are not going to do anything, one simple vertex shader is enough for us, which we will do at the very beginning.  The main efforts will be focused on fragment shaders and all subsequent examples will be relevant to them. </p><br><blockquote>  Try to write shader code with more or less meaningful variable names.  In the network, you will find examples where functions of 200 characters of solid text will be assembled from single-letter variables, but the fact that someone does this does not mean that it is worth repeating.  Such an approach is not "the specifics of working with GL", it is a banal copy-paste of source codes from the last century, written by people who in their youth had limitations on the length of variable names. </blockquote><p>  For starters, the vertex shader.  The 2d vector with coordinates <code>(x,y)</code> , as we said, will be passed to the variable-attribute <code>a_position</code> .  The shader should return a vector of four values <code>(x,y,z,w)</code> .  It will not move anything in space, so along the z axis, just zero everything and put the value of w in the standard unit.  If you are wondering why there are four coordinates, rather than three, then you can use the online search for the query "homogeneous coordinates". </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'vertex-shader'</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">'x-shader/x-vertex'</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> precision mediump float; attribute vec2 a_position; </span><span class="hljs-keyword"><span class="actionscript"><span class="hljs-keyword">void</span></span></span><span class="actionscript"> main() { gl_Position = vec4(position, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">0</span></span></span><span class="actionscript">, </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1</span></span></span><span class="actionscript">); } </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  The result of the work is recorded in a special variable <code>gl_Position</code> .  Shaders do not have a <code>return</code> operator in the full sense of the word; they write all results of their work into variables specially reserved for these purposes. </p><br><blockquote>  Pay attention to the accuracy specification for the float data type.  To avoid some of the problems on mobile devices, the accuracy should be worse than highp and should be the same in both shaders.  Here it is shown as an example, but it will be good practice to turn off such beauty with shaders on phones. </blockquote><p>  To start, the fragment shader will always return the same color.  Our square will occupy the entire <code>canvas</code> , so in fact here we set the color for each pixel: </p><br><pre> <code class="hljs pgsql">&lt;script id=<span class="hljs-string"><span class="hljs-string">'fragment-shader'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=<span class="hljs-string"><span class="hljs-string">'x-shader/x-fragment'</span></span>&gt; <span class="hljs-type"><span class="hljs-type">precision</span></span> mediump <span class="hljs-type"><span class="hljs-type">float</span></span>; #define GOLD vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.86</span></span>, <span class="hljs-number"><span class="hljs-number">0.6</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>) <span class="hljs-type"><span class="hljs-type">void</span></span> main() { gl_FragColor = GOLD; } &lt;/script&gt;</code> </pre> <br><p>  You can pay attention to the numbers that describe the color.  This is familiar to all the RGBA makers, only normalized.  Values ‚Äã‚Äãare not integers from 0 to 255, but fractional values ‚Äã‚Äãfrom 0 to 1. The order is the same. </p><br><blockquote>  Do not forget to use the preprocessor for all magic constants in real projects - this makes the code more understandable without affecting performance (substitution, like in C, occurs during compilation). </blockquote><p>  It is worth noting one more thing about the preprocessor: </p><br><blockquote>  The use of constant checks #ifdef GL_ES in various lessons is devoid of practical sense, because  we have in the browser today, no other options for GL simply do not exist. </blockquote><p>  But it‚Äôs time to look at the result: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/JaoYMj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Golden square says that shaders work as expected.  It makes sense to play around with them a bit before moving on to working with photos. </p><br><p>  <strong>Gradient and Vector Conversions</strong> </p><br><p>  Usually in WebGL tutorials, you start by drawing gradients.  This has little practical meaning, but it will be useful to note a couple of points. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { gl_FragColor = vec4(gl_FragCoord.zxy / <span class="hljs-number"><span class="hljs-number">500.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  In this example, we use the coordinates of the current pixel as the color.  You will often see this in the examples in the network.  Both are vectors.  So no one bothers to mix everything in a pile.  TypeScript evangelists should have a seizure here.  The important point is how we get out of the vector only part of the coordinates.  Properties <code>.x</code> , <code>.y</code> , <code>.z</code> , <code>.xy</code> , <code>.zy</code> , <code>.xyz</code> , <code>.zyx</code> , <code>.xyzw</code> etc.  in different sequences allow you to pull out the elements of the vector in a certain order in the form of another vector.  Very conveniently implemented.  Also, a higher dimension vector can be made from a smaller dimension vector, adding the missing values, as we did. </p><br><blockquote>  Always explicitly specify the fractional part of the numbers.  There is no automatic conversion of int -&gt; float. </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/vzENvx" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <strong>Uniforms and the passage of time</strong> </p><br><p>  The next useful example is the use of uniforms.  This is the most common data for all shader calls.  We get their location in almost the same way as for attribute variables, for example: </p><br><pre> <code class="hljs delphi">GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_time'</span></span>)</code> </pre> <br><p>  Then we can set them values ‚Äã‚Äãbefore each frame.  Also, as with vectors, there are many similar methods starting with the word <code>uniform</code> , followed by the dimension of the variable (1 for numbers, 2, 3 or 4 for vectors) and type (f - float, i - int, v - vector) . </p><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(timeStamp)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniform1f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.getUniformLocation(PROGRAM, 'u_time')</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeStamp</span></span></span><span class="hljs-function"> / 1000.0); </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GL</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawArrays</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GL.TRIANGLE_STRIP, 0, 4)</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">window</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestAnimationFrame</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(draw)</span></span></span><span class="hljs-function">; }</span></span></code> </pre> <br><blockquote>  In fact, we don't always need 60fps in the interfaces.  It is quite possible to add a drag to requestAnimationFrame and reduce the frame redrawing rate. </blockquote><p>  For example, we will change the fill color.  All basic mathematical functions are available in shaders - <code>sin</code> , <code>cos</code> , <code>tan</code> , <code>asin</code> , <code>acos</code> , <code>atan</code> , <code>pow</code> , <code>exp</code> , <code>log</code> , <code>sqrt</code> , <code>abs</code> and others.  We use two of them. </p><br><pre> <code class="hljs cpp">uniform <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_time; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_FragColor = vec4( <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">3.0</span></span>)), <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)), <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  Time in such animations is a relative concept.  Here we use the values ‚Äã‚Äãthat <code>requestAnimationFrame</code> provides us, but we can make our "time".  The idea is that if some parameters are described by a function of time, then we can turn the time in the opposite direction, slow it down, speed it up or return to its original state.  This is very useful. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/VGYvNP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  But enough of abstract examples, let's move on to using pictures. </p><br><p>  <strong>Load the image into the texture</strong> </p><br><p>  In order to use a picture, we need to create a texture that will later be rendered on our plane.  First, load the image itself: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createTexture</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Image(); image.crossOrigin = <span class="hljs-string"><span class="hljs-string">'anonymous'</span></span>; image.onload = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">// .... }; image.src = 'example.jpg'; }</span></span></code> </pre> <br><p>  After it loads, we create a texture and indicate that it will go at number 0. In WebGL, there can be many textures at the same time and we must explicitly indicate which subsequent commands will apply to.  In our examples there will be only one texture, but we still clearly indicate that it will be zero. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> texture = GL.createTexture(); GL.activeTexture(GL.TEXTURE0); GL.bindTexture(GL.TEXTURE_2D, texture);</code> </pre> <br><p>  It remains to add a picture.  We also immediately say that it needs to be flipped along the Y axis, since  in WebGL, the axis is upside down: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.pixelStorei</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNPACK_FLIP_Y_WEBGL</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">true</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texImage2D</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.RGB</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UNSIGNED_BYTE</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">image</span></span>);</code> </pre> <br><p>  In theory, the texture should be square.  More precisely, they should even have a size equal to the power of two - 32px, 64px, 128px, etc.  But we all understand that no one will process photos and they will each time have different proportions.  This will cause errors even if the <code>canvas</code> in size fits the texture perfectly.  Therefore, we fill all the space to the edges of the plane with the extreme pixels of the image.  This is standard practice, although it seems a bit crutch. </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_S</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_WRAP_T</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CLAMP_TO_EDGE</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.texParameteri</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_2D</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.TEXTURE_MIN_FILTER</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.LINEAR</span></span>);</code> </pre> <br><p>  It remains to transfer the texture to the shaders.  This is common to all data, so we use the <code>uniform</code> modifier. </p><br><pre> <code class="hljs delphi">GL.uniform1i(GL.getUniformLocation(<span class="hljs-keyword"><span class="hljs-keyword">PROGRAM</span></span>, <span class="hljs-string"><span class="hljs-string">'u_texture'</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><p>  Now we can use the colors from the texture in the fragment shader.  But we also want the image to occupy the entire <code>canvas</code> .  If the image and <code>canvas</code> have the same proportions, then this task becomes trivial.  To begin with, we pass the size of the <code>canvas</code> to shaders (this should be done every time it is resized): </p><br><pre> <code class="hljs pgsql">GL.uniform1f(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_canvas_size'</span></span>), Math.max(CANVAS.height, CANVAS.width));</code> </pre> <br><p>  And divide the coordinates on it: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> sampler2D u_texture; <span class="hljs-attribute"><span class="hljs-attribute">uniform</span></span> float u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, gl_FragCoord.xy / u_canvas_size); }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/QVwjeJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>At this point, you can make a short pause and brew tea.</em>  <em>We have done all the preparatory work and proceed to the creation of various effects.</em> </p><br><h2 id="effekty">  Effects </h2><br><p>  When creating various effects, intuition and experiments play an important role.  You can often replace a complex algorithm with something completely simple and giving a similar result.  The end user will not notice the difference, and we speed up work and simplify support.  WebGL does not provide intelligent tools for debugging shaders, so it is beneficial for us to have small pieces of code that can fit in the whole head. </p><br><blockquote>  Less code - less problems.  And easier to read.  Always check the shaders found on the network for unnecessary actions.  It happens that you can delete half of the code and nothing will change. </blockquote><p>  Let's play a little with the shader.  Most of our effects will be based on the fact that we return the color of the wrong pixel on the texture, which should be in this place, and some of the neighboring.  It is useful to try to add to the coordinates the result of performing a standard coordinate function.  Time will also be useful to use - so the result of execution will be easier to track, and in the end we will still make animated effects.  Let's try to use the sine: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  The result is strange.  Obviously, everything moves with too much amplitude.  Let's divide everything into some number: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Already better.  Now it is clear that there was a slight excitement.  The idea is that in order to increase each wave, we need to divide the sine argument - the coordinate.  Let's do it: </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + sin(<span class="hljs-name"><span class="hljs-name">u_time</span></span> + gl_FragCoord.y / <span class="hljs-number"><span class="hljs-number">30.0</span></span>) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/jvEWbJ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Such effects are often accompanied by the selection of coefficients.  This is done by eye.  As with cooking, at first it will be difficult to guess, but then it will happen by itself.  The main thing is to understand at least roughly what a particular coefficient influences in the resulting formula.  After the coefficients are selected, it makes sense to put them in macros (as it was in the first example) and give meaningful names. </p><br><p>  <strong>Curved mirror, bicycles and experiments</strong> </p><br><p>  Thinking is useful.  Yes, there are ready-made algorithms for solving some problems that we can just take and use.  But in the process of inventing, we learn ideas that would pass by us. </p><br><p>         ,   " ",       .  What to do? </p><br><p> ,       ,   ?      .   ,       rand()  - .    ,    ,   ,  ,   .    .                  .   ,      .         .      .    -,    .      .    ,     ,       ,   .     ,           "": </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(vec2 <span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fract(<span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">seed</span></span>, vec2(<span class="hljs-number"><span class="hljs-number">12.9898</span></span>,<span class="hljs-number"><span class="hljs-number">78.233</span></span>))) * <span class="hljs-number"><span class="hljs-number">43758.5453123</span></span>); }</code> </pre><br><p>    ,          , ,      NVIDIA  ATI     .     ,        . </p><br><p>       ,    ,          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, gl_FragCoord.xy / u_canvas_size + rand(<span class="hljs-name"><span class="hljs-name">gl_FragCoord</span></span>.xy + vec2(<span class="hljs-name"><span class="hljs-name">sin</span></span>(<span class="hljs-name"><span class="hljs-name">u_time</span></span>))) / <span class="hljs-number"><span class="hljs-number">250.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,   ,   : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/pOvgbX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> ,        .     ,   ,     .   ‚Äî           .  How to do it? .      . </p><br><p>       0  1,     - .    5 ‚Äî          .       ,      . </p><br><pre> <code class="hljs matlab">vec2 texture_coord = gl_FragCoord.xy / u_canvas_size; gl_FragColor = texture2D(u_texture, texture_coord + <span class="hljs-built_in"><span class="hljs-built_in">rand</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">5.0</span></span>) + vec2(<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(u_time))) / <span class="hljs-number"><span class="hljs-number">100.0</span></span>);</code> </pre> <br><p>   ,   -    .   -   . ,    ,   .     ? </p><br><p>        ,  ,   ,  - .     , .    , ..      -.      ,      .      . ,         ,   .        . </p><br><p>    <code>sin</code>  <code>cos</code>   ,    .   .         . </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2( <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>));</code> </pre> <br><p>      .   <code>fract</code>  .    1  1 ‚Äî     : </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(vec2 position) { vec2 block_position = <span class="hljs-keyword"><span class="hljs-keyword">floor</span></span>(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> top_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_left_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bottom_right_value = <span class="hljs-keyword"><span class="hljs-keyword">rand</span></span>(block_position + vec2(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vec2 computed_value = fract(position); <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br><p>        . WebGL      <code>smoothstep</code> ,     : </p><br><pre> <code class="hljs lisp">vec2 computed_value = smoothstep(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, fract(<span class="hljs-name"><span class="hljs-name">position</span></span>))<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>    ,      .   ,          X   : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> computed_value.x;</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/mGyVBK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> ‚Ä¶    ,  ,    ... </p><br><blockquote>    - ,     ,     ...        . </blockquote><p>     y ‚Äî    ,   .      ? </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length(computed_value);</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMza" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>     . </p><br><p>     .     0.5 ‚Äî      . </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mix</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_left_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_left_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> * (1<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span>) + (<span class="hljs-selector-tag"><span class="hljs-selector-tag">bottom_right_value</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">top_right_value</span></span>) * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.x</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">computed_value</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.y</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> 0<span class="hljs-selector-class"><span class="hljs-selector-class">.5</span></span>;</code> </pre> <br><p>      : </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/eLmJMZ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <em>     ,   , ,  .</em> </p><br><p> <strong> </strong> </p><br><p>        ,     ,          .         - . </p><br><p>    uniform-,       .   0  1,  0 ‚Äî   ,  1 ‚Äî  . </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> u_intensity;</code> </pre> <br><p>       : </p><br><pre> <code class="hljs mel">gl_FragColor = texture2D(u_texture, texture_coord + vec2(<span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">sin</span></span>(u_time + texture_coord.x * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">noise</span></span>(texture_coord * <span class="hljs-number"><span class="hljs-number">10.0</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">cos</span></span>(u_time + texture_coord.y * <span class="hljs-number"><span class="hljs-number">5.0</span></span>)) / <span class="hljs-number"><span class="hljs-number">10.0</span></span>) * u_intensity);</code> </pre> <br><p>         ,      . </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/PdwZdX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>         (  0  1),             . </p><br><blockquote>  ,    ,         ,       .          ‚Äî         requestAnimationFrame.       ,     FPS. </blockquote><p> <strong>   </strong> </p><br><p>      ,        .   uniform-. </p><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'mousemove'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> =&gt;</span></span> { let rect = CANVAS.getBoundingClientRect(); MOUSE_POSITION = [ e.clientX - rect.left, rect.height - (e.clientY - rect.top) ]; GL.uniform2fv(GL.getUniformLocation(PROGRAM, <span class="hljs-string"><span class="hljs-string">'u_mouse_position'</span></span>), MOUSE_POSITION); });</code> </pre> <br><p>    ,            .      ‚Äî  ,       . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">void</span></span> main() { <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> texture_coord = gl_FragCoord.xy / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">vec2</span></span> direction = u_mouse_position / u_canvas_size - texture_coord; <span class="hljs-attribute"><span class="hljs-attribute">float</span></span> dist = distance(gl_FragCoord.xy, u_mouse_position) / u_canvas_size; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (dist &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">4</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord + u_intensity * direction * dist * <span class="hljs-number"><span class="hljs-number">1</span></span>.<span class="hljs-number"><span class="hljs-number">2</span></span> ); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); } }</code> </pre> <br><p>         -    .         . </p><br><blockquote>             .    ,        . </blockquote><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/bxNEOP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p> <strong></strong> </p><br><p>      . Glitch-     ,      SVG.      .    ‚Äî .      ?       ‚Äî  ,   ,   ,      . </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">float</span></span> random_value = rand(vec2(texture_coord.y, u_time)); <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (random_value &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">05</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, vec2(texture_coord.x + random_value / <span class="hljs-number"><span class="hljs-number">5</span></span>.<span class="hljs-number"><span class="hljs-number">0</span></span>, texture_coord.y)); } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">gl_FragColor</span></span> = texture2D(u_texture, texture_coord); }</code> </pre> <br><blockquote> "     ?" ‚Äî   ,      .          . </blockquote><p>     .      ‚Äî  ,           . </p><br><pre> <code class="hljs lisp">float random_value = rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><p>     .   ,       : </p><br><pre> <code class="hljs lisp">gl_FragColor = texture2D(<span class="hljs-name"><span class="hljs-name">u_texture</span></span>, vec2(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.x + random_value / <span class="hljs-number"><span class="hljs-number">4.0</span></span>, texture_coord.y)) + vec4(<span class="hljs-name"><span class="hljs-name">vec3</span></span>(<span class="hljs-name"><span class="hljs-name">random_value</span></span>), <span class="hljs-number"><span class="hljs-number">1.0</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>          .          ‚Äî    . ,           ‚Äî   <code>.r</code> , <code>.g</code> , <code>.b</code> , <code>.rg</code> , <code>.rb</code> , <code>.rgb</code> , <code>.bgr</code> , ...               . </p><br><p>       : </p><br><pre> <code class="hljs lisp">float random_value = u_intensity * rand(<span class="hljs-name"><span class="hljs-name">vec2</span></span>(<span class="hljs-name"><span class="hljs-name">floor</span></span>(<span class="hljs-name"><span class="hljs-name">texture_coord</span></span>.y * 20.0), u_time));</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://codepen.io/sfi0zy/embed/preview/OoPMeY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="chto-v-itoge">  What is the result? </h2><br><p>         ,                   ,     .          ,  ,      ‚Äî         . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/420847/">https://habr.com/ru/post/420847/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420835/index.html">"Kalashnikov" showed the concept of a combat robot and electric motorcycle for the civilian market</a></li>
<li><a href="../420837/index.html">Testing software RAIDs for NVMe devices using the SNIA technique</a></li>
<li><a href="../420841/index.html">Pre-hospital hotfix or ‚ÄúHey, Swagger! Where are my mistakes? ‚Äù</a></li>
<li><a href="../420843/index.html">September 7, Ekaterinburg - mitap for .NET developers</a></li>
<li><a href="../420845/index.html">Taming of the Shrew with the use of a crutch: WF2190 Wi-Fi Hole (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../420853/index.html">Meet the Windows pseudo console (ConPTY)</a></li>
<li><a href="../420857/index.html">Seamless Wi-Fi roaming: theory in practice</a></li>
<li><a href="../420859/index.html">On the issue of virt and chains</a></li>
<li><a href="../420861/index.html">Preparing for C ++ 20. Coroutines TS on a real example</a></li>
<li><a href="../420863/index.html">As we did the first Russian smartphone, continued</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>