<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Too fast, too megamorphic: what affects the performance of a method call in Java?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: 
 the argument of the supporters of writing final everywhere and everywhere and their opponents is akin to the dispute of pointed...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Too fast, too megamorphic: what affects the performance of a method call in Java?</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator:</i> <i><br></i>  <i>the argument of the supporters of writing final everywhere and everywhere and their opponents is akin to the dispute of pointed and stupid points.</i>  <i>As in some other communities, this sluggish dispute has been going on for years in our company.</i>  <i>And only this <a href="http://www.insightfullogic.com/blog/2014/may/12/fast-and-megamorphic-what-influences-method-invoca/">article by</a> Richard Warburton allowed our spikes to take over.</i> <br><br><h5>  What are we talking about? </h5><br>  Let's start with a short story.  A few weeks ago I sent my <a href="http://mail.openjdk.java.net/pipermail/core-libs-dev/2014-April/026458.html">suggestion</a> to remove the <i>final</i> modifier from some methods to the Java core libs mailing list.  As a result, there were several topics for discussion.  One of them, for example, is to find out to what extent the performance of a method call that was <i>final</i> will deteriorate if this <i>final</i> is removed from it. <br><br>  I had some thoughts on whether performance regression would occur or not, but I first tried to find out if anyone had already published benchmark results on this issue.  Unfortunately, I could not find anything.  This does not mean that they do not exist or that other people did not investigate the situation, but I did not encounter any peer-reviewed code.  So it's time to write a few benchmarks. <br><a name="habracut"></a><br><h5>  Benchmarking Methodology </h5><br>  So, I decided to use the wonderful <a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a> framework to do benchmarking.  If you're not sure that the framework will help you get accurate benchmarking results, then you should watch this <a href="http://parleys.com/play/52ae09bde4b04354fb7e7cfd">talk by</a> Alexei Shipilev (@TheShade), the author of the framework, or <a href="http://psy-lob-saw.blogspot.co.uk/2013/05/using-jmh-to-benchmark-multi-threaded.html">Nitsan Wakart's</a> really cool <a href="http://psy-lob-saw.blogspot.co.uk/2013/05/using-jmh-to-benchmark-multi-threaded.html">blog</a> , which explains how it helps. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In my case, I wanted to understand what affected the performance of the method call.  I decided to try different variations of the call methods and measure the costs of them.  Having a set of criteria and varying only one factor at a time, we can understand how various factors or their combinations affect the cost of a method call. <br><br><h5>  Inlining </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/a0b/8fc/5fb/a0b8fc5fbcf4401602e4588c0f1e3ca0.jpg" alt="image"><br>  At the same time, the most and least obvious influencing factor is whether a method call occurs at all!  The actual method call can be so optimized by the compiler that it will not remain at all.  Generally speaking, there are two ways to reduce the cost of a call.  One of them is to directly embed the method itself, the other is to use the inline cache.  Don't worry - these are fairly simple concepts, but there is a bit of terminology to be understood.  Imagine that we have a class named Foo, which defines a method called bar. <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ... } }</code> </pre> <br>  We can call the bar method by writing code that looks like this: <br><br><pre> <code class="java hljs">Foo foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); foo.bar();</code> </pre><br>  The main thing here is the place where bar is actually called - foo.bar () - it is called <b>callsite</b> .  When we say that the method was inline (built-in), it means that the body of the method is taken and inserted into callsite, instead of calling the method.  For programs that consist of many small methods (I think that writing programs more correctly), embedding can lead to significant acceleration.  This is because the program does not spend most of its time on method calls instead of doing work!  We can control whether a method is embedded or not in JMH using the CompilerControl annotation.  We will return to the concept of inline cache a little later. <br><br><h5>  Hierarchy depth and method overrides </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/70a/a00/62d/70aa0062d6f510fb8b4601d4d7bba5dd.jpg" alt="image"><br>  If we decide to remove the <i>final</i> keyword from a method, this means that we will be able to override it.  This is another factor that needs to be taken into account.  So I took the methods and called them at different levels of the class hierarchy;  there were also methods redefined at different levels of the hierarchy.  This allowed me to determine how deeply class hierarchies interact with method overrides. <br><br><h5>  Polymorphism </h5><br><img src="https://habrastorage.org/getpro/habr/post_images/c4d/9fb/cdb/c4d9fbcdbe0fd3f9b6f309863513f83c.jpg" alt="image"><br>  When I mentioned the idea of ‚Äã‚Äãcallsite earlier, I secretly wanted to get around a rather important question.  Since the non- <i>final</i> method can be overridden in a subclass, our callsite s may eventually call various methods.  So maybe I‚Äôm dealing with Foo or its child class Baz, which also implements bar ().  How does the compiler know which method to call?  All methods in Java are virtual (redefinable) by default, and for each call you have to find the correct method in the so-called virtual method table (vtable).  This is rather slow, so optimizing compilers are always trying to reduce the cost of such searches.  The approach mentioned earlier ‚Äî inline or embed ‚Äî works great if your compiler can prove that a given callsite can call only one specific implementation of the method.  This is called monomorphic callsite. <br><br>  Unfortunately, for the most part, proving that callsite is strictly monomorphic is ultimately impractical.  JIT compilers, as a rule, use an alternative approach, profiling which types are called in callsite and assuming that if callsite was monomorphic in its first N calls, then it is worthy of speculative optimization based on the assumption that it will always be monomorphic.  Such a speculative optimization is usually true, but not always;  therefore, the compiler must implement protection before calling the method to verify the type of the object in which the method is called. <br><br>  However, monomorphic callsite-s is not the only case when we want to optimize.  Many callsite-s are, so-called, bimorphic (bimorphic) - i.e.  There are two methods that can be invoked.  You can still embed bimorph callsite-s using your security code, checking which implementation to call and then proceed to it.  It is still cheaper than a full method call.  In addition, you can optimize this case using the inline cache.  The inline cache does not actually embed the body of the method in callsite, but it has a specialized transition table that acts like a cache on a complete virtual method table.  The Hotspot JIT compiler supports bimorphic embedded caches, and any callsite with 3 or more possible implementations is considered megamorphic. <br><br>  Thus, there are 3 types of calls for comparison and research: cases of monomorphic, bimorphic and megamorphic calls. <br><br><h5>  results </h5><br>  Group the results so that you can see the forest among the trees;  I will present the dry figures along with their small analysis.  Specific figures / costs are actually not that interesting for us.  The relation between the different types of method calls is interesting, so that the statistical errors are small.  There is a rather significant difference - 6.26 times - between the fastest and the slowest.  In reality, this difference is likely to be greater - due to the costs associated with measuring the time of the empty method. <br><br>  The source code for these benchmarks is available on <a href="https://github.com/RichardWarburton/java-final-benchmark">GitHub</a> .  To avoid confusion, I presented parts of the results in different blocks.  Polymorphic benchmarks are made using PolymorphicBenchmark, and the rest - using JavaFinalBenchmark <br><br><h5>  Simple callsite s </h5><br><pre> <code class="java hljs">Benchmark Mode Samples Mean Mean error Units cijJavaFinalBenchmark.finalInvoke avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.606</span></span> <span class="hljs-number"><span class="hljs-number">0.007</span></span> ns/op cijJavaFinalBenchmark.virtualInvoke avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.598</span></span> <span class="hljs-number"><span class="hljs-number">0.008</span></span> ns/op cijJavaFinalBenchmark.alwaysOverriddenMethod avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.609</span></span> <span class="hljs-number"><span class="hljs-number">0.006</span></span> ns/op</code> </pre><br>  Our first result set shows the cost of calling a virtual method, a <i>final</i> method, and a method that goes into a deep hierarchy and is redefined.  Note that in all these cases we forced the compiler not to embed methods.  As you can see, the difference between the times is minimal and our standard deviation shows that it does not matter much.  Thus, we can conclude that simply adding a <i>final</i> keyword will not significantly improve call performance.  Redefinition of a method also, apparently, is not of great importance. <br><br><h5>  Embedding simple callsite </h5><br><pre> <code class="java hljs">Benchmark Mode Samples Mean Mean error Units cijJavaFinalBenchmark.inlinableFinalInvoke avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">0.782</span></span> <span class="hljs-number"><span class="hljs-number">0.003</span></span> ns/op cijJavaFinalBenchmark.inlinableVirtualInvoke avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">0.780</span></span> <span class="hljs-number"><span class="hljs-number">0.002</span></span> ns/op cijJavaFinalBenchmark.inlinableAlwaysOverriddenMethod avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1.393</span></span> <span class="hljs-number"><span class="hljs-number">0.060</span></span> ns/op</code> </pre><br>  Now take the same three cases and remove the constraint of embedding.  Again, <i>final</i> and virtual method calls end up with the same duration.  They are 4 times faster than in the case of the prohibition of embedding, which I would have recorded at the expense of, in fact, embedding.  Calling an overridden method everywhere ends up in between two.  I suspect that this is because the method itself has several possible implementations of subclasses and, therefore, the compiler must insert a type check.  The mechanics of this are explained above in more detail in the ‚ÄúPolymorphism‚Äù section. <br><br><h5>  Impact of class hierarchy </h5><br><pre> <code class="java hljs">Benchmark Mode Samples Mean Mean error Units cijJavaFinalBenchmark.parentMethod1 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.600</span></span> <span class="hljs-number"><span class="hljs-number">0.008</span></span> ns/op cijJavaFinalBenchmark.parentMethod2 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.596</span></span> <span class="hljs-number"><span class="hljs-number">0.007</span></span> ns/op cijJavaFinalBenchmark.parentMethod3 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.598</span></span> <span class="hljs-number"><span class="hljs-number">0.006</span></span> ns/op cijJavaFinalBenchmark.parentMethod4 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.601</span></span> <span class="hljs-number"><span class="hljs-number">0.006</span></span> ns/op cijJavaFinalBenchmark.inlinableParentMethod1 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1.373</span></span> <span class="hljs-number"><span class="hljs-number">0.006</span></span> ns/op cijJavaFinalBenchmark.inlinableParentMethod2 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1.368</span></span> <span class="hljs-number"><span class="hljs-number">0.004</span></span> ns/op cijJavaFinalBenchmark.inlinableParentMethod3 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1.371</span></span> <span class="hljs-number"><span class="hljs-number">0.004</span></span> ns/op cijJavaFinalBenchmark.inlinableParentMethod4 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1.371</span></span> <span class="hljs-number"><span class="hljs-number">0.005</span></span> ns/op</code> </pre><br>  Wow, this is a big block of methods!  Each of the numbered method calls (1-4) shows how deeply the method was called in the class hierarchy.  So parentMethod4 means that we call the method declared in the 4th parent class.  If you look at the numbers, the difference between 1 and 4 is very small.  Thus, we can conclude that the depth of the hierarchy does not matter.  When embedded, everyone follows the same pattern: the depth of the hierarchy is irrelevant.  Our embedded methods are comparable to inlinableAlwaysOverriddenMethod, but slower than inlinableVirtualInvoke.  I would refer this to type checking again.  The JIT compiler can profile methods to find out that only one has been built in, but it cannot prove that it will always be like this. <br><br><h5>  Impact of class hierarchy on <i>final</i> methods </h5><br><pre> <code class="java hljs">Benchmark Mode Samples Mean Mean error Units cijJavaFinalBenchmark.parentFinalMethod1 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.598</span></span> <span class="hljs-number"><span class="hljs-number">0.007</span></span> ns/op cijJavaFinalBenchmark.parentFinalMethod2 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.596</span></span> <span class="hljs-number"><span class="hljs-number">0.007</span></span> ns/op cijJavaFinalBenchmark.parentFinalMethod3 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.640</span></span> <span class="hljs-number"><span class="hljs-number">0.135</span></span> ns/op cijJavaFinalBenchmark.parentFinalMethod4 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">2.601</span></span> <span class="hljs-number"><span class="hljs-number">0.009</span></span> ns/op cijJavaFinalBenchmark.inlinableParentFinalMethod1 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1.373</span></span> <span class="hljs-number"><span class="hljs-number">0.004</span></span> ns/op cijJavaFinalBenchmark.inlinableParentFinalMethod2 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1.375</span></span> <span class="hljs-number"><span class="hljs-number">0.016</span></span> ns/op cijJavaFinalBenchmark.inlinableParentFinalMethod3 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1.369</span></span> <span class="hljs-number"><span class="hljs-number">0.005</span></span> ns/op cijJavaFinalBenchmark.inlinableParentFinalMethod4 avgt <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">1.371</span></span> <span class="hljs-number"><span class="hljs-number">0.003</span></span> ns/op</code> </pre><br>  Here, the same scheme as above ‚Äî the <i>final</i> keyword does not seem to have any meaning.  I thought that theoretically here it can be proved that inlinableParentFinalMethod4 is embedded and that type checking is excluded, but it looks like it is not. <br><br><h5>  Polymorphism </h5><br><pre> <code class="java hljs">Monomorphic: <span class="hljs-number"><span class="hljs-number">2.816</span></span> +- <span class="hljs-number"><span class="hljs-number">0.056</span></span> ns/op Bimorphic: <span class="hljs-number"><span class="hljs-number">3.258</span></span> +- <span class="hljs-number"><span class="hljs-number">0.195</span></span> ns/op Megamorphic: <span class="hljs-number"><span class="hljs-number">4.896</span></span> +- <span class="hljs-number"><span class="hljs-number">0.017</span></span> ns/op Inlinable Monomorphic: <span class="hljs-number"><span class="hljs-number">1.555</span></span> +- <span class="hljs-number"><span class="hljs-number">0.007</span></span> ns/op Inlinable Bimorphic: <span class="hljs-number"><span class="hljs-number">1.555</span></span> +- <span class="hljs-number"><span class="hljs-number">0.004</span></span> ns/op Inlinable Megamorphic: <span class="hljs-number"><span class="hljs-number">4.278</span></span> +- <span class="hljs-number"><span class="hljs-number">0.013</span></span> ns/op</code> </pre><br>  Finally, we come to the case of a polymorphic call.  The cost of a monomorphic call, roughly speaking, is the same as that of our regular virtual calls described above.  As we need to perform searches on large tables of virtual methods, they become slower as more and more biomorphic and megamorphic cases appear.  As soon as we allow embedding, profiling throws out too much, and our monomorphic and biomorphic callsite are lowered to the cost of our built-in calls with type checking.  Very similar to the case of a class hierarchy, only slightly slower.  The megamorphic case is still very slow.  Let me remind you that here we have not configured Hotspot to prevent embedding, it simply does not implement a polymorphic inline cache for callsite-s more complex than bimorphic. <br><br><h5>  What do we understand? </h5><br>  I think it is worth noting that there are many people who do not have a speculative performance model that calculates different types of method calls, taking a different amount of time, and a lot of people who understand that they use a different amount of time, but they don‚Äôt really understand it right.  I know because I myself was so and made wrong assumptions.  So I hope this study was useful for you.  The following is a brief summary of the theses that I defended in this article: <br><ul><li>  There is a big difference between the fastest and the slowest type of method call. </li><li>  In practice, adding or deleting the <i>final</i> keyword does not really affect performance, but if you later reorganize your hierarchy, the process may begin to slow down. </li><li>  Deeper class hierarchies have no real effect on call performance. </li><li>  Monomorphic calls are faster than bimorphic. </li><li>  Bimorph calls are faster than megamorphic. </li><li>  When checking the type, which we see in the case of profiling, when it is impossible to prove monomorphism, the call slows down a little, compared to monomorphic. </li></ul><br><br>  I would say that the price of checking the type is my personal "big revelation."  This is what I see as is rarely discussed and often neglected. <br><br><h5>  Warnings and further work </h5><br>  Of course, this is not the only possible approach to this issue! <br><ul><li>  This article focuses on the factors affecting the performance of method calls related to call types.  One of the factors that I did not mention is the heuristic surrounding the method, embedded depending on the size or depth of the call stack.  If your method is too large, it will not be embedded at all, and you still end up paying for the cost of calling the method.  Another reason to write small, easy to read methods. </li><li>  I did not consider how a call through an interface affects any of these situations.  If you find this interesting, then there is an interface performance study on the <a href="http://mechanical-sympathy.blogspot.co.uk/2012/04/invoke-interface-optimisations.html">Mechanical Sympathy</a> blog. </li><li>  One factor that we completely ignored was the effect of the embedding method on other compiler optimizations.  When compilers perform optimization, in which only one method is analyzed (intra-procedural optimization), in order to effectively optimize, they really need as much information as possible.  Restricting embedding can significantly reduce the context with which other optimizations will have to work. </li><li>  Binding explanations down to the assembler level to dive into this issue in more detail. </li></ul><br><br>  Perhaps these are topics for future posts. <br><br>  Thanks: <br>  - <a href="http://shipilev.net/">Alexey Shipilev</a> for feedback to the benchmark, <br>  - to users of <a href="http://mechanical-sympathy.blogspot.co.uk/">Martin Thompson</a> , Martijn Verburg, Sadiq Jaffer and <a href="https://blog.goeswhere.com/">Chris West</a> - for very useful reviews and comments on my blog. </div><p>Source: <a href="https://habr.com/ru/post/223875/">https://habr.com/ru/post/223875/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../223867/index.html">Vibrating Insoles - wearable technology that you did not expect. (concept)</a></li>
<li><a href="../223869/index.html">MBLOK Wireless Storage on Kickstarter</a></li>
<li><a href="../22387/index.html">Toshiba's cute and intelligent robot ApriPoko</a></li>
<li><a href="../223871/index.html">IBM specialists have discovered a new class of durable self-healing polymers</a></li>
<li><a href="../223873/index.html">Distribution of scientific software. Is free</a></li>
<li><a href="../223877/index.html">How Host-tracker helped to quickly detect malicious code</a></li>
<li><a href="../22388/index.html">Google Analytics implemented on YouTube</a></li>
<li><a href="../223881/index.html">Tabtabus 2014 Summer Fest - open registration for the summer IT-open-air fest</a></li>
<li><a href="../223883/index.html">Electric for regular airlines</a></li>
<li><a href="../223885/index.html">DevConf 2014: Andrei Aksenov, author of Sphinx - will tell you how the repositories are arranged inside NoSQL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>