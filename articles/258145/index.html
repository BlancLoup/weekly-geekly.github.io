<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Forget the SAR theorem as no longer relevant.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="or ‚ÄúStop characterizing data stores as CP or AP‚Äù 

  Jeff Hodges in his excellent post ‚Äú Notes on Distributed Systems for Beginners ‚Äù recommends using...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Forget the SAR theorem as no longer relevant.</h1><div class="post__text post__text-html js-mediator-article">  or ‚ÄúStop characterizing data stores as CP or AP‚Äù <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/cc1/0d6/56d/cc10d656d52e91cab4ca56a0a7e57460.png" alt="cap" width="419" height="344" align="left"></a>  Jeff Hodges in his excellent post ‚Äú <a href="http://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/">Notes on Distributed Systems for Beginners</a> ‚Äù recommends using the <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_CAP">CAP theorem</a> to criticize the solutions found.  Many seem to have taken this advice too close to heart, describing their systems as ‚ÄúCP‚Äù (data consistency, but without constant availability with network distribution), ‚ÄúAP‚Äù (availability without a consistent state with network distribution), or sometimes ‚ÄúCA‚Äù (means "I still have not read the article <a href="http://codahale.com/you-cant-sacrifice-partition-tolerance/">Coda (Coda Hale) almost 5 years ago</a> "). <br><br>  I agree with all points of the article except for the SAR theorem.  It simplifies too much and too many people misunderstand it in order to use it to determine the characteristics of a system.  So I ask you to stop referring to the SAR theorem, talk about it and give it to her to calmly go to rest.  Instead, we must use more accurate terminology to discuss the various trade-offs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      (Yes, I understand the irony of writing an entire article on the topic of what I urge not to write others at all. But at least I will have a link that I can give to people interested when they ask me why I do not approve of the discussion of the CAP theorem Also, I want to apologize if the article seems too pompous to you, but this bombast relies on many references.) <br><br><h1>  ATS uses too narrow a definition </h1><br>  If you want to refer to CAP as a <em>theorem</em> (and not a vague concept in the marketing materials for your database), you must be accurate.  Mathematics requires accuracy.  Proof is preserved only if you embed in words, the same meaning that was used in the proof.  And it relies on very precise definitions: <a name="habracut"></a><br><ul><li>  <em>Consistency</em> in ATS actually means <a href="http://cs.brown.edu/~mph/HerlihyW90/p463-herlihy.pdf">linearizability</a> , which is (and very strong) the principle of consistency.  In particular, this has nothing to do with the "C" of ACID, even if this C also means "consistency."  I'll explain on fingers what linearizability is a bit later. </li><li>  <em>Availability</em> in the RAA is defined as ‚Äúevery request received by a working node [database] in the system should result in a response [not containing errors]‚Äù.  It is not enough for <em>some</em> nodes to process the request: <strong><em>any</em></strong> working node must be able to process the request.  A lot of so-called ‚Äúhigh abailability‚Äù, i.e.  with low downtime, systems in reality do not meet the definition of accessibility. </li><li>  <em>Resistance to separation (Partition</em> <em>tolerance</em> <em>) is a</em> terrible name - in general terms it means that you use <a href="http://henryr.github.io/cap-faq/">an asynchronous network</a> for communication, which can lose or delay messages.  The Internet and all data centers <a href="https://aphyr.com/posts/288-the-network-is-reliable">have this property</a> , so in reality you have no choice in this context. </li></ul><br>  I also want to note that the SAR theorem describes not just any old system, but a system of a very specific model: <br><ul><li>  A system model in SAR space is a single node / counter (register) of read-write - that's all.  For example, nothing is said about transactions that affect multiple objects.  They are simply outside the conditions of the theorem, as long as you don‚Äôt somehow cut those objects down to a single object. </li><li>  The only type of failure mentioned by the CAP theorem is network separation, i.e.  the nodes remain active, but the network between some of them is down.  This kind of error <a href="https://aphyr.com/posts/288-the-network-is-reliable">somehow happens</a> , but this is not the only thing that can go wrong: the nodes can be broken or reloaded, the disk can run out, you can catch a bug in the software, etc., etc.  In the process of creating a distributed system, you need to keep in mind a much larger range of possible errors and compromises to which they lead.  Focusing too much on the SAR theorem leads to ignoring other important problems. </li><li>  Moreover, the CAP theorem says nothing about latency, which <a href="http://dbmsmusings.blogspot.co.uk/2010/04/problems-with-cap-and-yahoos-little.html">worries most developers much more</a> than accessibility.  In fact, CAP-compatible systems can be arbitrarily slow and still be called "affordable."  If you take everything to the extreme, I am sure that your users will not be inclined to call your system ‚Äúaccessible‚Äù if it takes 2 minutes to get a web page. </li></ul><br>  If your definition coincides with the formal meaning of terms in the CAP theorem, then it fits you.  But if you give a different definition of the terms consistency and accessibility, then you cannot expect the SAR theorem to apply to you.  Of course, this does not mean that by redefining the values ‚Äã‚Äãyou can suddenly do impossible things!  You just can not follow the CAP theorem and use it for argumentation in support of your point of view. <br><br><h1>  Linearizability </h1><br>  In case you are not familiar with linearizability (in the sense of "integrity" in the context of ATS), let me briefly tell about it.  The formal definition is not that very understandable, but the key idea, if in a simple way, is: <br><br>  <em>If operation B started after successful completion of operation A, then operation B should see the state of the system at the moment A is completed or in the new state.</em> <br><br>  For greater clarity, you can imagine the following situation in which the system will <strong>not</strong> be linearized.  See the diagram below (some kind of preview of my book that hasn't been released yet): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d8e/187/d9d/d8e187d9d73a6309d530db595610e6f7.png" alt="alice_bob" width="711" height="506"></a> <br><br>  The diagram illustrates the following situation: Bob and Alice are in the same room, both are checking their phones to check the results of the final game at the 2014 World Cup.  Immediately after the bill has been announced, Alice refreshes the page, sees the winner and happily informs Bob of this.  He immediately presses <em>Update</em> on his phone, but his request falls on a replicated database that lags slightly, so his phone says that the game is still running. <br><br>  If Alice and Bob had updated the page on the phone at the same time, it would not be surprising that they got different results, because they don‚Äôt know at what time their requests were processed.  However, Bob knows that he is updating the page (initiates a request) <em>after</em> he heard Alice‚Äôs exclamation about the final account and, thus, he expects his data to be at least the same old as Alice‚Äôs.  The fact that he got a rotten query result is a violation of linearization. <br><br>  The knowledge that Bob‚Äôs request occurred strictly after Alice‚Äôs request (that they were not simultaneous) is based on the fact that Bob heard the result of a request from Alice through another communication channel (verbally, in our case).  If Bob had not heard the result from Alice that the game was over, then he would not know that his result was outdated. <br><br>  When you are designing a database, you cannot know what types of communication channels the client will have.  It turns out that if you want to provide linearization (CAP-consistency) in your database, you have to make everyone think that there is only a single copy of the data, even if there may be a lot of it (replicated data, cache) in various places . <br><br>  It is very expensive and problematic to provide guarantees of linearizability, because it requires a large number of coordination operations.  Even the CPU in your computer <a href="http://www.cl.cam.ac.uk/~pes20/weakmemory/x86tso-paper.tphols.pdf">does not provide linearized access to the RAM</a> !  To obtain linearizability in modern CPUs, you must use the <a href="http://mechanical-sympathy.blogspot.co.uk/2011/07/memory-barriersfences.html">memory barrier instructions</a> .  And even to test the linearizability of the system <a href="https://github.com/aphyr/knossos">is not very easy</a> . <br><br><h1>  CAP availability </h1><br>  Let's talk a little bit about whether to sacrifice linearization or accessibility in the case of network sharing. <br><br>  Suppose we have copies of the database in two different data centers.  The specific replication method is unimportant in this case ‚Äî it can be single-leader (master / slave), multi-leader (master / master), or quorum-based replication ( <a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo-style</a> ).  The general meaning of replication is that when data changes in one data center, they are displayed in another.  Imagine that clients are connected with only one data center and there must be another connection between data centers for replicating data. <br><br>  Now let the connection between the DCs be interrupted - this is what we mean by network sharing.  What happens then? <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/704/2af/926/7042af926054b830a3766b3b657a7205.png" alt="dc" width="753" height="344"></a> <br><br>  Obviously, you can choose one of two options: <br><ol><li>  The application continues to work and allows writing to the database, it is fully accessible to both data centers.  But since the connection between the DCs is interrupted, all changes in one DC will not be available in the other.  This violates the linearizability (in terms of the previous example, Alice can be assigned to DC1, and Bob to DC2). </li><li>  If you do not want to lose linearizability, you must be sure that you are doing all the reading and writing in one data center, which you can call the <em>master.</em>  In another DC, the data of which cannot be up to date due to the loss of connection, the database should stop servicing clients for reading and writing until the synchronization is restored.  Since the dependent database in the second DC cannot process requests, it is not CAP-accessible. </li></ol><br>  By the way, this is essentially a proof of the CAP theorem.  In the example, two DCs are used, but everything can be applied to one DC, as the network problems can be inside too.  I just thought that the example of the two DCs is more simple and clear. <br><br>  Note that in our conditionally ‚Äúinaccessible‚Äù situation in the second version, we can quite successfully process requests in one of the DCs.  So if the system is built with an emphasis on linearizability (i.e., not CAP is available), then this does not necessarily mean that network separation automatically leads to application downtime.  If you can transfer all clients to the use of a lead DC, customers will not notice a drop at all. <br><br>  Availability in practice <a href="http://blog.thislongrun.com/2015/04/cap-availability-high-availability-and_16.html">doesn‚Äôt exactly refer</a> to CAP accessibility.  The availability of your application is most likely measured in the SLA (for example, 99.9% of the correct queries should return a result within 1 second), but such an agreement can be implemented in CAP-accessible and CAP-inaccessible systems. <br><br>  In practice, systems located in many DCs are often designed taking into account asynchronous replication and it turns out that they are nonlinearized.  However, the reason for this choice is often the network latency itself, and not just because of the increased stability of the data centers and the network falling. <br><br><h1>  Many systems are neither linearizable nor CAP-accessible. </h1><br>  How to create systems with strict definitions in the CAP-theorem for integrity (linearization) and accessibility? <br><br>  For example, take any database with replication and one leader (single leader), which is the standard setting for most relational databases.  In this configuration, the client can not write to the database if it is separated from the master.  Even if a client can read from copies (read-only recplica), the fact that he cannot write data means that any setting with a single master is not CAP-accessible.  It does not matter that such systems are often positioned as "systems with high availability." <br><br>  If replication with one master is not CAP-available, then does it make it "CP"?  Wait, not so fast!  If you allow an application to read from replicas, and asynchronous replicas (the default for most databases), then the dependent database may be slightly outdated during reading.  In this case, the reading will not be linearized, i.e.  not cap-consistent. <br><br>  Moreover, databases with <a href="http://research.microsoft.com/pubs/69541/tr-95-51.pdf">an isolation level of snapshot</a> / MVCC are deliberately non-linearized, because the linearization requirement will reduce the number of concurrency operations simultaneously.  For example, <a href="http://drkp.net/papers/ssi-vldb12.pdf">PostgreSQL SSI</a> gives serializability, but not linearizability, with <a href="http://www.researchgate.net/publication/220225203_Making_snapshot_isolation_serializable/file/e0b49520567eace81f.pdf">Oracle the same situation</a> .  Just because a database is marked as ACID does not mean that the database satisfies the definition of consistency / consistency in the CAP theorem. <br><br>  It turns out that these systems are neither CAP-agreed, nor CAP-accessible.  They are neither ‚ÄúSR‚Äù nor ‚ÄúAR‚Äù, they are simply ‚ÄúP‚Äù, whatever that means.  Yes, the wording ‚Äútwo out of three‚Äù <em>allows</em> you to choose only one option out of three, or even none! <br><br>  What about NoSQL?  For example, you can take MongoDB: it has one lead per shard (at least so it is assumed, if it is not split-brain mode), so given all the above, there is no longer CAP availability.  And Kyle (Kyle) <a href="https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads">recently showed</a> that this allows non-linearized reading to be done even with the highest level of consistency settings, so CAP-consistency is not the same. <br><br>  Dynamo derivatives like Riak, Cassandra and Voldemort are often called ‚ÄúAR‚Äù because they are optimized for high availability?  Well, it depends on your settings.  If you can write and read data in replicas (R = W = 1), they are really CAP-available.  However, if reading and writing are performed by a quorum (R + W&gt; N) and you have network sharing, clients on the minority side cannot reach the quorum, it turns out that the quorum operation is also not ATS-available (at least temporarily, until the base data will not raise additional cues on the minority side). <br><br>  Sometimes you can meet people who claim that quorum-based reading and writing guarantees linearization, but I think it will not be very clever to rely on it - a fragile combination of features such as sloppy quorums and reading repair can lead to <a href="http://basho.com/riaks-config-behaviors-part-3/">fragile face</a> , when the <strike>dead will</strike> recover deleted records will be restored, or the number of replicas will fall less than the original number of writers (violation of quorum conditions), or the number of replicas will exceed the original N (again violation of quorum conditions).  All this leads to non-linearized data acquisition. <br><br>  All the systems mentioned are not bad: people successfully use them in combat environments.  However, so far we have not been able to strictly define it as ‚ÄúAP‚Äù or ‚ÄúCP‚Äù, including because it depends on a specific operation or configuration, or because the system does not meet the strict definition of consistency or availability in the CAP theorem. <br><br><h1>  Real-life example: ZooKeeper </h1><br>  What about ZooKeeper?  This system uses <a href="http://web.stanford.edu/class/cs347/reading/zab.pdf">an agreement algorithm</a> , so many agree that this is a <a href="http://www.knewton.com/tech/blog/2014/12/eureka-shouldnt-use-zookeeper-service-discovery/">pure example of preference for consistency over accessibility</a> (i.e., the ‚ÄúCP system‚Äù). <br><br>  However, if you look in the <a href="http://zookeeper.apache.org/doc/r3.4.6/zookeeperProgrammers.html">documentation</a> , it clearly states that ZooKeeper <strong>does not</strong> provide a linearized reading by default.  Each client is connected to one of the nodes, and when you want to start reading, you see data only from your node, even if there is updated data on the neighboring nodes.  This allows you to read data much faster than if you need to collect a quorum or poll the leader for each read, but it also means that ZooKeeper by default does not meet the requirements of the CAP theorem on consistency. <br><br>  In general, it is possible to do a linearized reading in ZooKeeper <a href="http://mail-archives.apache.org/mod_mbox/zookeeper-user/201303.mbox/%253CCAJwFCa0Hoekc14Zy6i0LyLj%3DeraF8JimqMZadohoKQJNTMtYSg%40mail.gmail.com%253E">using sync before the read command</a> .  This is not the default behavior, because we get a performance drop.  The sync command is used, but not all the time. <br><br>  What about availability in ZooKeeper?  Well, the ZK requires a <a href="http://www.tcs.hut.fi/Studies/T-79.5001/reports/2012-deSouzaMedeiros.pdf">majority decision</a> to reach an agreement to record the data.  If you have a division into a majority and a minority of nodes, then the majority will function as before, but the nodes remaining in the minority will not be able to process write requests, despite the fact that they are all working.  It turns out that the recording function in ZK is not CAP-available in the partitioned mode of operation (even taking into account the fact that most nodes can write data). <br><br>  To add even more fun to all this, ZooKeeper version 3.4.0 added <a href="http://zookeeper.apache.org/doc/r3.4.6/zookeeperAdmin.html">a read-only mode</a> in which nodes remaining in the minority can continue to serve read requests ‚Äî a quorum is not required!  Those.  read mode <em>is</em> CAP-accessible.  Thus, the default ZK is neither CAP-negotiated (‚ÄúCP‚Äù) or CAP-accessible (‚ÄúAR‚Äù) - it is really just ‚ÄúP‚Äù.  However, you can make the system "CP" using the sync method, and only for the read operation system "AP", if you enable the correct options. <br><br>  But what's annoying: calling ZooKeeper a ‚Äúnon-consistent‚Äù system, simply because it is non-linearizable by default ‚Äî a truly horrible interpretation of features.  ZK actually gives you a great degree of consistency!  It supports <a href="http://web.stanford.edu/class/cs347/reading/zab.pdf">atomic broadcast in</a> conjunction with guaranteed <a href="http://research-srv.microsoft.com/en-us/um/people/lamport/pubs/multi.pdf">casual consistency</a> ‚Äî which is a <a href="http://arxiv.org/pdf/1302.0309.pdf">stronger</a> condition than <a href="http://www.researchgate.net/profile/Douglas_Terry3/publication/3561300_Session_guarantees_for_weakly_consistent_replicated_data/links/02e7e52cdbe60a6cb4000000.pdf">monotonic reads</a> and <a href="http://research.microsoft.com/pubs/157411/ConsistencyAndBaseballReport.pdf">consistent prefix reads</a> put together.  Documentation says that the system gives <a href="http://research-srv.microsoft.com/en-us/um/people/lamport/pubs/multi.pdf">consistent consistency</a> , but this is an underestimation of themselves, because ZooKeeper guarantees a stronger definition than consistent consistency. <br><br><h1>  SR / AR: False Dichotomy </h1><br>  The fact that we could not unambiguously classify even one repository as ‚ÄúAR‚Äù or ‚ÄúSR‚Äù should lead to certain thoughts: these are simply inappropriate definitions for the described systems. <br><br>  I am sure that we should stop trying to identify the various repositories in the category ‚ÄúAR‚Äù or ‚ÄúSR‚Äù because: <br><ul><li>  Within one application, there may be several different operations with <a href="http://groups.csail.mit.edu/tds/papers/Gilbert/Brewer2.pdf">different data consistency characteristics</a> . </li><li>  Many systems do not meet the definition of consistency and accessibility within the framework of the CAP-theorem.  However, I have never heard that someone called his system simply ‚ÄúP‚Äù, probably because it sounds bad.  But this is not bad - it can be a perfectly planned architecture that simply does not fall into the category of CP / AR. </li><li>  Even if the majority of software does not fall precisely into the mentioned categories, people still try to squeeze it into one of the categories, and it turns out that the meaning of ‚Äúconsistency‚Äù or ‚Äúaccessibility‚Äù inevitably changes to what they want to mean by that.  Unfortunately, if the meaning of words changes - the CAP theorem can no longer be applied, and the division into CP / AP does not matter. </li><li>  A huge amount of nuances is lost when trying to cram a system into one of two categories.  There are a huge number of aspects regarding fault tolerance, latency, simplicity of the programming model, interaction, and so on, which can be used in the design of distributed systems.  It is physically impossible to encode all these nuances in one bit of information.  For example, even ZooKeeper supports ‚ÄúAP‚Äù in read-only mode, and this mode allows you to read entries in the same order as they were written - it is much stronger than ‚ÄúAP‚Äù in systems like Riak or Cassandra - so it was would be ridiculous to put them in one pile. </li><li>  Even Eric Brewer <a href="http://cs609.cs.ua.edu/CAP12.pdf">admits</a> that ATS is misleading and simplifies too much.  In 2000, it was important to start a discussion of trade-offs in distributed systems, and it worked.  There was no intention to create some kind of breakthrough formal document or strict classification schemes for data warehouses.  15 years later, we had a much richer set of tools with different approaches to ensuring data integrity and error protection.  ATS has done its task and now is the time to move on. </li></ul><br><br><h1>  Learn to think for yourself </h1><br>  If ‚ÄúSR‚Äù and ‚ÄúAR‚Äù are not suitable for describing and criticizing systems, what should be used instead?  I do not think that I have the only correct answer.  Many people spent a lot of time thinking about the problems of distributed systems, and offered terminology and models that now help us understand the problems.  To learn more about these ideas, you need to delve into the literature yourself: <br><ul><li>  A good starting point would be Doug Terry's article where he <a href="http://research.microsoft.com/pubs/157411/ConsistencyAndBaseballReport.pdf">explains the differences between different levels of partial consistency using baseball for example</a> .  It is very easy to read and understand, even if you (just like me) are not American and do not understand anything about baseball. </li><li>  If you want to learn more about transaction isolation models (which is not the same as consistency in distributed replicas, but close), my little <a href="http://martin.kleppmann.com/2014/11/25/hermitage-testing-the-i-in-acid.html">Hermitage</a> project can help. </li><li>  The relationship between replica consistency, transactions, and availability has been investigated <a href="http://arxiv.org/pdf/1302.0309.pdf">by</a> Peter Bailis.  The document also explains the significance of the hierarchy of levels of consistency that Kyle Kingsbury <a href="https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads">likes to show</a> so <a href="https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads">much</a> . </li><li>  When you read all this, you will be ready to dig deeper.  I shoveled a bunch of links and documents for this post - read them, the experts have already perfectly described many things for you. </li><li>  As a final argument, if you cannot read the original sources, I suggest you take a look at my book, which contains and summarizes the most important ideas in a convenient way.  You see, I tried <em>very hard</em> not to make an advertising speech out of the post. </li><li>  If you are interested in the ZooKeeper theme and you want to draw a more detailed look at it, then <a href="http://shop.oreilly.com/product/0636920028901.do">Flavio Junqueira and Benjamin Reed</a> have written a good book. </li></ul><br>  No matter what path of study you choose, I urge you to maintain curiosity and patience - this is not easy.  But you will be rewarded, because you will understand the reasons for the compromises and will be able to determine what type of architecture is needed in your particular case.  But whatever you do, stop talking about ‚ÄúSR‚Äù and ‚ÄúAR‚Äù, because it does not make sense. </div><p>Source: <a href="https://habr.com/ru/post/258145/">https://habr.com/ru/post/258145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258127/index.html">OpenHAB and home controller - we make iron</a></li>
<li><a href="../258129/index.html">Installing OTRS v4 on Windows</a></li>
<li><a href="../258135/index.html">Modified driver from ReactOS makes life easier on Windows on a Chromebook</a></li>
<li><a href="../258137/index.html">Wi-Fi CO2 meter on ESP8266 + K-30</a></li>
<li><a href="../258139/index.html">What to expect when you expect a child: PHP 7, part 2</a></li>
<li><a href="../258147/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ160 (May 11 - 17, 2015)</a></li>
<li><a href="../258151/index.html">5 tools to help analyst</a></li>
<li><a href="../258153/index.html">Coverage SQL in Postgres</a></li>
<li><a href="../258155/index.html">Energia Launchpad wireless electronic lock</a></li>
<li><a href="../258157/index.html">Audio playback on Intel Edison via Bluetooth using the Advanced Audio Distribution Profile (A2DP)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>