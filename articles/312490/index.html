<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to assemble bigrams for a body of any size on a home computer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In modern computational linguistics, bigrams, or in general n-grams, are an important statistical tool. In the article, we will describe what difficul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to assemble bigrams for a body of any size on a home computer</h1><div class="post__text post__text-html js-mediator-article">  In modern computational linguistics, bigrams, or in general n-grams, are an important statistical tool.  In the article, we will describe what difficulties can be encountered when calculating bigrams on a large body of texts and present an algorithm that can be used on any home computer. <br><a name="habracut"></a><br>  A bigram is two words that are adjacent in the text or, in our case, in the corpus of texts.  For example in the sentence: <br><br><pre> It was a hot summer.
 1 2 3 4 5 (space after the "summer" is not a typo or error)
</pre><br>  There will be such bigrams: <br><br><ul><li>  It was </li><li>  it was hot </li><li>  hot summer </li><li>  summer . </li></ul><br>  Strictly speaking, bigrams consist not of words, but of tokens.  Token, i.e.  an indivisible unit within our task, will be either a word or a punctuation sign.  Tokenization is not an easy topic, so we will assume that our corpus is already tokenized and split into sentences, and in order to convert a sentence into a list of tokens, it is enough to split it by a space. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Our task will be to get this list: <br><br><ul><li>  It was 190360 </li><li>  it was hot 1017 </li><li>  hot summer 2621 </li><li>  summer .  42146 </li></ul><br>  where the number shows how many times the bigram occurs in the whole body. <br><br>  Sometimes in the text we allow ourselves to use the term double-combination as a synonym for the word digram. <br><br>  In this article, we intend to omit all implementation details, since  The approach is interesting in itself and is easy to implement in your favorite programming language.  In addition, the implementation contains a sufficient amount of interesting details to talk about it in a separate article.  The minimum number of explanatory remarks will be given in Java. <br><br><h3>  Naive approach </h3><br><ul><li>  run on the body </li><li>  from each sentence highlight digrams </li><li>  read them using a multiset data structure (in Java it is Multiset &lt;String&gt; or ConcurrentHashMultiset &lt;String&gt; in a multithreaded version) </li></ul><br>  On a relatively small and clean case, it may work, but in the general case, with a naive approach, your memory will run out before you have time to calculate the entire array of texts. <br><br><h3>  Add intermediate clipping </h3><br>  A naive approach is very easy to turn into a worker, if you modify it a bit: <br><br><ul><li>  run on the body </li><li>  from each sentence highlight digrams </li><li>  read them using multisets </li><li>  as soon as we see that the memory is running out, we clear the counter, deleting the biggrams that have met at this point less than the threshold number of times </li></ul><br>  This modification gives a completely working algorithm, but the cut-offs bring one trouble: along with unnecessary noise, like irregular typos and errors, we will remove a lot of useful information about rare words.  For example, if a lexeme (set of word forms) is found 1000 times in a case, then each of its separate word forms may occur, say, less than 200 times per case, and what to speak of two combinations. <br><br>  Our task is to count the bigrams as honestly as possible, without using intermediate cuts. <br><br><h3>  Use the disk as a temporary memory. </h3><br>  RAM now is relatively inexpensive, but still worth it.  In addition, many versions of laptops more than 16 gigabytes, you do not install with all the desire - a platform restriction.  There are no problems with disk space - it costs much less and if you want you can always use an external drive. <br><br>  At the mention of the semantic tags # hard_disk and # algorithm, merge sort algorithms and ordered lists unions, which many people wrote in Pascal at school, pop up in memory.  The ideas behind these algorithms are well suited for solving our problem. <br><br><h3>  The basic scheme of solving the problem </h3><br>  Before proceeding to the details, we present a schematic diagram of the solution of the problem: <br><br><ol><li>  Break the case into approximately equal blocks, say 1 gigabyte. </li><li>  Calculate the bigrams separately for each block, sort them in lexicographical order and write to disk. </li><li>  Using the merge algorithm of ordered lists, merge individual files with two combinations into one, summing up the number of entries for matching digrams. </li></ol><br>  The size of each block can be chosen according to taste (read: according to the amount of installed RAM), but in most tasks the size in gigabytes is more than convenient.  You can also work with a monolithic case, making the program cut-off according to the size of the processed text, throwing the result to disk and clearing the data structures. <br><br>  Looking at the algorithm from a bird's eye view, you can go to the details. <br><br><h3>  We consider bigrams for each block </h3><br>  In order to build an optimal architecture for the two-counting counter, we consider two important requirements: <br><br><ol><li>  We want to count in several streams. </li><li>  At the output you need to get a list of digrams sorted in lexicographical order. </li></ol><br>  So it turns out that these two tasks can be effectively addressed together.  It is proposed instead of using a single-level card (a multiset is essentially a key-counter card) <br><br><pre><code class="java hljs">ConcurrentHashMultiset&lt;String&gt;</code> </pre> <br>  for counting bigrams use a map card: <br><br><pre> <code class="java hljs">ConcurrentMap&lt;String, ConcurrentHashMultiset&lt;String&gt;&gt;</code> </pre><br>  The experiment shows that multithreaded calculation of two-combinations using both data structures is performed in approximately the same time, while sorting using a two-level map is much faster, because  You can sort the keys of the external and internal cards independently. <br><br>  Another major advantage that the use of a two-level map gives is that you can very quickly do additional filtering according to digrams.  For example, check their entry in the dictionary or even perform normalization (fast driving -&gt; fast driving).  It is very costly to perform these operations before you have grouped the same two combinations.  the same operation will be performed many times. <br><br><h3>  Combining results for all blocks </h3><br>  So, at the output of the previous algorithm, we have a set of files with records of the form: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">bigram1</span></span> count1 bigram2 count2 ... bigramN countN</code> </pre><br>  where the keys are sorted in lexicographical order.  Our task is to combine these files into one, summing up the number of entries for matching keys.  The task of summing up two files will be considered trivial and leave without additional explanation. <br><br>  The general problem of combining all files can be solved using a battery file by successively adding individual block files to it: <br><br><pre> <code class="hljs erlang">((((((N1 + N2) + N3) + N4) + N5) + N6) + N7)...</code> </pre><br>  However, this campaign is ineffective, because  After a certain number of iterations, we will add relatively small files of separate blocks to a relatively large battery and spend most of the time reading data from the disk and writing to the disk.  It is much more profitable to build such a strategy, where at each iteration blocks of approximately the same size will be summed up, because the matching keys will collapse into one record and the final file will be smaller than the sum of the two original ones. <br><br>  The backbone of merge sorting using recursion is excellent for implementation.  Schematically, for 15 files it will look like this (for the merge function, the first index is included, the second is excluded): <br><br><pre> | _ merge (0, 15) = merge (0, 7) + merge (7, 15)
   | _ merge (0, 7) = merge (0, 3) + merge (3, 7)
     | _ merge (0, 3) = 0 + merge (1, 3)
       | _ merge (1, 3) = 1 + 2
     | _ merge (3, 7) = merge (3, 5) + merge (5, 7)
       | _ merge (3, 5) = 3 + 4
       | _ merge (5, 7) = 5 + 6
   | _ merge (7, 15) = merge (7, 11) + merge (11, 15)
     | _ merge (7, 11) = merge (7, 9) + merge (9, 11)
       | _ merge (7, 9) = 7 + 8
       | _ merge (9, 11) = 9 + 10
     | _ merge (11, 15) = merge (11, 13) + merge (13, 15)
       | _ merge (11, 13) = 11 + 12
       | _ merge (13, 15) = 13 + 14
</pre><br>  As a result, the algorithm will do the same 14 mergers, but it will work out with the battery option much more efficiently.  There are theoretical memory requirements for the O (1) merge algorithm, but in practice, memory is allocated only for read and write buffers. <br><br><h3>  Finally </h3><br>  Using the above approach, it is possible to assemble not only bigrams along the body, but also n-grams for any n.  Although there may have to use blocks of smaller size and more often throw off intermediate results to disk. <br><br>  As we said at the beginning, the implementation details deserve a separate discussion, and we will describe them in the next article. </div><p>Source: <a href="https://habr.com/ru/post/312490/">https://habr.com/ru/post/312490/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312470/index.html">Storing user passwords in Google Chrome on Android</a></li>
<li><a href="../312472/index.html">Why super-mega-about machine learning in 15 minutes still does not become</a></li>
<li><a href="../312476/index.html">How Asana makes it easier to work with the team, documents and brings more profit</a></li>
<li><a href="../312482/index.html">Hackathon according to criminal statistics</a></li>
<li><a href="../312484/index.html">How to love mbed, and then screw it up twice</a></li>
<li><a href="../312492/index.html">OpenShift v3. Part II. Continue dating. ROR4</a></li>
<li><a href="../312494/index.html">Saga about the cluster. Everything you wanted to know about Postgres horizontal scaling</a></li>
<li><a href="../312496/index.html">How we built our mini data center. Part 2 - Hermoson</a></li>
<li><a href="../312498/index.html">A few words about moving to Cyprus</a></li>
<li><a href="../312500/index.html">Do not step on our rake with TK: an epic contest experience and a couple of tales</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>