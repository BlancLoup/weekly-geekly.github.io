<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Developing your own core for embedding into the FPGA processor system</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So, in the first article of the cycle, it was said that for controlling the equipment implemented by the FPGA, for the Redd complex it is best to use ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Developing your own core for embedding into the FPGA processor system</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/ze/eo/9f/zeeo9fw5rmqp8pk7lsmr0cytbve.jpeg"><br><br>  So, in the <a href="https://habr.com/ru/post/452656/">first article of the cycle,</a> it was said that for controlling the equipment implemented by the FPGA, for the Redd complex it is best to use the processor system, after which during the first and second articles it was shown how to do this system.  Well, it is done, we can even select some ready-made kernels from the list to include them in it, but the ultimate goal is to manage our own non-standard kernels.  It is time to consider how to include an arbitrary core in the processor system. <br><a name="habracut"></a><br>  All articles of the cycle: <br>  <a href="https://habr.com/ru/post/452656/">Development of the simplest ‚Äúfirmware‚Äù for the FPGA installed in Redd, and debugging using the memory test as an example</a> <br>  <a href="https://habr.com/ru/post/453682/">Development of the simplest ‚Äúfirmware‚Äù for the FPGA installed in Redd.</a>  <a href="https://habr.com/ru/post/453682/">Part 2. Program Code</a> <br><br>  To understand today's theory, you should find and download the <b>Avalon Interface Specifications</b> document, since the base bus for the NIOS II system is the Avalon bus.  I will refer to sections, tables and figures for the wording of the document dated September 26, 2018. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We open section 3, devoted Memory Mapped Interfaces, to be exact - 3.2.  Table 9 lists the bus signals.  Note that all of these signals are optional.  I did not find a single signal that had ‚ÄúYes‚Äù in the Required column.  We may well not to send one or another signal to our device.  Therefore, in the simplest case, the tire is extremely easy to implement.  The beginning of the table looks like this: <br><br><img src="https://habrastorage.org/webt/qj/et/kn/qjetkngv8gubiwwtqtx8atvab7c.png"><br><br>  As you can see, all the signals are very well described (unless it is done in English).  Below are timing charts for various cases.  The simplest case does not cause any questions.  I will now take a temporary diagram from the document and cover some of the lines with a semitransparent fill (they are all optional, we have the right to exclude any consideration). <br><br><img src="https://habrastorage.org/webt/q4/oz/w_/q4ozw_efgf6v6adbdhnkdeacply.png"><br><br>  Fearfully?  But it's simple: we put the address and the strobe <b>read</b> , we must put the data on the readdata bus.  And vice versa: we are given the address, the data on the writedata bus and the write strobe, and we have to snap the data.  It is not scary at all, a typical tire synchronous. <br><br>  Covered byteenable lines <b>are</b> needed for the case when memory access is not in 32-bit words.  This is extremely important when we design generic kernels.  But when we design a one-day kernel, then we simply write in the document about this core (I am opposed to the mark in my head, but someone can limit it to this) that you need to apply 32-bit words and that's it.  Well, the <b>response</b> signal, it is very special, and it does not interest us in principle. <br><br>  Sometimes it is important that when the equipment is not ready, it is possible to delay the operation of the bus for several cycles.  In this case, add the <b>WaitRequest</b> signal.  The timing diagram changes as follows: <br><br><img src="https://habrastorage.org/webt/sy/hr/lf/syhrlf64dvm-zrr262xvveicea4.png"><br><br>  While <b>WaitRequest is</b> cocked, the master knows that our device is busy.  Be careful, if this signal is not reset, the whole system will ‚Äúhang‚Äù when it is accessed, so that only a reset of the FPGA can reset it.  JTAG will hang with the system.  The last time I saw this phenomenon in the preparation of this article, so that the memories are still bright. <br><br>  Further in the company document, more productive cases of data pipelining and batch transactions are considered, but the task of the article is not to consider all possible options, but to show the reader a way to work, emphasizing that all this is not at all scary, so we limit ourselves to these two simple options. <br><br>  Let's design some simple device that will periodically become unavailable via the bus.  The first thing that comes to mind is the serial interface.  While we are transmitting, we will make the system wait.  And in life, I categorically do not advise doing this: the processor will stop until the end of a busy transaction, but for an article this is an ideal case, since the implementing code will be understandable and not very cumbersome.  In general, we will make a serial transmitter that can send data and signals for selecting a chip to two devices. <br><br><img src="https://habrastorage.org/webt/fr/uj/_u/fruj_ufw0phhzgbovupezinxo6c.png"><br><br>  Let's start with the simplest version of the tire.  We make a parallel output port, which forms the signals for selecting crystals. <br><br><img src="https://habrastorage.org/webt/rc/z6/yg/rcz6ygig6s3yz-bxsjwsbonygp4.png"><br><br>  To do this, I will take the project, which turned out in the last article, but in order to avoid confusion, I will put it in the AVALON_DEMO catalog.  The names of other files will not change.  In this directory, create the directory <b>my_cores</b> .  The directory name can be any.  We will store our cores in it.  True, today it will be one.  We create a file there <b>CrazySerial.sv</b> with the following contents: <br><pre><code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output reg [1:0] cs ); always @(posedge clk, posedge reset) begin if (reset == 1) begin cs &lt;= 0; end else begin if (write) case (address) 2'h00: cs &lt;= writedata [1:0]; default:; endcase end end endmodule</code> </pre> <br>  Let's figure it out.  First of all, the interface lines.  <b>clk</b> and <b>reset</b> are clocking and reset lines.  The names of the lines <b>address</b> , <b>write</b> and <b>writedata</b> are taken from the table with the list of signals <b>Memory Mapped Interfaces of the</b> document. <br><br><img src="https://habrastorage.org/webt/lz/q9/rv/lzq9rvmj8mekwwiqqene5mvbu7i.png"><br><br><img src="https://habrastorage.org/webt/pe/xz/a-/pexza-dsswt01-shzs4sy0pkjay.png"><br><br>  In fact, the names I could give any.  The linking of logical lines with physical ones will be made later.  But if you give the names as in the table, the development environment will link them themselves.  Therefore, it is better to take the names from the table. <br><br>  Well, and <b>cs</b> are the crystal selection lines that will come out of the chip. <br><br>  The implementation itself is trivial.  When reset, the outputs are zeroed out.  And so - on each clock cycle we check if there is a <b>write</b> signal.  If the address is zero, then click the data.  You could, of course, add a decoder here, which would prevent the choice of two devices at once, but what is good in life will overload the article.  The article provides only the most necessary steps, however, it is noted that in life everything can be done and more complicated. <br><br>  Perfectly.  We are ready to inject this code into the processor system.  Go to the <b>Platform Designer</b> , select the system that we built during past experiences as an input file: <br><br><img src="https://habrastorage.org/webt/vd/a3/mp/vda3mpnhkbmfl9gj037h7kyefs8.png"><br><br>  Pay attention to the <b>New Component</b> item in the upper left corner: <br><br><img src="https://habrastorage.org/webt/iz/xq/hw/izxqhw8wg6jshahucg0ardu7ukg.png"><br><br>  To add your component, click on this item.  In the opened dialog we fill the fields.  And for the article we will fill in only the name of the component: <br><br><img src="https://habrastorage.org/webt/nn/l8/mt/nnl8mtcsdxmqyp6cjnkrcr-qlc0.png"><br><br>  Now go to the <b>Files</b> tab and click <b>Add File</b> : <br><br><img src="https://habrastorage.org/webt/fo/rw/jx/forwjxin05orcsaaw7uuuiw1mra.png"><br><br>  Add a previously created file, select it in the list and click <b>Analyze Synthesis File</b> : <br><br><img src="https://habrastorage.org/webt/a_/-i/g0/a_-ig0-b-v--safmwwco-gcblvi.png"><br><br>  There are no errors when parsing <b>SystemVerilog</b> , but there are a few conceptual errors.  They are caused by the fact that some lines were incorrectly connected by the development environment.  Go to the <b>Signals &amp; Interfaces</b> tab and pay attention here: <br><br><img src="https://habrastorage.org/webt/be/7s/nb/be7snb0yjnqj8qn-ku_dboeirjs.png"><br><br>  The <b>cs</b> lines were incorrectly assigned to the <b>avalon_slave0</b> interface, the <b>readdata</b> signal.  But all the other lines were recognized correctly, thanks to the fact that we gave them the names from the document table.  But what to do with the problem lines?  They should be attributed to the interface type <b>conduit</b> .  To do this, click on the item "add interface" <br><br><img src="https://habrastorage.org/webt/ur/ce/je/urcejebzbrayxcoyvs16vorleik.png"><br><br>  In the popup menu, choose <b>conduit</b> : <br><br><img src="https://habrastorage.org/webt/2-/l-/45/2-l-45h1b_8jnat3uazcscgcpt0.png"><br><br>  We get a new interface: <br><br><img src="https://habrastorage.org/webt/g_/r4/j0/g_r4j0acbfvawp7plewjmsolw1e.png"><br><br>  If you wish, you can rename it.  True, it will certainly be necessary if we want to make several external interfaces.  As part of the article, let's leave him the name <b>conduit_end</b>  Now we grab the <b>cs</b> line with a mouse and drag it into this interface.  We need to manage to throw a signal under the line <b>conduit_end</b> , then we will be allowed to do this.  In other places the cursor will be displayed in the form of a crossed circle.  In the end, we should have this: <br><br><img src="https://habrastorage.org/webt/gb/2e/lw/gb2elw6dvx2iw11y28uq0qlye5q.png"><br><br>  Replace the type of signal from <b>readdata</b> to, say, <b>chipselect</b> .  The final picture: <br><br><img src="https://habrastorage.org/webt/6o/ur/gq/6ourgq054tn85rth2nixk33_pvs.png"><br><br>  But the mistakes remained.  The <b>avalon bus is</b> not assigned a reset signal.  Select <b>avalon_slave_0</b> from the list and see its properties. <br><br><img src="https://habrastorage.org/webt/s6/0i/--/s60i--4ijigk6exutkovd5zlwi0.png"><br><br>  Replace <b>none</b> with <b>reset</b> .  At the same time examine the other properties of the interface. <br><br><img src="https://habrastorage.org/webt/xn/4d/kf/xn4dkf5jpxsi-6ujubxeuptddo4.png"><br><br>  It can be seen that the addressing is in words.  Well, a number of other things from the documentation is configured here.  What time schedules will be obtained will be drawn at the very bottom of the properties: <br><br><img src="https://habrastorage.org/webt/xc/nw/xq/xcnwxqjxkz7y4qgxtcmn6ulb5eu.png"><br><br>  Actually, there are no more errors.  You can click <b>Finish</b> .  Our created module appeared in the device tree: <br><br><img src="https://habrastorage.org/webt/rt/qe/bz/rtqebza22wictmnw0cpgvw_uu3g.png"><br><br>  Add it to the processor system, connect the clock signals and reset.  We connect the data bus to the processor's <b>Data Master</b> .  Double-click on <b>Conduit_end</b> and give the external signal a name, say, <b>lines</b> .  It turns out something like this: <br><br><img src="https://habrastorage.org/webt/ob/mm/al/obmmalo6x1jytho2mzkvy4emdbu.png"><br><br>  It is important here not to forget that since we have added a block to the system, we must make sure that it does not conflict with anyone in the address space.  In this particular case, there are no conflicts in the figure, but still I will select the <b>System-&gt; Assign Base Addresses</b> menu <b>item</b> . <br><br>  Everything.  The block is created, configured, added to the system.  Press the button <b>Generate HDL</b> , then - <b>Finish</b> . <br><br>  We make a draft assembly of the project, after which we go to <b>Pin Planner</b> and assign the legs.  I did this: <br><br><img src="https://habrastorage.org/webt/mn/fs/39/mnfs39ezihwpwese2tsdto4ialc.png"><br><br>  That corresponds to pins B22 and C22 of the interface connector. <br><br>  We make a final assembly, we load the processor system into the FPGA.  Now we need to refine the program code.  Run Eclipse. <br><br>  Let me remind you, I am currently working with a project that is located in another directory regarding my previous work with Redd.  In order not to be confused, I will delete old projects from the tree (but only from the tree, without erasing the files themselves). <br><br><img src="https://habrastorage.org/webt/xm/jv/ch/xmjvchikm8_ukin_evoqdw28op8.png"><br><br>  Then click the right mouse button on the empty tree and select <b>Import</b> in the menu: <br><br><img src="https://habrastorage.org/webt/yp/kt/sf/ypktsfboxaxgfhqcubjnlwogoxq.png"><br><br>  Next - <b>General-&gt; Existing Project into Workspace</b> : <br><br><img src="https://habrastorage.org/webt/rb/dw/me/rbdwmebel6yu6hjmvyxn7hik0q8.png"><br><br>  And just choose the directory in which the project files are stored: <br><br><img src="https://habrastorage.org/webt/nd/3t/6h/nd3t6hwmddm9pfrwr4cjd4iw4hy.png"><br><br><img src="https://habrastorage.org/webt/ei/qg/de/eiqgdehf_klzhkyyleod_opnlgq.png"><br><br>  Both projects inherited from past experiments will connect to the development environment. <br><br><img src="https://habrastorage.org/webt/qq/vw/jk/qqvwjkfgoli7vu3wedt3qhbnsf0.png"><br><br>  I will highlight the next item in the frame: <br><blockquote>  Each time after changing the hardware configuration, you should re-select the menu item <b>Nios II -&gt; Generate BSP</b> for the BSP project. </blockquote><br><br><img src="https://habrastorage.org/webt/ks/jn/mt/ksjnmtcdfbf2p0vej4qeeltlkxk.png"><br><br>  Actually, after this operation, a new block appeared in the file <b>\ AVALON_DEMO \ software \ SDRAMtest_bsp \ system.h</b> : <br><pre> <code class="plaintext hljs">/* * CrazySerial_0 configuration * */ #define ALT_MODULE_CLASS_CrazySerial_0 CrazySerial #define CRAZYSERIAL_0_BASE 0x4011020 #define CRAZYSERIAL_0_IRQ -1 #define CRAZYSERIAL_0_IRQ_INTERRUPT_CONTROLLER_ID -1 #define CRAZYSERIAL_0_NAME "/dev/CrazySerial_0" #define CRAZYSERIAL_0_SPAN 16 #define CRAZYSERIAL_0_TYPE "CrazySerial"</code> </pre><br>  We are primarily interested in the constant <b>CRAZYSERIAL_0_BASE</b> . <br><br>  Add the following code to the <b>main ()</b> function: <br><pre> <code class="plaintext hljs"> while (true) { IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x00); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x01); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x02); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x03); }</code> </pre><br>  We start debugging and watch the contents of the lines with an oscilloscope.  Must be an incremental binary code.  He is there. <br><br><img src="https://habrastorage.org/webt/fm/xp/0z/fmxp0z5mactvzv-vdv2cahbvj1i.png"><br><br>  And the frequency of access to the ports is just wonderful: <br><br><img src="https://habrastorage.org/webt/cm/rd/of/cmrdofrh6yzmo2xwdkjynz6gwwm.png"><br><br>  Approximately 25 MHz is half the bus frequency (2 clocks per cycle).  Sometimes the access time is not 2 cycles, but more.  This is due to the execution of branch operations in the program.  In general, the simplest access to the bus works. <br><br>  The time has come to add to the example the functionality of the serial port.  To do this, add the <b>waitrequest</b> interface signal related to the bus and a couple of signals of the serial port - <b>sck</b> and <b>sdo</b> .  So, we get the following code snippet on <b>systemverilog</b> : <br><br><img src="https://habrastorage.org/webt/dy/wc/vt/dywcvtwz6_h4ccubotauamcnnju.png"><br><br><div class="spoiler">  <b class="spoiler_title">Same text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output waitrequest, output reg [1:0] cs, output reg sck, output sdo );</code> </pre><br></div></div><br>  According to the rules of good tone, you need to make an uncomplicated machine that will transfer data.  Unfortunately, the most simple machine within the article will look very difficult.  But in fact, if I do not increase the functionality of the machine (and in the framework of the article I‚Äôm not going to do this), then it will have only two states: the transmission is on and there is no transmission.  Therefore, I can encode the state with one signal: <br>  reg sending = 0; <br><br>  During the transfer, I will need a bit counter, a clock divider (I also make a deliberately slow device) and a shift register for the transmitted data.  Add the appropriate registers: <br><pre> <code class="plaintext hljs"> reg [2:0] bit_cnt = 0; reg [3:0] clk_div = 0; reg [7:0] shifter = 0;</code> </pre><br>  I will divide the frequency by 10 (guided by the principle ‚Äúwhy not?‚Äù).  Accordingly, on the fifth cycle I will cock SCK, and on the tenth - drop this line, after which - carry out the transition to the next bit of data.  On all other bars, simply increment the divisor counter.  It is important not to forget that on the fourth clock cycle it is also necessary to increase the counter, and on the ninth one to zero it.  If you omit the process of moving to the next bit, then the specified logic looks like this: <br><pre> <code class="plaintext hljs"> if (sending) begin case (clk_div) 4: begin sck &lt;= 1; clk_div &lt;= clk_div + 1; end 9: begin sck &lt;= 0; clk_div &lt;= 0; // &lt;   &gt; end default: clk_div &lt;= clk_div + 1; endcase end else</code> </pre><br>  The transition to the next bit is simple.  Shifted shift register, then, if the current bit is the seventh, stopped working, switching the state of the machine, otherwise - increased the bit counter. <br><pre> <code class="plaintext hljs"> shifter &lt;= {shifter[6:0],1'b0}; if (bit_cnt == 7) begin sending &lt;= 0; end else begin bit_cnt &lt;= bit_cnt + 1; end</code> </pre><br>  Actually, everything.  The output bit is always taken from the high bit of the shift register: <br><pre> <code class="plaintext hljs"> assign sdo = shifter [7];</code> </pre><br>  And the most important line for the current revision.  Signal <b>waitrequest we</b> cock in unit always, when there is a transfer of consecutive data.  That is, it is a copy of the <b>sending</b> signal that sets the state of the machine: <br><pre> <code class="plaintext hljs"> assign waitrequest = sending;</code> </pre><br>  Well, when writing to address 1 (remember, here we have the addressing in 32-bit words), we snap the data into the shift register, reset the counters and start the transfer process: <br><pre> <code class="plaintext hljs"> if (write) //... 2'h01: begin bit_cnt &lt;= 0; clk_div &lt;= 0; sending &lt;= 1; shifter &lt;= writedata [7:0]; end default:; endcase end</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Now I will give all the described fragments in the form of a single text:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module CrazySerial ( input clk, input reset, input [1:0] address, input write, input [31:0] writedata, output waitrequest, output reg [1:0] cs, output reg sck, output sdo ); reg sending = 0; reg [2:0] bit_cnt = 0; reg [3:0] clk_div = 0; reg [7:0] shifter = 0; always @(posedge clk, posedge reset) begin if (reset == 1) begin cs &lt;= 0; sck &lt;= 0; sending &lt;= 0; end else begin if (sending) begin case (clk_div) 4: begin sck &lt;= 1; clk_div &lt;= clk_div + 1; end 9: begin clk_div &lt;= 0; shifter &lt;= {shifter[6:0],1'b0}; sck &lt;= 0; if (bit_cnt == 7) begin sending &lt;= 0; end else begin bit_cnt &lt;= bit_cnt + 1; end end default: clk_div &lt;= clk_div + 1; endcase end else if (write) case (address) 2'h00: cs &lt;= writedata [1:0]; 2'h01: begin bit_cnt &lt;= 0; clk_div &lt;= 0; sending &lt;= 1; shifter &lt;= writedata [7:0]; end default:; endcase end end assign sdo = shifter [7]; assign waitrequest = sending; endmodule</code> </pre><br></div></div><br>  We begin to introduce a new code into the system.  Actually, the path is the same as when creating the component, but some of the steps can already be omitted.  Now we just get to know the process of refinement.  Go to the <b>Platform Designer</b> .  If we had only verilog code exchanged, it would be enough to simply perform the <b>Generate HDL</b> operation for the finished system.  But since the module has new lines (that is, the interface has changed), it needs to be redone.  To do this, select it in the tree, press the right mouse button and select <b>Edit</b> . <br><br><img src="https://habrastorage.org/webt/sg/el/hx/sgelhxlzgzwjz81z6q7xhkhbxzs.png"><br><br>  We are editing a ready-made system.  So just go to the <b>Files</b> tab and click <b>Analyze Sinthesis Files</b> : <br><br><img src="https://habrastorage.org/webt/qy/nw/0q/qynw0q5tul7k26yaygdyzsigouu.png"><br><br>  Predictably errors occurred.  But we already know that the blame for all the misinterpreted lines.  Therefore, we go to the <b>Signals &amp; Interfaces</b> tab, drag along the <b>sck</b> and <b>sdo lines</b> from the <b>avalon_slave_0</b> interface to the <b>conduit_end</b> interface: <br><br><img src="https://habrastorage.org/webt/z_/rz/jj/z_rzjjaaiaqzey6gczf6ptt0vfa.png"><br><br>  Also rename the <b>Signal Type</b> fields for them.  The result should be the following: <br><br><img src="https://habrastorage.org/webt/ng/3_/t_/ng3_t_kiebqf_jw3wwljh0aqsig.png"><br><br>  Actually, everything.  Click <b>Finish</b> , call <b>Generate HDL File</b> for the processor system, do the draft build of the project in Quartus, assign the new legs: <br><br><img src="https://habrastorage.org/webt/ul/hg/rh/ulhgrhytzp1y9149j8x11apyvcy.png"><br><br>  These are contacts A21 and A22 of the interface connector, we are doing the final assembly, we fill in the ‚Äúfirmware‚Äù in the FPGA. <br><br>  Iron updated.  Now - the program.  Go to Eclipse.  What we do not forget to do there?  That's right, do not forget to choose <b>Generate BSP</b> . <br><br>  Actually, everything.  It remains to add functionality to the program.  We will send a pair of bytes to the serial port, but send the first byte to the device selected by the <b>cs [0] line</b> , and the second by <b>cs [1]</b> . <br><pre> <code class="plaintext hljs"> IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x01); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE+4,0x12); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x02); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE+4,0x34); IOWR_ALTERA_AVALON_PIO_DATA (CRAZYSERIAL_0_BASE,0x00);</code> </pre><br>  Please note that there are no readiness checks.  Parcels go one after another.  However, everything on the oscilloscope was quite consistent. <br><br><img src="https://habrastorage.org/webt/vh/qm/ig/vhqmigcblrnmmcizbs11jwdgsig.png"><br><br>  The yellow beam is <b>cs [0]</b> , the green is <b>sdo</b> , the purple is <b>sck</b> , the blue is <b>cs [1]</b> .  It can be seen that the code 0x12 went to the first device, 0x34 went to the second one. <br><br>  Reading is done in a similar way, but I just can‚Äôt think of any beautiful example, apart from the banal reading of the contents of the connector foot.  But that example is so degenerate that it is not even interesting to do it.  But here it is worth noting that when reading this bus setting can be extremely important: <br><br><img src="https://habrastorage.org/webt/m4/7g/i6/m47gi6xbkat-jct5iuuffqmyya8.png"><br><br>  If there is a line <b>Read</b> , then a time diagram of reading will appear on the settings dialog.  And it will show the effect of this parameter.  When reading the connector leg, it will still not be noticeable, but when reading from the same FIFO or RAM - completely.  RAM can be configured to issue data immediately after the address is submitted, or it can be sent to synchronous output.  In the second case, latency is added.  After all, the bus set the address, set the gate ... But there is no data yet on the nearest edge of the clock signal.  They will appear after this front ... That is, the system has latency in one clock cycle.  And just it is necessary to consider it, having set this parameter.  In short, if it‚Äôs not what was expected, first check to see if you need to adjust latency.  As for the rest, reading is no different from writing. <br><br>  Well, let me remind you once again that it is better not to remove the tire readiness during long operations, otherwise it is quite possible to drastically reduce system performance.  The readiness signal is good to hold the transaction for a couple of ticks, and not up to 80 ticks, as in my example.  But firstly, any other example would be inconvenient for an article, and secondly, for one-day kernels, this is completely acceptable.  You will be fully aware of your actions and will avoid situations where the tire is blocked.  However, if the core survives the time allotted to it, such an assumption can ruin life in the future, when everyone will forget about it, but it will slow down everything.  But it will be later. <br><br>  Nevertheless, we have learned how to make the processor core control our cores.  With the addressed world everything is clear, now it‚Äôs time to deal with the streaming world.  But we will do this in the next article, and perhaps even a few articles. <br><br><h3>  Conclusion </h3><br>  The article shows how an arbitrary kernel in the Verilog language can be connected to control the means of the Nios II processor system.  The options for the simplest connection to the Avalon bus are shown, as well as connections in which the bus can be in a busy state.  There are links to literature, from which you can find other modes of the Avalon bus in Memory Mapped mode. <br><br>  The resulting project can be downloaded <a href="https://yadi.sk/d/PxT_VU_F6mtP_w">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/454938/">https://habr.com/ru/post/454938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454922/index.html">Tales about foreign customers and their peculiarities of work in Russia after the law on PD</a></li>
<li><a href="../454926/index.html">Everything you know about word2vec is not true</a></li>
<li><a href="../454928/index.html">A way to bypass the Windows lock screen on RDP sessions</a></li>
<li><a href="../454930/index.html">Garbage Collection in V8: How the New Orinoco GC Works</a></li>
<li><a href="../454936/index.html">Vivaldi: ad blocking should be user selectable</a></li>
<li><a href="../45494/index.html">University tour Opera. Kiev</a></li>
<li><a href="../454940/index.html">Travel insurance: detailed instructions</a></li>
<li><a href="../454944/index.html">How the JPEG format works</a></li>
<li><a href="../454950/index.html">Work and life IT pros in Cyprus - the pros and cons</a></li>
<li><a href="../454958/index.html">An inside look: graduate school at EPFL. Part 4.1: daily life</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>