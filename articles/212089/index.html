<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Masking the class under the Boost graph. Part 2: Completing the implementation of concept support</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue: Boost Concepts 
 Part 1: Connection of associated types without interfering with the source class interface 

 Briefly recall the task. Ther...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Masking the class under the Boost graph. Part 2: Completing the implementation of concept support</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a5b/77f/599/a5b77f5999db35249fa68daae2ff4415.png" align="left" width="300" height="300"><br>  <a href="http://habrahabr.ru/post/210838/">Prologue: Boost Concepts</a> <br>  <a href="http://habrahabr.ru/post/211558/">Part 1: Connection of associated types without interfering with the source class interface</a> <br><br>  Briefly recall the task.  There is a two-dimensional playing field of cells, some of which are free, and some are occupied.  It is required to find a path through the free cells from one position of the field to another.  The pathfinding algorithm is implemented in Boost.  But he demands that our field fit the definition of a graph.  More precisely, the class must satisfy two concepts - <b>boost :: VertexListGraph</b> and <b>boost :: IncidenceGraph</b> .  At the same time, there is no wish to change the interface of the playing field - for the rest of the project this is not a graph and it will never become a graph. <br><br>  In the last part, we examined the connection of external associated types that are necessary for interpreting a class as a boost graph.  Of course, some types are not enough.  You also need to implement several functions with a given signature and iterators, with the help of which the library will be able to manipulate the game field as a graph. <br><a name="habracut"></a><br>  Let's start with the function <b>num_vertices</b> , which, as the name suggests, should return the number of graph vertices.  For our case, this is the length of the playing field multiplied by the width.  The <b>VerticesSizeType</b> type <b>is</b> defined in the <a href="http://habrahabr.ru/post/211558/">first part of the article</a> (in fact, it is an int). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">VerticesSizeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">num_vertices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameField&amp; graph)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> graph.getWidth() * graph.getHeight(); }</code> </pre> <br><br>  Now you can go to the implementation of the first iterator.  He will be responsible for enumerating all the vertices of the graph.  Earlier we agreed that vertices will be denoted by integers from zero to <b>num_vertices</b> .  To avoid writing an iterator from scratch, we use the auxiliary class <b>boost :: forward_iterator_helper</b> .  It allows you to get a full-fledged iterator, defining only a few basic operators: increment (++), comparisons (==) and dereferencing (*).  In addition, the search algorithm requires that a default constructor exist for the iterator.  Naturally, in this form, using an object is impossible - before applying, the library will assign the correct value to the iterator. <br><br>  First, look at the class interface <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VertexIteratorImpl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::forward_iterator_helper&lt;VertexIteratorImpl, Vertex, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span>, Vertex*, Vertex&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: VertexIteratorImpl(); VertexIteratorImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField&amp; field, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++ (); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>== (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VertexIteratorImpl&amp; anotherIterator) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; Vertex <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mIndex; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField* mField; };</code> </pre><br><br>  The iterator stores the current vertex number and a pointer to the playing field.  The explicit default constructor simply has to be - it does not create a ‚Äúworking‚Äù object: <br><br><pre> <code class="cpp hljs">VertexIteratorImpl::VertexIteratorImpl() : mField(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) , mIndex(<span class="hljs-number"><span class="hljs-number">0</span></span>) { }</code> </pre><br><br>  The second constructor allows you to create a full-featured object. <br><br><pre> <code class="cpp hljs">VertexIteratorImpl::VertexIteratorImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField&amp; field, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index) : mField(&amp;field) , mIndex(index) { }</code> </pre><br><br>  <b>isValid</b> - an auxiliary function that checks whether the iterator is in the correct state (the playing field is set, the index has a valid value) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> VertexIteratorImpl::isValid() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (mField != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) &amp;&amp; (mIndex &lt; num_vertices(*mField)) &amp;&amp; (mIndex &gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><br>  Given that a vertex is a number, the implementation of operators is extremely simple, and it comes down to working with the mIndex field.  Here is a test for equality <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> VertexIteratorImpl::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>== (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> VertexIteratorImpl&amp; anotherIterator) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mIndex == anotherIterator.mIndex; }</code> </pre><br><br>  This is the increment of the iterator - you only need to check if the index does not exceed the number of graph vertices <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> VertexIteratorImpl::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++ () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValid()) { ++mIndex; } }</code> </pre><br><br>  Dereferencing is reduced to returning the vertex number <br><br><pre> <code class="cpp hljs">Vertex VertexIteratorImpl::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mIndex; }</code> </pre><br><br>  After that, it becomes possible to create another function required by graph concepts - <b>vertices</b> .  It must return two iterators of vertices - the initial one and the next after the last (analogous to <b>end ()</b> in standard collections). <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;VertexIterator, VertexIterator&gt; vertices(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField&amp; graph) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(VertexIterator(graph, <span class="hljs-number"><span class="hljs-number">0</span></span>), VertexIterator(graph, num_vertices(graph))); }</code> </pre><br><br>  The VertexIterator type is defined in the <a href="http://habrahabr.ru/post/211558/">first part of the article</a> (this is an alias VertexIteratorImpl).  Now let's set the edges.  First you need to define a couple of functions that, having received an edge, will return its initial and final vertices. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vertex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">source</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edge edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameField &amp;graph)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> edge.first; } <span class="hljs-function"><span class="hljs-function">Vertex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">target</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Edge edge, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameField &amp;graph)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> edge.second; }</code> </pre><br><br>  The second parameter is to transfer the graph to them, even if it is not needed for work (in our case, the edge is a pair of vertices).  It remains to create an iterator outgoing edges from a given vertex.  It is a little more difficult to implement, but still quite primitive.  Algorithm of work: check 8 vertices around a given one, if they are free, then there are edges, if busy, there is no way in this direction.  Let's start with the interface <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutEdgeIteratorImpl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::forward_iterator_helper&lt;OutEdgeIterator, Edge, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">ptrdiff_t</span></span>, Edge*, Edge&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: OutEdgeIteratorImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField&amp; field, Vertex cellPosition, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>); OutEdgeIteratorImpl(); Edge <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++ (); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>== (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OutEdgeIterator&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-function">Vertex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCurrentPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">Vertex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTargetPosition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">updateShift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isValid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mShift; Vertex mCellPosition; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField* mField; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sShiftsX[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> sShiftsY[<span class="hljs-number"><span class="hljs-number">8</span></span>]; };</code> </pre><br><br>  <b>sShiftsX</b> and <b>sShiftsY</b> are arrays with offsets along the x and y axes to iterate over adjacent vertices. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OutEdgeIteratorImpl::sShiftsX[<span class="hljs-number"><span class="hljs-number">8</span></span>] = { <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> OutEdgeIteratorImpl::sShiftsY[<span class="hljs-number"><span class="hljs-number">8</span></span>] = { <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">-1</span></span>};</code> </pre><br><br>  With constructors, the same situation as for the vertex iterator - the default constructor creates a dummy object (needed for the library to work), we will use the second constructor ourselves. <br><br><pre> <code class="cpp hljs">OutEdgeIteratorImpl::OutEdgeIteratorImpl() : mField(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) , mCellPosition(<span class="hljs-number"><span class="hljs-number">0</span></span>) , mShift(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } OutEdgeIteratorImpl::OutEdgeIteratorImpl(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField&amp; field, Vertex cellPosition, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index<span class="hljs-comment"><span class="hljs-comment">/* = 0*/</span></span>) : mField(&amp;field) , mCellPosition(cellPosition) , mShift(index) { updateShift(); }</code> </pre><br><br>  Unlike bypassing the vertices, it will not be possible to return all the edges in a row - some of them may not exist.  Therefore, the increment operator will contain the <b>updateShift</b> method, whose task is to check the validity of the current position of the iterator and, if necessary, ‚Äúscroll‚Äù it further. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OutEdgeIteratorImpl::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>++ () { ++mShift; updateShift(); }</code> </pre><br>  The check is performed using the <b>GameField :: canPass (int x, int y)</b> game field method, if it returns false (there is no path to the specified cell), the next neighboring cell will be checked.  Outgoing edges can be from zero to eight. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> OutEdgeIteratorImpl::updateShift() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isValid()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie(x, y) = getCoordinates(mCellPosition, *mField); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dx = sShiftsX[mShift]; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dy = sShiftsY[mShift]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mField-&gt;canPass(x + dx, y + dy)) { ++mShift; updateShift(); } } } <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> OutEdgeIteratorImpl::isValid() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (mField != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) &amp;&amp; (mShift &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp;&amp; (mShift &gt;=<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br><br>  The iterator also contains two auxiliary methods that return the initial vertex (which was passed to the constructor) and outgoing (calculated based on the <b>mShift</b> offset). <br><br><pre> <code class="cpp hljs">Vertex OutEdgeIteratorImpl::getCurrentPosition() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mCellPosition; } Vertex OutEdgeIteratorImpl::getTargetPosition() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getCurrentPosition() + sShiftsX[mShift] + mField-&gt;getWidth() * sShiftsY[mShift]; }</code> </pre><br><br>  The dereference operator returns this pair of vertices: <br><br><pre> <code class="cpp hljs">Edge OutEdgeIteratorImpl::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(getCurrentPosition(), getTargetPosition()); }</code> </pre><br><br>  Comparison of edge iterators, as well as for the case with vertices, reduces to comparing the numerical indices <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> OutEdgeIteratorImpl::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>== (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OutEdgeIteratorImpl&amp; other) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mShift == other.mShift; }</code> </pre><br><br>  And the last step remains - to determine the edge search functions, which work on the basis of the created iterators.  This is how the search function for outgoing edges for a given vertex will look like. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;OutEdgeIterator, OutEdgeIterator&gt; out_edges(Vertex v, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField&amp; graph) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(OutEdgeIterator(graph, v, <span class="hljs-number"><span class="hljs-number">0</span></span>), OutEdgeIterator(graph, v, <span class="hljs-number"><span class="hljs-number">8</span></span>)); }</code> </pre><br><br>  As an iterator, the end is passed to an object with index 8, since there can be no edges with this number (valid values ‚Äã‚Äãare from 0 to 7).  The function of determining the number of outgoing edges also uses an <b>OutEdgeIterator</b> iterator - it counts the edges by search. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">DegreeSizeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">out_degree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vertex v, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameField&amp; graph)</span></span></span><span class="hljs-function"> </span></span>{ DegreeSizeType result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;OutEdgeIterator, OutEdgeIterator&gt; edges = out_edges(v, graph); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (OutEdgeIterator i = edges.first; i != edges.second; ++i) { ++result; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br><br>  Everything.  Now you can write concept validation functions and enjoy the result - our playing field simultaneously satisfies the requirements for two types of columns: <br><br><pre> <code class="cpp hljs"> boost::function_requires&lt;boost::VertexListGraphConcept&lt;GameField&gt; &gt;(); boost::function_requires&lt;boost::IncidenceGraphConcept&lt;GameField&gt; &gt;();</code> </pre><br><br>  This completes the implementation of the concepts.  For the path finding algorithms to work, a few more improvements will be needed - I will tell about them in the final article of the cycle. </div><p>Source: <a href="https://habr.com/ru/post/212089/">https://habr.com/ru/post/212089/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../212073/index.html">Your success as a programmer depends on you.</a></li>
<li><a href="../212075/index.html">Bionic hand prosthesis returns touch</a></li>
<li><a href="../212077/index.html">PhpStorm - improve performance (keyboard shortcuts). Part 1</a></li>
<li><a href="../212085/index.html">Quick build OS images with Packer</a></li>
<li><a href="../212087/index.html">Bitcoin crash</a></li>
<li><a href="../212091/index.html">Installing VLC Player violates the warranty of the speakers in a Dell laptop</a></li>
<li><a href="../212093/index.html">Automatic light and music ASIM-AU-2-6</a></li>
<li><a href="../212095/index.html">Galois field arithmetic for encoding information by Reed-Solomon codes</a></li>
<li><a href="../212097/index.html">Electronics manufacturing in China - what to expect?</a></li>
<li><a href="../212099/index.html">Player from Playboy magazine (continuation of the epic)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>