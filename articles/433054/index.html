<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A needle in a stack of sessions, or regular expression bytecode</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="17 billion events, 60 million user sessions and a huge number of virtual dates occur in Badoo every day. Each event is carefully stored in relational ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A needle in a stack of sessions, or regular expression bytecode</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/kz/rl/nu/kzrlnugblhii_j4jrsqzdk9fsgo.jpeg"></p><br><p>  17 billion events, 60 million user sessions and a huge number of virtual dates occur in Badoo every day.  Each event is carefully stored in relational databases for subsequent analysis in SQL and not only. </p><br><p>  Modern distributed transactional databases with dozens of terabytes of data is a real engineering marvel.  But SQL as the embodiment of relational algebra in most standard implementations does not yet allow formulating queries in terms of ordered tuples. </p><br><p>  In the last article in the <a href="https://habr.com/company/badoo/blog/425325/">virtual</a> <a href="https://habr.com/company/badoo/blog/428878/">machines</a> series, I‚Äôll talk about an alternative approach to finding interesting sessions ‚Äî the regular expression engine ( <a href="">‚ÄúThe Pig Matcher‚Äù</a> ) defined for sequences of events. </p><br><p>  Virtual machine, bytecode and compiler are attached for free! </p><a name="habracut"></a><br><h1 id="o-sobytiyah-i-sessiyah">  About events and sessions </h1><br><p>  Suppose we already have a data warehouse that allows us to quickly and consistently view the events of each of the user sessions. </p><br><p>  We want to find sessions based on requests like ‚Äúcount all sessions where there is a specified subsequence of events‚Äù, ‚Äúfind parts of a session described by a given pattern‚Äù, ‚Äúreturn that portion of a session that happened after a given pattern‚Äù or ‚Äúcalculate how many sessions have reached certain parts template. "  This can be useful for various types of analysis: search for suspicious sessions, funnel analysis, etc. </p><br><p>  The required subsequences must somehow be described.  In its simplest form, this task is similar to finding a substring in the text;  we want to have a more powerful tool - regular expressions.  Modern implementations of regular expression engines most often use (you guessed it!) Virtual machines. </p><br><p>  Creating small virtual machines for matching sessions with regular expressions will be discussed below.  But first let's clarify the definition. </p><br><p>  <em>An event</em> consists of an event type, a time, a context, and a set of attributes specific to each type. </p><br><p>  <em>The type</em> and <em>context of</em> each of the events are integers from predefined lists.  If everything is clear with the types of events, then the context is, for example, the number of the screen on which the specified event occurred. </p><br><p>  <em>An</em> event <em>attribute</em> is an arbitrary integer whose meaning is determined by the type of event.  There may be no attributes of the event, or there may be several of them. </p><br><p>  <em>A session</em> is a sequence of events sorted by time. </p><br><p>  But let's finally get down to business.  The buzz, as they say, subsided, and I went to the stage. </p><br><h1 id="sravnivaem-po-bumazhke">  Compare by piece of paper </h1><br><p><img src="https://habrastorage.org/webt/gu/ec/dw/guecdwuc3rhjl1oc6cvuk-4ec9k.jpeg"></p><br><p>  The peculiarity of this virtual machine is passivity in relation to input events.  We do not want to keep the entire session in memory and allow the virtual machine to go from event to event independently.  Instead, we will, one after another, submit events from the session to the virtual machine. </p><br><p>  Define interface functions: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">matcher *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *bytecode)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> event)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *matcher)</span></span></span></span>;</code> </pre> <br><p>  If everything is clear with the functions matcher_create and matcher_destroy, then the matcher_accept should be commented.  The matcher_accept function receives an instance of the virtual machine and the next event (32 bits, where 16 bits are for the type of event and 16 bits are for the context), and returns a code explaining what to do next to the user code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> match_result { <span class="hljs-comment"><span class="hljs-comment">//       MATCH_NEXT, //    ,      MATCH_OK, //       ,      MATCH_FAIL, //     MATCH_ERROR, } match_result;</span></span></code> </pre><br><p>  Virtual machine opcodes: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { <span class="hljs-comment"><span class="hljs-comment">//  ,      OP_ABORT, //      ( -  ) OP_NAME, //     ( -  ) OP_SCREEN, //    OP_NEXT, //    OP_MATCH, } matcher_opcode;</span></span></code> </pre><br><p>  The main loop of the virtual machine: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP() \ (*m-&gt;ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG() \ ((void)(m-&gt;ip += 2), (m-&gt;ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + m-&gt;ip[-1]) for (;;) { uint8_t instruction = NEXT_OP(); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(); if (event_name(next_event) != name) return MATCH_FAIL; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(); if (event_screen(next_event) != screen) return MATCH_FAIL; break; } case OP_NEXT:{ return MATCH_NEXT; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre> <br><p>  In this simple version, our virtual machine sequentially matches the pattern described by the byte code with the incoming events.  In this form, it is simply not too concise a comparison of the <em>prefixes of</em> two lines: the desired pattern and the input string. </p><br><p>  Prefixes are prefixes, but we want to find the required templates not only at the beginning, but also in an arbitrary place of the session.  A naive solution is to restart the mapping from each session event.  But this implies a multiple viewing of each of the events and the eating of algorithmic babies. </p><br><p>  <a href="">The example</a> from the <a href="https://habr.com/company/badoo/blog/425325/">first article of the</a> series, in effect, simulates the restart of the mapping with the help of rollback (eng. Backtracking).  The code in the example looks, of course, slimmer given here, but the problem has not gone away: each of the events will have to check many times. </p><br><p>  So you can not live. </p><br><h1 id="ya-esche-raz-ya-i-snova-ya">  I, I again and I again </h1><br><p><img src="https://habrastorage.org/webt/bq/ue/gt/bquegtp3mpd4rxv65f1fk-svdjk.jpeg"></p><br><p>  Let's once again denote the task: it is necessary to match the pattern with the incoming events, starting from each of the events a new mapping.  So why don't we do that?  Let the virtual machine go through the incoming events in several threads! </p><br><p>  To do this, we need to create a new entity - a stream.  Each stream stores a single pointer ‚Äî to the current instruction: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher_thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *ip; } matcher_thread;</code> </pre><br><p>  Naturally, we will not store an explicit pointer in the virtual machine itself either.  It will be replaced by two lists of threads (about them below): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matcher</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *bytecode; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the current event */</span></span> matcher_thread current_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> current_thread_num; <span class="hljs-comment"><span class="hljs-comment">/* Threads to be processed using the event to follow */</span></span> matcher_thread next_threads[MAX_THREAD_NUM]; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> next_thread_num; } matcher;</code> </pre><br><p>  And here is the updated main loop: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">match_result </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">matcher_accept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(matcher *m, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next_event)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_OP(thread) \ (*(thread).ip++) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NEXT_ARG(thread) \ ((void)((thread).ip += 2), ((thread).ip[-2] </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 8) + (thread).ip[-1]) /*         - */ add_current_thread(m, initial_thread(m)); //         for (size_t thread_i = 0; thread_i &lt; m-&gt;current_thread_num; thread_i++ ) { matcher_thread current_thread = m-&gt;current_threads[thread_i]; bool thread_done = false; while (!thread_done) { uint8_t instruction = NEXT_OP(current_thread); switch (instruction) { case OP_ABORT:{ return MATCH_ERROR; } case OP_NAME:{ uint16_t name = NEXT_ARG(current_thread); //  ,      ,    //     next_threads,    if (event_name(next_event) != name) thread_done = true; break; } case OP_SCREEN:{ uint16_t screen = NEXT_ARG(current_thread); if (event_screen(next_event) != screen) thread_done = true; break; } case OP_NEXT:{ //    , ..      // next_threads add_next_thread(m, current_thread); thread_done = true; break; } case OP_MATCH:{ return MATCH_OK; } default:{ return MATCH_ERROR; } } } } /*      ,    */ swap_current_and_next(m); return MATCH_NEXT; #undef NEXT_OP #undef NEXT_ARG }</span></span></span></span></code> </pre><br><p>  At each received event, we first add the current_threads new stream to the list, checking the pattern from the very beginning, and then we begin to crawl the current_threads list, for each of the threads, following the instructions on the pointer. </p><br><p>  If the NEXT instruction is encountered, the thread is placed in the list of next_threads, that is, waiting for the next event to be received. </p><br><p>  If the thread template does not match the event received, then such a thread is simply not added to the next_threads list. </p><br><p>  The MATCH instruction immediately exits the function, telling the return code that the pattern matches the session. </p><br><p>  When the thread list traversal is complete, the current and next lists are swapped. </p><br><p>  Actually, everything.  We can say that we literally do what we wanted: we simultaneously check several templates, launching one new matching process for each of the session events. </p><br><h1 id="mnozhestvennye-lichnosti-i-vetvleniya-v-shablonah">  Multiple personalities and branches in patterns </h1><br><p><img src="https://habrastorage.org/webt/8l/gv/-e/8lgv-e5bp1xhv0ksukeacrhasaq.jpeg"></p><br><p>  Looking for a template that describes a linear sequence of events is, of course, useful, but we want to get full-fledged regular expressions.  And the streams that we created in the previous step will also be useful here. </p><br><p>  Suppose we want to find a sequence of two or three events of interest to us, something like a regular expression on the strings: "a? Bc".  In this sequence, the character "a" is optional.  How to express it in bytecode?  Easy! </p><br><p>  We can run <em>two</em> streams, one for each case: with and without the "a" symbol.  To do this, we introduce an additional instruction (of the form SPLIT addr1, addr2), which starts two streams from the specified addresses.  In addition to SPLIT, we can also use JUMP, which simply continues execution with the instruction specified in the argument directly: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> matcher_opcode { OP_ABORT, OP_NAME, OP_SCREEN, OP_NEXT, <span class="hljs-comment"><span class="hljs-comment">//     OP_JUMP, //         OP_SPLIT, OP_MATCH, //     OP_NUMBER_OF_OPS, } matcher_opcode;</span></span></code> </pre> <br><p>  The loop itself and the remaining instructions do not change - we will simply add two new handlers: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... case OP_JUMP:{ /*   ,      */ uint16_t offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, offset)); break; } case OP_SPLIT:{ /*        */ uint16_t left_offset = NEXT_ARG(current_thread); uint16_t right_offset = NEXT_ARG(current_thread); add_current_thread(m, create_thread(m, left_offset)); add_current_thread(m, create_thread(m, right_offset)); break; } // ...</span></span></code> </pre><br><p>  Notice that the instructions add threads to the current list, that is, they continue to work in the context of the current event.  The thread within which a branch has occurred is no longer in the list of the following threads. </p><br><p>  The most surprising thing about this virtual machine for regular expressions is that our threads and this pair of instructions are enough to express almost all the constructs that are common when matching strings. </p><br><h1 id="regulyarnye-vyrazheniya-na-sobytiyah">  Regular expressions on events </h1><br><p>  Now that we have the right virtual machine and the tools for it, we can deal with the syntax for our regular expressions. </p><br><p>  Manual recording opcodes for more serious programs quickly tires.  Last time I didn‚Äôt make a full-fledged parser, but the user <a href="https://habr.com/users/true-grue/" class="user_link">true-grue</a> showed the capabilities of his <a href="https://github.com/true-grue/raddsl">raddsl</a> library <a href="https://github.com/true-grue/raddsl">using the</a> example of the mini-language <a href="https://github.com/true-grue/raddsl">PigletC</a> .  I was so impressed with the brevity of the code that with the help of raddsl I wrote a small compiler of regular expressions of lines a hundred or two hundred in Python.  <a href="https://github.com/vkazanov/bytecode-interpreters-post/tree/master/regexp">The compiler</a> and instructions for its use are on GitHub.  The result of the compiler's work in assembly language is understood by the utility that reads two files (a program for a virtual machine and a list of session events for verification). </p><br><p>  To begin with, we limit ourselves to the type and context of the event.  Event type is denoted by a single number;  if you need to specify a context, we specify it through a colon.  The simplest example is: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13" # ,     13 NEXT NAME 13 MATCH</code> </pre> <br><p>  Now an example with context: </p><br><pre> <code class="plaintext hljs">python regexp/regexp.py "13:12" #  13,  12 NEXT NAME 13 SCREEN 12 MATCH</code> </pre> <br><p>  Sequential events must be somehow separated (for example, by spaces): </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "13 11 10:9" 08:40:52 NEXT NAME 13 NEXT NAME 11 NEXT NAME 10 SCREEN 9 MATCH</code> </pre> <br><p>  The template is more interesting: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "12|13" SPLIT L0 L1 L0: NEXT NAME 12 JUMP L2 L1: NEXT NAME 13 L2: MATCH</code> </pre> <br><p>  Note the lines ending with a colon.  These are tags.  The SPLIT instruction creates two threads that continue execution from the L0 and L1 tags, and the JUMP at the end of the first branch of execution just goes to the end of the branch. </p><br><p>  You can choose between chains of expressions more genuinely by grouping subsequences with parentheses: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "(1 2 3)|4" SPLIT L0 L1 L0: NEXT NAME 1 NEXT NAME 2 NEXT NAME 3 JUMP L2 L1: NEXT NAME 4 L2: MATCH</code> </pre> <br><p>  An arbitrary event is indicated by a period: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py ". 1" NEXT NEXT NAME 1 MATCH</code> </pre> <br><p>  If we want to show that the subsequence is optional, then we put a question mark after it: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1 2 3? 4" NEXT NAME 1 NEXT NAME 2 SPLIT L0 L1 L0: NEXT NAME 3 L1: NEXT NAME 4 MATCH</code> </pre> <br><p>  Of course, regular repeated expressions are also supported in regular expressions (plus or asterisk): </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1+ 2" L0: NEXT NAME 1 SPLIT L0 L1 L1: NEXT NAME 2 MATCH</code> </pre> <br><p>  Here we simply repeatedly execute the SPLIT instruction, launching new threads on each cycle. </p><br><p>  Similarly with an asterisk: </p><br><pre> <code class="plaintext hljs">&gt; python regexp/regexp.py "1* 2" L0: SPLIT L1 L2 L1: NEXT NAME 1 JUMP L0 L2: NEXT NAME 2 MATCH</code> </pre> <br><p><img src="https://habrastorage.org/webt/g-/ud/3s/g-ud3s00i4ccyhf4lp5huusjlyu.jpeg"></p><br><h1 id="perspektiva">  Perspective </h1><br><p>  Other extensions of the described virtual machine may be useful. </p><br><p>  For example, it can easily be extended by checking the attributes of events.  For a real system, I intend to use a syntax like ‚Äú1: 2 {3: 4, 5:&gt; 3}‚Äù, which means: event 1 in context 2 with attribute 3 having a value of 4 and attribute value 5 exceeding 3. Attributes here you can simply pass the array to the function matcher_accept. </p><br><p>  If you also pass the time interval between events to matcher_accept, then you can add a syntax to the template language that allows you to skip the time between events: "1 mindelta (120) 2", which means: event 1, then the interval of at least 120 seconds, event 2 In combination with the preservation of a subsequence, this allows you to collect information about user behavior between two subsequences of events. </p><br><p>  Other useful things that are relatively easy to add are: retaining regular expression subsequences, separating the "greedy" and ordinary asterisk and plus operators, and so on.  Our virtual machine in terms of the theory of automata is a non-deterministic finite-state machine, for the realization of which such things are easy to do. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  Our system is developed for fast user interfaces, so the session storage engine is self-written and optimized for all sessions.  All billions of events broken into sessions are checked for compliance with the patterns in seconds on a single server. </p><br><p>  If speed is not so critical for you, then a similar system can be arranged as an extension for some more standard data storage system like a traditional relational database or a distributed file system. </p><br><p>  By the way, in recent versions of <a href="">the SQL standard</a> , a feature similar to that described in the article has already appeared, and some databases ( <a href="https://docs.oracle.com/cd/E28280_01/apirefs.1111/e12048/pattern_recog.htm">Oracle</a> and <a href="https://www.vertica.com/docs/8.1.x/HTML/index.htm">Vertica</a> ) have already implemented it.  In turn, Yandex ClickHouse implements its own SQL-like language, but there are <a href="https://clickhouse.yandex/docs/ru/query_language/agg_functions/parametric_functions/">similar functions</a> there <a href="https://clickhouse.yandex/docs/ru/query_language/agg_functions/parametric_functions/">as well</a> . </p><br><p>  Aside from events and regular expressions, I want to repeat that the applicability of virtual machines is much broader than it might seem at first glance.  This technique is suitable and widely used in all cases when there is a need to clearly separate the primitives that the system's engine understands, and the ‚Äúfront‚Äù subsystem, that is, for example, some DSL or programming language. </p><br><p>  This concludes a series of articles on various applications of bytecode interpreters and virtual machines.  I hope, Habr's readers liked the series and, of course, I will be glad to answer any questions on the topic. </p><br><h1 id="neformalnyy-spisok-literatury">  Informal bibliography </h1><br><p>  Bytecode interpreters for programming languages ‚Äã‚Äãis a specific topic, and there is relatively little literature on them.  I personally liked the book <a href="https://www.amazon.co.uk/Virtual-Machines-Iain-D-Craig/dp/1852339691/">‚ÄúVirtual Machines‚Äù</a> by Ayan Craig, although it describes not so much the implementation of interpreters as the abstract machines ‚Äî the mathematical models that underlie various programming languages. </p><br><p>  In a broader sense, another book is devoted to virtual machines - <a href="https://www.amazon.co.uk/Virtual-Machines-Versatile-Platforms-Architecture/dp/1558609105/">‚ÄúVirtual Machines: Flexible Platforms for Systems and Processes‚Äù</a> (‚ÄúVirtual Machines: Versatile Platforms for Systems and Processes‚Äù).  This is an introduction to the various applications of virtualization, encompassing the virtualization of both languages, processes and computer architectures in general. </p><br><p>  Practical aspects of developing regular expression engines are rarely discussed in popular compiler literature.  The Pig Matcher and the example from the first article are based on ideas from the stunning <a href="https://swtch.com/~rsc/regexp/">series of articles by</a> Russ Cox, one of the developers of the Google RE2 engine. </p><br><p>  The theory of regular expressions is presented in all academic compiler textbooks.  It is customary to refer to the famous <a href="https://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811">"Book of the Dragon"</a> , but I would recommend to start with the above link. </p><br><p>  Working on an article, for the first time I used an interesting system for the rapid development of Python compilers <a href="https://github.com/true-grue/raddsl/">raddsl</a> , owned by the user of <a href="https://habr.com/users/true-grue/" class="user_link">true-grue</a> (thanks, Peter!).  If you are faced with the task of prototyping a language or quickly developing some DSL, you should pay attention to it. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/433054/">https://habr.com/ru/post/433054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../433042/index.html">Intel will release the processor with three-dimensional architecture Foveros in 2019</a></li>
<li><a href="../433044/index.html">OpenJDK source code contains too many expletives</a></li>
<li><a href="../433048/index.html">How 2019 will change Russian stores</a></li>
<li><a href="../433050/index.html">From aircraft to programmers in one year, or how to become a Jedi</a></li>
<li><a href="../433052/index.html">snap & flatpack - community tragedy</a></li>
<li><a href="../433056/index.html">Ministry of Communications will tighten the rules for software with elements of foreign origin</a></li>
<li><a href="../433058/index.html">Quintet as a basic entity for describing the subject area</a></li>
<li><a href="../433060/index.html">Why I do not believe microbench marks</a></li>
<li><a href="../433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Compare CCTV Cameras</a></li>
<li><a href="../433064/index.html">Incident management: ‚Äúgive away cannot be left‚Äù or the art of placing commas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>