<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Successful branching model for Git</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article by Vincent Driessen: A successful Git branching model 

 In this article, I present a development model that I use for all ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Successful branching model for Git</h1><div class="post__text post__text-html js-mediator-article">  <i>Translation of the article by Vincent Driessen: <a href="http://nvie.com/posts/a-successful-git-branching-model/">A successful Git branching model</a></i> <br><br>  In this article, I present a development model that I use for all my projects (both working and private) for a year, and which has shown itself to be a good one.  I was going to write about her for a long time, but still have not found free time.  I will not talk about all the details of the project, I will touch only the branching strategy and release management. <br><br><img src="https://habrastorage.org/storage/4bf7e68c/49e29c35/3a01bd6b/782a1be3.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a tool for managing the version of the entire source code, it uses <a href="http://git-scm.com/">Git</a> . <br><br><a name="habracut"></a><br><h4>  Why git? </h4><br>  For a full discussion of all the advantages and disadvantages of Git versus centralized version control systems, <a href="http://whygitisbetterthanx.com/">contact</a> <a href="http://www.looble.com/git-vs-svn-which-is-better/">the worldwide</a> <a href="http://git.or.cz/gitwiki/GitSvnComparsion">network</a> .  There you will find a sufficient amount of controversy on this topic.  Personally, as a developer, I currently prefer Git to all other tools.  Git really was able to change the attitude of developers towards merging and branching.  In the classic world, CVS / Subversion, from which I came, branching and merging are usually considered dangerous (‚Äúbeware of merge conflicts, they bite painfully!‚Äù) And therefore are held as little as possible. <br><br>  But with Git, these actions are extremely simple and cheap, and therefore, in fact, they become central elements of the usual <i>daily</i> workflow.  Just compare: in the CVS / Subversion <a href="http://svnbook.red-bean.com/">books</a> , branching and merging are usually covered in the last chapters (for advanced users), while in <a href="http://book.git-scm.com/">any</a> <a href="http://github.com/progit/progit">Git</a> <a href="http://pragprog.com/titles/tsgit/pragmatic-version-control-using-git">book</a> they are already mentioned for the third chapter (basics). <br><br>  Because of their simplicity and predictability, branching and merging are no longer actions to be feared.  Now versioning tools can help branch and merge more than any other. <br><br>  But stop talking about tools, let's move on to the development model.  The model I want to present is, in essence, just a set of procedures that each team member executes, so that everyone can achieve high controllability of the development process. <br><br><h4>  Decentralized but centralized </h4><br>  The proposed branch model is based on a project configuration that contains one central ‚Äútrue‚Äù repository.  Note that this repository is only <i>considered</i> central (since Git is DVCS, it does not have such a thing as a main repository at a technical level).  We will call this repository the term origin, since  This name is so familiar to all Git users. <br><br><img src="https://habrastorage.org/storage/0f1b4537/51094c28/85985dd2/1d1e8f1a.png"><br><br>  Each developer takes and publishes changes (pull &amp; push) to origin.  But, in addition to the centralized push-pull relationship, each developer can also pick up changes from the rest of the colleagues within his micro-team.  For example, this method may be convenient in a situation where two or more developers are working together on a great new feature, but cannot publish an unfinished work to origin ahead of time.  The picture above shows the subgroups of Alice and Bob, Alice and David, Claire and David. <br><br>  Technically, this is easy to implement: Alice creates a remote Git branch called bob that points to Bob‚Äôs repository, and Bob does the same with hers repository. <br><br><h4>  Main branches </h4><br><img align="right" src="https://habrastorage.org/storage/7dad2753/d8861db2/3ff3a29f/00eb029a.png"><br>  The core of the development model is no different from most existing models.  The central repository contains two main branches that exist all the time. <br><ul><li>  master </li><li>  develop </li></ul><br>  The master branch is created when the repository is initialized, which should be familiar to every Git user.  In parallel, we also create a branch for the development called develop. <br><br>  We consider origin / master as the main branch.  That is, the source code in it must be in a <i>production-ready</i> state at any arbitrary point in time. <br><br>  We consider the origin / develop branch as the main branch for development.  The code stored in it at any time should contain the most recent changes made necessary for the next release.  This branch can also be called "integration".  It serves as a source for building automatic night builds. <br><br>  When the source code in the develop branch reaches a stable state and is ready for release, all changes must be merged into the master branch in a certain way and tagged with the release number.  Below we look at this process in detail. <br><br>  Therefore, each time changes change into the master branch, we get a new release <i>by definition</i> .  We try to treat this rule very strictly, so, in principle, we could use Git hooks to automatically collect our products and upload them to the working servers at each commit to the master branch. <br><br><h4>  Auxiliary branches </h4><br>  In addition to the main master and develop branches, our development model contains a number of types of auxiliary branches, which are used to parallelize development between team members, to simplify the introduction of new features (features), to prepare releases and to quickly fix problems in the production version of the application.  Unlike the main branches, these branches always have a limited lifespan.  Each of them eventually ends sooner or later. <br><br>  We use the following types of branches: <br><ul><li>  Feature branches </li><li>  Release branches </li><li>  Fixes (Hotfix branches) </li></ul><br>  Each type of branch has its own specific purpose and strict set of rules, from which branches they can be generated, and which ones should be merged.  Now we consider them in turn. <br><br>  Of course, from a technical point of view, these branches have nothing ‚Äúspecific‚Äù.  The division of branches into categories exists only in terms of how they are used.  In all other respects, these are the good old branches of Git. <br><br><h5>  Feature branches </h5><br><img align="right" src="https://habrastorage.org/storage/3231978c/c6c3c3e9/5acee56c/968a9100.png"><br>  May originate from: develop <br>  Should be poured into: develop <br>  Naming convention: everything except master, develop, release- * or hotfix- * <br><br>  The branches of functionality (feature branches), also sometimes called thematic branches (topic branches), are used to develop new functions that should appear in current or future releases.  At the beginning of work on the functionality (features) it may still be unknown in which release it will be added.  The meaning of the existence of a branch of functionality (feature branch) is that it lives for as long as the development of this functionality (feature) continues.  When the work in the branch is completed, the latter is merged back into the main development branch (which means that the functionality will be added to the upcoming release) or deleted (in case of an unsuccessful experiment). <br><br>  The branches of functionality (feature branches) usually exist in the repositories of developers, but not in the main repository (origin). <br><br><h6>  Creating a branch of functionality (feature branch) </h6><br>  When starting work on a new functionality, a branch from the develop branch is developed. <br><br> <code>$ git checkout -b myfeature develop <br> Switched to a new branch "myfeature"</code> <br> <br><h6>  Adding completed functionality to develop </h6><br>  Completed functionality (feature) merges back into the develop branch (development) and falls into the next release. <br><br> <code>$ git checkout develop <br> Switched to branch 'develop' <br> $ git merge --no-ff myfeature <br> Updating ea1b82a..05e9557 <br> (  ) <br> $ git branch -d myfeature <br> Deleted branch myfeature (was 05e9557). <br> $ git push origin develop</code> <br> <br>  The --no-ff flag causes Git to always create a new commit object during a merge, even if the merge can be performed with the fast-forward algorithm.  This allows you to not lose the information that the branch existed, and groups together all the changes.  Compare: <br><br><img src="https://habrastorage.org/storage/a90013bb/4166845b/d7905ec1/572137b0.png"><br><br>  In the second case, it is impossible to see in the change history exactly which objects of the commits together form the functionality, for this you have to manually read all the messages in the commits.  Abolishing the entire functionality (i.e., a group of commits) is then impossible without a headache, and with the --no-ff flag this is done elementary. <br><br>  Of course, such an approach creates a certain additional amount of (empty) commit objects, but the benefit obtained more than justifies such a price. <br><br>  Unfortunately, I have not yet found how to configure Git so that --no-ff is the default behavior for merges.  But this method must be implemented. <br><br><h5>  Release branches </h5><br>  May originate from: develop <br>  Must join: develop and master <br>  Naming convention: release- * <br><br>  Release branches (release branches) are used to prepare for the release of new versions of the product.  They allow you to place the final points on i before the release of a new version.  In addition, they can add minor fixes, as well as prepare the metadata for the next release (version number, build date, etc.).  When all of this work is placed in the release branch, the main development branch (develop) is cleared to add further features (which will be included in the next big release). <br><br>  A new release branch should be spawned at the moment when the state of the development branch fully or almost fully meets the requirements of the new release.  At least, all the necessary functionality intended for this release is already injected into the develop branch.  The functionality intended for the following releases may not be infused.  It is even better if the branches for these functionalities wait until the current release branch spans off from the develop branch. <br><br>  The next release gets its version number only at the moment when a new branch is created for it, but by no means earlier.  Up to this point, the development branch contains changes for the ‚Äúnew release‚Äù, but until the release branch is separated, it is not known whether this release will have version 0.3, or 1.0, or some other.  The decision is made when creating a new release branch and depends on the rules adopted in the draft for numbering versions of the project. <br><br><h6>  Creating a release branch </h6><br>  The release branch is created from the develop branch.  Let, for example, the current released release has version 1.1.5, and on the way a new big release, full of changes.  The development branch (develop) is ready for the ‚Äúnext release‚Äù, and we decide that this release will be version 1.2 (and not 1.1.6 or 2.0).  In this case, we create a new branch and give it a name corresponding to the new version of the project: <br><br> <code>$ git checkout -b release-1.2 develop <br> Switched to a new branch "release-1.2" <br> $ ./bump-version.sh 1.2 <br> Files modified successfully, version bumped to 1.2. <br> $ git commit -a -m "Bumped version number to 1.2" <br> [release-1.2 74d9424] Bumped version number to 1.2 <br> 1 files changed, 1 insertions(+), 1 deletions(-)</code> <br> <br>  We created a new branch, switched to it, and then set the version number (bump version number).  In our example, bump-version.sh is a fictional script that modifies some of the files in the working copy by writing a new version to them.  (Of course, these changes can be made manually; I just draw your attention to the fact that <i>some</i> files are changed.) Then we make a commit with the indication of the new version of the project. <br><br>  This new branch may exist for some time, until the new release is finally ready for release.  During this time, corrections of found bugs can be added to this branch (and not to develop).  But adding major new changes to this branch is strictly prohibited.  They should always join the development branch (develop) and wait for the next big release. <br><br><h6>  Release branch closure </h6><br>  When we decide that the release branch is finally ready for release, we need to do a few things.  First of all, the release branch merges into the main branch (I remind you, every commit to master is, <i>by definition, a</i> new release).  Further, this commit in master should be tagged so that you can easily access any existing version of the product in the future.  Finally, changes made to the release branch must be added back to the development (the develop branch) so that future releases also contain bug fixes. <br><br>  The first two steps in git: <br><br> <code>$ git checkout master <br> Switched to branch 'master' <br> $ git merge --no-ff release-1.2 <br> Merge made by recursive. <br> (  ) <br> $ git tag -a 1.2</code> <br> <br>  Now the release is published and tagged. <br><br>  <b>Note</b> : if you wish, you can also use the -s or -u &lt;key&gt; flags to sign the tag cryptographically. <br><br>  To save changes in subsequent releases, we need to put these changes back into development.  We do it like this: <br><br> <code>$ git checkout develop <br> Switched to branch 'develop' <br> $ git merge --no-ff release-1.2 <br> Merge made by recursive. <br> (  )</code> <br> <br>  This step, in principle, can lead to a merge conflict (it often happens that the cause of a conflict is a change in the version number of the project).  If this happens, correct them and make a commit. <br><br>  Now we have finally finished with the release branch.  You can delete it because we no longer need it: <br><br> <code>$ git branch -d release-1.2 <br> Deleted branch release-1.2 (was ff452fe).</code> <br> <br><h5>  Hotfix Branches </h5><br><img align="right" src="https://habrastorage.org/storage/a303d38c/6c9c561c/8bcc22f7/3f8cbad4.png"><br>  May be generated by: master <br>  Must join: develop and master <br>  Naming convention: hotfix- * <br><br>  Hotfix branches are very similar to release branches, as they are also used to prepare new product releases, unless they are unplanned.  They are caused by the need to immediately correct unwanted behavior of the production version of the product.  When there is a bug in the production version that requires immediate correction, a new branch is generated from the corresponding master tag tag (master) to work on the fix. <br><br>  The meaning of its existence is that the team‚Äôs work on the develop branch can continue quietly, while one prepares a quick fix for the production version. <br><br><h6>  Create hotfix branch </h6><br><br>  Hotfix branches are created from the master branch.  Let, for example, the current production release has version 1.2, and in it (suddenly!) A serious bug is detected.  A change in the development branch (develop) is still not stable enough to publish them in a new release.  But we can create a new branch of fixes and start working on solving the problem: <br><br> <code>$ git checkout -b hotfix-1.2.1 master <br> Switched to a new branch "hotfix-1.2.1" <br> $ ./bump-version.sh 1.2.1 <br> Files modified successfully, version bumped to 1.2.1. <br> $ git commit -a -m "Bumped version number to 1.2.1" <br> [hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1 <br> 1 files changed, 1 insertions(+), 1 deletions(-)</code> <br> <br>  Do not forget to update the version number after creating a branch! <br><br>  Now you can fix the bug, and publish the changes with at least one commit or at least a few. <br><br> <code>$ git commit -m "Fixed severe production problem" <br> [hotfix-1.2.1 abbe5d6] Fixed severe production problem <br> 5 files changed, 32 insertions(+), 17 deletions(-)</code> <br> <br><h6>  Close the patch branch </h6><br>  When the bug is fixed, the changes need to be poured back into the main branch (master), as well as into the development branch (develop), to ensure that this fix will be in the next release.  This is very similar to how a release branch closes. <br><br>  First of all, you need to update the main branch (master) and mark the new version with a tag. <br><br> <code>$ git checkout master <br> Switched to branch 'master' <br> $ git merge --no-ff hotfix-1.2.1 <br> Merge made by recursive. <br> (  ) <br> $ git tag -a 1.2.1</code> <br> <br>  <b>Note</b> : if you wish, you can also use the -s or -u &lt;key&gt; flags to cryptographically sign the tag. <br><br>  The next step is to transfer the fix to the develop branch. <br><br> <code>$ git checkout develop <br> Switched to branch 'develop' <br> $ git merge --no-ff hotfix-1.2.1 <br> Merge made by recursive. <br> (  )</code> <br> <br>  There is one exception to this rule: <b>if there is a release branch at the moment, the hotfix branch should be merged into it, not the develop branch</b> .  In this case, the fixes will be included in the development branch along with the entire release branch when it is closed.  (Although, if work in develop requires an immediate correction of the bug and cannot wait until the current release is completed, you can still pour fixes (bugfix) into the develop branch, and it will be completely safe). <br><br>  Finally, delete the temporary branch: <br><br> <code>$ git branch -d hotfix-1.2.1 <br> Deleted branch hotfix-1.2.1 (was abbe5d6).</code> <br> <br><h4>  Conclusion </h4><br>  Although there is absolutely nothing fundamentally new in this branching model, the ‚Äúbig picture‚Äù that this article begins with has proven itself in our projects from the very best side.  It forms an elegant mental model that is easy to fully cover with one glance, and which allows the team to form a joint understanding of the branching and merging processes that are involved in the project. <br><br>  A high-quality PDF version of this picture is free for download <a href="http://github.com/downloads/nvie/gitflow/Git-branching-model.pdf">here</a> .  Print it out and hang it on your wall so that you can access it at any time. <br><br>  <i><b>Note</b></i>  <i><b>translator: the</b> article is not new, the link to the original <a href="http://habrahabr.ru/blogs/development_tools/104993/">has already appeared on the site</a> .</i>  <i>This translation is for those to whom English is still not so easy (as well as for my colleagues, among whom I do propaganda, hehe).</i>  <i>To automate the procedures described in this article, the author has created a gitflow project, <a href="http://github.com/nvie/gitflow">which can be found on github</a> .</i> </div><p>Source: <a href="https://habr.com/ru/post/106912/">https://habr.com/ru/post/106912/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../106902/index.html">Opened two new Russian Wikipedia</a></li>
<li><a href="../106904/index.html">Google set a new record for web traffic</a></li>
<li><a href="../106905/index.html">Not a single plan</a></li>
<li><a href="../106906/index.html">PenguSpy will help you choose a game for Linux</a></li>
<li><a href="../106911/index.html">Intel office :: 2</a></li>
<li><a href="../106913/index.html">Extensions for Opera: Windows</a></li>
<li><a href="../106916/index.html">What version control systems do you use? (In real work. Poll for the conference).</a></li>
<li><a href="../106917/index.html">New Google FeedBurner interface</a></li>
<li><a href="../106918/index.html">Obama signed Aypad with his finger</a></li>
<li><a href="../106919/index.html">MINSK / Belarus (Minsk / Belarus) Motion TimeLapse</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>