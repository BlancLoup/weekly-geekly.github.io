<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Designing a news feed in social networks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It so happened that over the past couple of years I managed to participate in the development of several social networks. The main task that had to be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Designing a news feed in social networks</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/04b/58b/804/04b58b8049ce4e1db470d07c140668a2.png"><br><br>  It so happened that over the past couple of years I managed to participate in the development of several social networks.  The main task that had to be addressed in each of these projects was to form the user's news feed.  With that, an important condition was the possibility of scaling this tape in the conditions of growing number of users (more precisely, the number of links between them) and, as a result, the amount of content that they divide each other. <br><br>  My story will be about how, <a href="">overcoming difficulties</a> , I solved the problem of forming a news feed.  And also I will talk about the approaches that the guys from the <a href="https://github.com/10gen-labs/socialite">Socialite</a> project have developed, and which they shared on <a href="https://www.mongodb.com/presentations/socialite-open-source-status-feed-part-3-scaling-data-feed">MongoDB World</a> . <br><a name="habracut"></a><br><h1>  How to shape the tape? </h1><br>  So, for a start, absolutely banal information that any news feed is formed from the activity of users with whom we are friends (or which we follow / read / etc).  Consequently, the task of forming a tape is the task of delivering content from the author to his followers.  The tape, as a rule, consists of completely heterogeneous content: seals, cubs, comedic videos, some text statuses and other things.  On top of this, we have reposts, comments, likes, user tagging on these most statuses / photos / videos.  Consequently, the main tasks that arise for developers of a social network are: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. Aggregation of all activity, all content posted by users.  Call it conditionally a <i>content service</i> .  In the post-Halloween picture above, it is depicted as a boiling magic cauldron that digests and aggregates all sorts of different objects into a collection of more or less homogeneous documents. <br><br>  2. Delivery of user content to his followers.  Let's entrust this process to <i>the tape service</i> , which is represented by cones.  Thus, when the user wants to read his tape, he goes to his personal cone, takes it, goes to the pot with it, and we pour him the necessary piece of content. <br><br>  It seems to be nowhere easier.  Let's take a closer look at the approaches to the implementation of the formation of a personalized news feed (in other words, the delivery of content from the author to his readers).  I guarantee you a couple of interesting difficulties. <br><br><h1>  We form a tape when reading </h1><br>  This approach involves tape formation on the fly.  Those.  when a user requests his news feed, we pull the records of people the user has subscribed to from our content service, sort them by time and get a news feed.  Here, in general, that's all.  I think this is the most obvious and intuitive approach.  On the diagram, it looks like this: <br><br><img src="https://habrastorage.org/files/5b7/f0d/81e/5b7f0d81ecf6486d8cf1d977e5e2d591.jpg"><br><br>  When a user posts something new, the process is absolutely trivial: you only need to make one entry to the content service.  This simplicity is not surprising, since  tape delivery goes when reading, which means all the most interesting is there. <br><br>  OK, proceed to reading the tape.  To form a tape for a specific user, you need to take a list of people to whom it is subscribed.  With this list, we go to the content service and pull out the posts of these people.  Of course, it is not necessary to take straight all-all records, as a rule, it is possible to take some part of this, necessary for the formation of the beginning of the tape or the next part of it.  But in any case, the size of the received data will be much larger than what we will eventually return to the user.  This is due to the fact that the activity of our friends is completely uneven and we do not know in advance how many posts we need to take from each of them in order to show the necessary part of the tape. <br><br>  But this is not the biggest problem of this approach.  Obviously, as the network grows, the content collection will grow faster than the rest.  And sooner or later there will come the need to shard this collection.  And, naturally, sharding will occur by content authors (for example, by their ID).  So, the biggest disadvantage of this approach is that our request will affect a very large number of arbitrary shards.  If you certainly do not follow one person. <br><br>  Let's now summarize the results on the delivery of Lena for reading. <br><br>  <b>Of the benefits:</b> <br><ul><li>  Ease of implementation.  That is why this approach is good to use "by default."  For example, in order to quickly make a working demo, Proof on Concept, etc. </li><li>  No need for additional storage for copies of content from followers. </li></ul><br>  <b>Now for the cons:</b> <br><ul><li>  Reading the tape affects many shards, which will no doubt affect the speed of such a sample. </li><li>  And this, most likely, will pull the need for additional indexing. </li><li>  The need to choose content with "stock". </li></ul><br><br><h1>  We form a tape when writing </h1><br>  Let's get to the problem a bit from the other side.  What if for each user to keep a ready-made news feed and update it every time his friends post something new?  In other words, we will make a copy of each post of the author in the "materialized" tape of his subscribers.  This approach is a little less obvious, but there is nothing beyond it.  The most important thing in it is to find the optimal storage model for this very ‚Äúmaterialized‚Äù tape for each user. <br><br><img src="https://habrastorage.org/files/344/855/668/344855668c11447f9b86e6f462badfca.jpg"><br><br>  And so, what happens when a user posts something new?  As in the previous case, the post is sent to the content service.  But now we additionally make a copy of the post in the tape of each subscriber (in fact, in this picture, the arrows going to the service tape should start not from the author's post, but from the content service).  Thus, for each user, personalized tapes are ready for reading.  It is also very important that when sharding data from the tape service, the IDs of the subscribers will be used, not of the authors (as is the case with the content service).  Accordingly, now we will read the tape from one shard and this will give a significant acceleration. <br><br>  At first glance it may seem that creating copies of the post for each subscriber (especially if there are tens of thousands of them) can turn out to be very slow.  But after all, we are developing a live chat, so it‚Äôs not at all scary if the cloning process takes even a few minutes.  After all, we can do all this work asynchronously, in contrast to reading.  Those.  the user does not have to wait until his record is duplicated in the tape of each subscriber. <br><br>  There is one more, far more tangible flaw - the need to store all of our "materialized" tapes somewhere.  Those.  This is the need for additional cost.  And if a user has 15.000 followers, this means that all his content will be permanently stored in 15.000 thousand copies.  And it does not look cool at all. <br><br>  And briefly about the advantages and disadvantages. <br><br>  <b>Of the benefits:</b> <br><ul><li>  The tape is formed by reading one or more documents.  The number of documents will depend on the selected tape storage model, about a little later. </li><li>  It is easy to exclude inactive users from the process of pre-creating tapes. </li></ul><br>  <b>About cons:</b> <br><ul><li>  Delivery of copies to a large number of subscribers can take quite a long time. </li><li>  The need for additional storage for ‚Äúmaterialized‚Äù tapes. </li></ul><br><br><h1>  Storage models "materialized" tapes </h1>  As you can guess, we will not put up with problems just like that, especially since the scrolling is still only in the middle of the article :-) And here we are come to the aid of the guys from MongoDB Labs, who have developed as many as 3 storage models of ‚Äúmaterialized‚Äù tapes.  Each of these models somehow solves the shortcomings described above. <br><br>  Looking a little ahead, I will say that the first two models assume the storage of a personalized tape for the entire period of its existence.  Those.  With these two approaches, we store absolutely all the records that have ever been in the tape.  Thus, the first two approaches, unlike the third, do not solve the problem of data ‚Äúswelling‚Äù.  But, on the other hand, they allow very quickly to give the user not only the top of the tape, but all its subsequent parts, right up to the very end.  Of course, users rarely scroll the tape to the bottom, but it all depends on the specific project and requirements. <br><br><h4>  Grouped by time </h4><br>  This model implies that all posts in the tape for a certain time interval (hour / day / etc.), Are grouped in one document.  Such a document guys from MongoDB Labs called "baket".  In our post-Halloween style, they are depicted by cones: <br><br><img src="https://habrastorage.org/files/e41/b8c/e32/e41b8ce325854ea4b16555427fa17e87.jpg" width="600"><br><div class="spoiler">  <b class="spoiler_title">Example with MongoDB Documents</b> <div class="spoiler_text"><pre><code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"_id"</span></span>: {<span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"time"</span></span>: <span class="hljs-number"><span class="hljs-number">516935</span></span>}, <span class="hljs-string"><span class="hljs-string">"timeline"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...dc1"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"masha"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"How are you?"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...dd2"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"petya"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"Let's go drinking!"</span></span>} ] }, { <span class="hljs-string"><span class="hljs-string">"_id"</span></span>: {<span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"petya"</span></span>, <span class="hljs-string"><span class="hljs-string">"time"</span></span>: <span class="hljs-number"><span class="hljs-number">516934</span></span>}, <span class="hljs-string"><span class="hljs-string">"timeline"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...dc1"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"dimon"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"My name is Dimon."</span></span>} ] }, { <span class="hljs-string"><span class="hljs-string">"_id"</span></span>: {<span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"time"</span></span>: <span class="hljs-number"><span class="hljs-number">516934</span></span>}, <span class="hljs-string"><span class="hljs-string">"timeline"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...da7"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"masha"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hi, Vasya!"</span></span>} ] }</code> </pre> <br></div></div><br><br>  All we do is round off the current time (for example, take the start of each hour / day), take the follower ID, and write up each new post with upsert to your bake.  Thus, all posts for a certain time interval will be grouped for each subscriber in one document. <br><br>  If last day the people you have subscribed to have written 23 posts, then there will be exactly 23 entries in your user's yesterday‚Äôs bucket.  If, for example, in the last 10 days there have been no new posts, then new buckets will not be created.  So in certain cases, this approach will be very convenient. <br><br>  The main drawback of the model is that the buckets being created will be of unpredictable size.  For example, on Friday everyone will post Friday koubas, and you will have several hundred entries in the bucket.  And the next day everyone is asleep, and there will be 1-2 entries in your Saturday's bakery.  This is bad because you do not know how many documents you need to read in order to form the necessary part of the tape (even the beginning).  And you can also tritely exceed the maximum document size of 16Mb. <br><br><h4>  Grouped by size </h4><br>  If the unpredictability of the size of buckets is critical for your project, then you need to form buckets by the number of entries in them. <br><br><img src="https://habrastorage.org/files/948/555/e41/948555e414ba4880ba8099ccf1fdb6d4.jpg" width="600"><br><div class="spoiler">  <b class="spoiler_title">Example with MongoDB Documents</b> <div class="spoiler_text"><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...122"</span></span>), <span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"timeline"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...dc1"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"masha"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"How are you?"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...dd2"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"petya"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"Let's go drinking!"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...da7"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"petya"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hi, Vasya!"</span></span>} ] }, { <span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...011"</span></span>), <span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"petya"</span></span>, <span class="hljs-string"><span class="hljs-string">"size"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"timeline"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...dc1"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"dimon"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"My name is Dimon."</span></span>} ] }</code> </pre><br></div></div><br><br>  I will give an example.  Set a limit on the bake in 50 entries.  Then we write the first 50 posts to the first user bakt.  When the turn of the 51st post comes, we create a second bakt for the same user, and we write there this and the next 50 posts.  And so on.  In this simple way we solved the problem with an unstable and unpredictable size.  But this model works on recording about 2 times slower than the previous one.  This is due to the fact that when recording each new post, it is necessary to check whether we have reached the established limit or not.  And if achieved, then create a new baket and write in it already. <br><br>  So, on the one hand, this approach solves the problems of the previous one, and on the other, creates new ones.  Therefore, the choice of model will depend on the specific requirements for your system. <br><br><h4>  Cache the top </h4><br>  And finally, the latest tape storage model, which should solve all the accumulated problems.  Or at least balance them. <br><br><img src="https://habrastorage.org/files/c15/711/b03/c15711b03bb042fd8a321e0c103d7dfe.jpg" width="600"><br><div class="spoiler">  <b class="spoiler_title">Example with MongoDB Documents</b> <div class="spoiler_text"><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"vasya"</span></span>, <span class="hljs-string"><span class="hljs-string">"timeline"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...dc1"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"masha"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"How are you?"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...dd2"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"petya"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"Let's go drinking!"</span></span>}, {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...da7"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"petya"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"Hi, Vasya!"</span></span>} ] }, { <span class="hljs-string"><span class="hljs-string">"user"</span></span>: <span class="hljs-string"><span class="hljs-string">"petya"</span></span>, <span class="hljs-string"><span class="hljs-string">"timeline"</span></span>: [ {<span class="hljs-string"><span class="hljs-string">"_id"</span></span>: ObjectId(<span class="hljs-string"><span class="hljs-string">"...dc1"</span></span>), <span class="hljs-string"><span class="hljs-string">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"dimon"</span></span>, <span class="hljs-string"><span class="hljs-string">"post"</span></span>: <span class="hljs-string"><span class="hljs-string">"My name is Dimon."</span></span>} ] }</code> </pre><br></div></div><br><br>  The main idea of ‚Äã‚Äãthis model is that we cache a number of recent posts, rather than storing the entire history.  Those.  in essence, the bake will be a capped-array, storing a number of entries.  In MongoDB (since version 2.4) this is done very simply using the $ push and $ slice operators. <br><br>  There are several advantages to this approach.  First, we need to update only one document.  What does this update will be very fast, because  there are no checks in it, unlike the previous model.  Secondly, to get the tape, we need to read again just one document. <br><br>  Further.  If the user does not enter our service for a long time, then we can simply delete his cache.  Thus, we will exclude inactive users from the process of creating ‚Äúmaterialized‚Äù tapes, freeing the resources of our servers.  If an inactive user suddenly decides to return, say in a year, we can easily create a new cache for him.  You can fill it with current posts using the fallback in a simple delivery for reading. <br><br>  Thus, this model is an excellent balance between storing the entire tape for each user and building this tape for each request. <br><br><h4>  Embedding vs Linking </h4><br>  And one more important point regarding the storage of the tape in the cache: to store the content of posts or just a link? <br><br>  The approach with the storage of a full copy of posts right in the bucket will be good if the content of the posts is small and importantly known size.  A perfect example is Twitter with its 140-character status. <br><br>  In the general case, the second approach wins when we store the post ID and, possibly, some meta-data (for example, the author's ID, publication date, etc.).  Content is drawn only when necessary.  Moreover, having a post ID can be done very easily and quickly. <br><br><h1>  What if I'm very lazy? </h1><br>  In the 21st century, there are approximately 100,500 applications for each laziness for every bummer.  Accordingly, for each developer, there are slightly less than 100,500 services.  A cool ribbon management service lives <a href="https://getstream.io/">here</a> . <br><br>  I have it all.  I just want to say that a silver bullet for solving all the problems of forming a news feed was not expected.  But we looked at a whole bunch of solutions and approaches, each of which would work well in their particular situation. </div><p>Source: <a href="https://habr.com/ru/post/242593/">https://habr.com/ru/post/242593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242581/index.html">New malware for iOS can infect devices without jailbreak</a></li>
<li><a href="../242585/index.html">Features of the Android TV box with multicast broadcasting</a></li>
<li><a href="../242587/index.html">New version of Veeam Backup & Replication v8 (paid and free editions)</a></li>
<li><a href="../242589/index.html">4SICS Conference: Vulnerable Collider, Havex Trojan, and Other ‚ÄúRussian Threats‚Äù</a></li>
<li><a href="../242591/index.html">Stun gun in section: 3.000.000 volts for educational purposes</a></li>
<li><a href="../242595/index.html">Megatons of waste paper with a flick of the wrist</a></li>
<li><a href="../242601/index.html">Immersion cooling, underwater servers: Immersion-2 for 3M ‚Ñ¢ Novec ‚Ñ¢ delivers magical results, put into practice in Hong Kong</a></li>
<li><a href="../242603/index.html">Cryptographic solutions. From the cloud signature to the trusted environment</a></li>
<li><a href="../242609/index.html">Expressive javascript: search and error handling</a></li>
<li><a href="../242611/index.html">Career project manager vs organization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>