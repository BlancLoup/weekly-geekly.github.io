<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tail recursion in C ++ using 64-bit variables - Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This time I want to share with you one problem I encountered when I decided to compare iterative and recursive functions in C ++. There are several di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tail recursion in C ++ using 64-bit variables - Part 1</h1><div class="post__text post__text-html js-mediator-article">  This time I want to share with you one problem I encountered when I decided to compare iterative and recursive functions in C ++.  There are several differences between recursion and iteration: they are described in detail in this <a href="http://www.viva64.com/go.php%3Furl%3D1593">article</a> .  In general purpose languages ‚Äã‚Äãlike Java, C, or Python, recursion is quite expensive compared to iteration because of the need to allocate a new stack frame each time.  In C / C ++, these costs can be easily eliminated by telling the optimizing compiler to use tail recursion, in which certain types of recursion (or rather, certain types of tail calls) are converted into unconditional branch instructions.  To perform such a conversion, it is necessary that the most recent action of the function before returning the value is a call to another function (in this case itself).  In this scenario, the unconditional jump to the beginning of the second subprogram is safe.  The main drawback of recursive algorithms in imperative languages ‚Äã‚Äãis that it is not always possible to have tail calls in them, i.e.  allocating space for the address of a function (and its associated variables, for example, structures) on the stack for each call.  If the recursion depth is too large, this can lead to a stack overflow due to the limit on its maximum size, which is usually orders of magnitude smaller than the amount of RAM. <br><a name="habracut"></a><br>  As a test for studying tail recursion, I wrote in Visual Studio a simple Fibonacci function in C ++.  Let's see how it works: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib_tail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> res, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fib_tail(n - <span class="hljs-number"><span class="hljs-number">1</span></span>, next, res + next); }</code> </pre> <br>  To get a tail call before returning a value, the <i>fib_tail</i> function calls itself as the last action.  Let's now take a look at the generated assembler code.  To do this, I compiled the program in release mode using the optimization / O2 key.  This is what this code looks like: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6ca/c0b/858/6cac0b858f9b1b0606eac407a2dcd28d.png" alt="Picture 1"><br><br>  There is!  Notice the last line: <i>JMP is</i> used instead of the <i>CALL</i> instruction.  In this case, tail recursion worked, and our function will not have any problems with stack overflow, since at the assembler level it turned into an iterative function. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This was not enough for me, and I decided to experiment with performance by increasing the input variable <i>n</i> .  Then I changed the type of variables used in the function from <i>int</i> to <i>unsigned</i> <i>long</i> <i>long</i> .  By running the program again, I suddenly got a stack overflow!  This is how this version of our function looks like: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> ULONG64; <span class="hljs-function"><span class="hljs-function">ULONG64 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib_tail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ULONG64 n, ULONG64 res, ULONG64 next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fib_tail(n - <span class="hljs-number"><span class="hljs-number">1</span></span>, next, res + next); }</code> </pre> <br>  Let's look again at the generated assembly code: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/424/8d4/279/4248d42798102cc17c7cc2b58b1d5fde.png" alt="Picture 2"><br><br>  As I expected, tail recursion was not here!  Now, instead of the expected <i>JMP</i> used <i>CALL</i> .  Meanwhile, the only difference between the two variants of our function is that in the second case I used a 64-bit variable instead of a 32-bit variable.  In this connection, the question arises: why does the compiler not use tail recursion when using 64-bit variables? <br><br>  I decided to compile the program in 64-bit mode and see how it behaves.  Generated assembly code: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ca/59d/861/1ca59d86117c80cabaa843d42624a1a3.png" alt="Picture 3"><br><br>  Here the tail recursion appeared again!  Thanks to 64-bit registers (rax, r8, rcx, rdx), the calling and called functions have a common stack, and the called function returns the result directly to the call point inside the calling function. <br><br>  I asked my question on <a href="http://www.viva64.com/go.php%3Furl%3D1594">StackOverflow</a> - it seems that the problem is in the Microsoft C ++ compiler itself.  The author of one of the comments said that this problem is not observed in other C ++ compilers, but I have to make sure of this myself. <br><br>  I posted sample code on <a href="http://www.viva64.com/go.php%3Furl%3D1595">GitHub</a> - you can copy it and try to run it.  On <a href="http://www.viva64.com/go.php%3Furl%3D1596">Reddit</a> and Stackoverflow, I was also told that in the VS2013 Community Edition, this problem does not occur.  I tried to work in VS2013 Ultimate, but I ran into it there.  Over the next few days I will try to test the code under GCC and compare the results. <br><br>  See the Example project on <a href="http://www.viva64.com/go.php%3Furl%3D1595">GitHub</a> . <br><br>  I hope that my investigation will be useful for you, if you suddenly happen to understand why the compiler does not implement tail recursion in certain cases. <br><br>  See you soon! <br><br>  <b>Continued: <a href="http://habrahabr.ru/company/pvs-studio/blog/261029/">habrahabr.ru/company/pvs-studio/blog/261029</a></b> </div><p>Source: <a href="https://habr.com/ru/post/261027/">https://habr.com/ru/post/261027/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261011/index.html">About interviews (by Eric Lippert)</a></li>
<li><a href="../261013/index.html">Adobe fixed critical flash player vulnerability</a></li>
<li><a href="../261017/index.html">Unity 5 uNet is a new network subsystem. Study on authoritarian architecture</a></li>
<li><a href="../261019/index.html">The importance of controlling the output of the serializing API</a></li>
<li><a href="../261023/index.html">Create a simple UI5 ‚Äã‚Äãapplication in a web development environment</a></li>
<li><a href="../261029/index.html">Tail recursion in C ++ using 64-bit variables - Part 2</a></li>
<li><a href="../261031/index.html">Reactive extensions</a></li>
<li><a href="../261033/index.html">Turing's Cathedral: the origin of the digital universe</a></li>
<li><a href="../261035/index.html">MiTM Mobile Contest: How Mobile Phone Broke on PHDays V</a></li>
<li><a href="../261039/index.html">Inside the antivirus for Virusday sites - Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>