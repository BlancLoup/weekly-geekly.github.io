<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>My planet Earth</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone who reads this! I want to tell you how to draw such a globe using the OpenGL library. 
 Here I will not dwell on the creation of a wind...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>My planet Earth</h1><div class="post__text post__text-html js-mediator-article"><img width="400" height="272" src="https://habrastorage.org/getpro/geektimes/post_images/865/ac2/6b5/865ac26b5d460de627ccda3398ae5b5a.png"><br><br>  Hello everyone who reads this!  I want to tell you how to draw such a globe using the OpenGL library. <br>  Here I will not dwell on the creation of a window and a display device context, since  with this is beyond the scope of this narrative. <br><a name="habracut"></a><br><h4>  BASED ON SPHERE </h4><br>  First, you need to build a geometric frame, which will be a sphere. <br><img width="147" height="147" src="https://habrastorage.org/getpro/geektimes/post_images/ca8/76e/8c4/ca876e8c4fb19784a05125cd9fddf8bb.png"><br>  There is nothing difficult to open any textbook on geometry and find a parametric equation of a sphere there.  It is written like this: <br><br><img height="74" src="https://habrastorage.org/getpro/geektimes/comment_images/d0c/25f/96b/d0c25f96b9f2dac329b80e4be6647601.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Using this equation, you can calculate the vertices for constructing the framework.  At once I will make a reservation that for visualization of the framework I used the mechanism of vertex arrays, which allows to reduce the number of calls to the display functions of polygons to one.  This reduction will help to significantly increase the speed of visualization. <br>  Something else.  Vertices have a peculiarity: vertices can belong to different polygons.  But in order not to store it separately for each polygon, they decided to store the indices of these vertices.  In this particular case, the indices are calculated based on the fact that polygons will be drawn using the following order of vertices: <br><br><img width="182" height="140" src="https://habrastorage.org/getpro/geektimes/post_images/844/c17/972/844c1797257cbd664c7148818959e07f.png"><br><br>  In <i>OpenGL,</i> this order corresponds to the constant <i>GL_QUAD_STRIP</i> , which is used in the display functions. <br><br>  Now programming.  First, you need to calculate the number of vertices and the number of indices. <br><br><blockquote><code><font color="black">numberOfVertices = ((180 / step) + 1) * ((360 / step) + 1) <br> numberOfIndices = 2 * (numberOfVertices - (360 / step) - 1)</font></code> </blockquote> <br>  where <i>step is the</i> interpolation step between two points.  I took 8 degrees (or 0.14 radians). <br><br>  Next, we declare an array of vertices and an array of indices: <br><br><blockquote> <code><font color="black"><font color="#0000FF">class</font> CScene { <br> <font color="#0000FF">private</font> : <br> <br> <font color="#0000FF">enum</font> { <br> step = 8, <br> numberOfVertices = ((180 / step) + 1) * ((360 / step) + 1), <br> numberOfIndices  = 2 * (numberOfVertices - (360 / step) - 1) <br> }; <font color="#008000"><i>// enum</i></font> <br> <br> <font color="#0000FF">struct</font> { <br> GLfloat x,y,z; <font color="#008000"><i>//  </i></font> <br> } m_vertices[numberOfVertices]; <font color="#008000"><i>//  </i></font> <br> <br> GLuint m_indices[numberOfIndices]; <font color="#008000"><i>//  </i></font> <br> <br> ... <br> <br> }; <font color="#008000"><i>// class CScene</i></font></font></code> </blockquote> <br>  And here is the code in which the values ‚Äã‚Äãof these arrays are calculated. <br><br><blockquote> <code><font color="black">CScene::CScene( <font color="#0000FF">void</font> ) { <br> <font color="#008000"><i>///        </i></font> <br> <font color="#0000FF">const</font> GLfloat fRadius = 1.0; <br> <br> <font color="#0000FF">for</font> ( <font color="#0000FF">int</font> alpha = 90, index = 0; alpha &lt;= 270; alpha += step) { <br> <font color="#0000FF">const int</font> angleOfVertical = alpha % 360; <br> <br> <font color="#0000FF">for</font> ( <font color="#0000FF">int</font> phi = 0; phi &lt;= 360; phi += step, ++index) { <br> <font color="#0000FF">const int</font> angleOfHorizontal = phi % 360; <br> <br> <font color="#008000"><i>///   </i></font> <br> m_vertices[index].x = fRadius * g_tableOfCosines[angleOfVertical] * g_tableOfCosines[angleOfHorizontal]; <br> m_vertices[index].y = fRadius * g_tableOfSinus[angleOfVertical]; <br> m_vertices[index].z = fRadius * g_tableOfCosines[angleOfVertical] * g_tableOfSinus[angleOfHorizontal]; <br> } <font color="#008000"><i>// for</i></font> <br> } <font color="#008000"><i>// for</i></font> <br> <br> <font color="#008000"><i>///        </i></font> <br> <font color="#0000FF">for</font> ( <font color="#0000FF">int</font> index = 0; index &lt; numberOfIndices; index += 2) { <br> m_indices[index] = index &gt;&gt; 1; <br> m_indices[index + 1] = m_indices[index] + (360 / step) + 1; <br> } <font color="#008000"><i>// for</i></font> <br> } <font color="#008000"><i>// constructor CScene</i></font></font></code> </blockquote> <br>  Note that instead of the <i>cos</i> and <i>sin</i> functions, the <i>g_tableOfCosines</i> and <i>g_tableOfSinus</i> tables are used, in which the cosine and sine values ‚Äã‚Äãare pre-recorded.  This is done to increase the speed of computing vertices.  Instead of using the slow <i>cos</i> and <i>sin</i> functions each time, the ready-made values ‚Äã‚Äãare used. <br><br>  Before you start rendering, you must pass the data of the vertex arrays in <i>OpenGL</i> .  The following function will be used for this: <br><br><blockquote> <code><font color="black"><font color="#0000FF">inline void</font> CScene::InitArrays( <font color="#0000FF">void</font> ) { <br> <font color="#0000FF">const</font> GLsizei stride = 3 * <font color="#0000FF">sizeof</font> (GLfloat); <br> <br> glEnableClientState(GL_VERTEX_ARRAY); <br> glVertexPointer(3, GL_FLOAT, stride, m_vertices); <br> <br> glEnableClientState(GL_NORMAL_ARRAY); <br> glNormalPointer(GL_FLOAT, stride, m_vertices); <br> } <font color="#008000"><i>// InitArrays</i></font></font></code> </blockquote> <br>  <i>stride</i> - the gap in memory (in bytes) between the first coordinate of the previous and the first coordinate of the next vertex. <br><br>  Note!  That vertices are used as normal vectors.  The fact is that for smooth filling I used the normal vector at the vertices.  And for a sphere, the direction of the normal vector corresponds to the coordinates of this vertex (of course, if the sphere is at the origin). <br><br>  Now let's draw a sphere. <br><br><blockquote> <code><font color="black"><font color="#0000FF">inline void</font> CScene::InitLights( <font color="#0000FF">void</font> ) { <br> <font color="#0000FF">const</font> GLfloat pos[] = {1.0, 1.0, 1.0, 0.0}; <br> <font color="#0000FF">const</font> GLfloat clr[] = {1.0, 1.0, 1.0, 1.0}; <br> <br> glEnable(GL_LIGHT0); <br> <br> glLightfv(GL_LIGHT0, GL_POSITION, pos); <br> glLightfv(GL_LIGHT0, GL_DIFFUSE,  clr); <br> glLightfv(GL_LIGHT0, GL_SPECULAR, clr); <br> } <font color="#008000"><i>// InitLights</i></font> <br> <br> <font color="#0000FF">void</font> CScene::Init( <font color="#0000FF">const int</font> _nWidth, <font color="#0000FF">const int</font> _nHeight) { <br> <font color="#008000"><i>//   </i></font> <br> glViewport(0, 0, _nWidth, _nHeight); <br> <font color="#008000"><i>///   </i></font> <br> glMatrixMode(GL_PROJECTION); <br> glLoadIdentity(); <br> gluPerspective(80.0, (GLdouble)_nWidth / (GLdouble)_nHeight, 0.1, 3.0); <br> <font color="#008000"><i>///  </i></font> <br> glMatrixMode(GL_MODELVIEW); <br> glLoadIdentity(); <br> gluLookAt( 0.0,1.5,1.5,  0.0,0.0,0.0,  0.0,1.0,0.0); <br> <font color="#008000"><i>///    </i></font> <br> glCullFace(GL_FRONT); <br> glEnable(GL_CULL_FACE); <br> <font color="#008000"><i>//    </i></font> <br> glEnable(GL_DEPTH_TEST); <br> <font color="#008000"><i>//  </i></font> <br> glEnable(GL_NORMALIZE); <br> <font color="#008000"><i>//   </i></font> <br> glShadeModel(GL_SMOOTH); <br> <font color="#008000"><i>//    - </i></font> <br> glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); <br> <font color="#008000"><i>///   </i></font> <br> <font color="#0000FF">this</font> -&gt;InitLights(); <br> glEnable(GL_LIGHTING); <br> <font color="#008000"><i>//    - </i></font> <br> glClearColor(0.0, 0.0, 0.0, 1.0); <br> <font color="#008000"><i>///    </i></font> <br> <font color="#0000FF">const</font> GLfloat clr[] = {1.0, 1.0, 1.0, 1.0}; <br> glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, clr); <br> glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 50.0); <br> <font color="#008000"><i>//   </i></font> <br> <font color="#0000FF">this</font> -&gt;InitArrays(); <br> } <font color="#008000"><i>// Init</i></font> <br> <br> <font color="#0000FF">inline void</font> CScene::DrawEarth( <font color="#0000FF">void</font> ) { <br> glDrawElements(GL_QUAD_STRIP, numberOfIndices, GL_UNSIGNED_INT, m_indices); <br> } <font color="#008000"><i>// DrawEarth</i></font> <br> <br> <font color="#0000FF">void</font> CScene::Redraw( <font color="#0000FF">void</font> ) { <br> glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <br> <br> <font color="#0000FF">this</font> -&gt;DrawEarth(); <br> <br> glFinish(); <br> } <font color="#008000"><i>// Redraw</i></font></font></code> </blockquote> <br>  And that's what happened as a result: <br><br><img width="256" height="170" src="https://habrastorage.org/getpro/geektimes/post_images/b23/198/5f0/b231985f09c23ee19b146f3d03f348ee.png"><br><br><h4>  NOW TEXTURE </h4><br>  Now that the sphere is ready.  It is necessary to impose a texture on it in order to betray similarities with the globe. <br>  Where to get the texture?  Everything is very simple.  Open <a href="http://images.google.ru/"><i>images.google.com</i></a> and enter the query there: " <i>Earth map</i> ". <br><br><img width="400" height="140" src="https://habrastorage.org/getpro/geektimes/post_images/396/e50/ffc/396e50ffc858f48533a4ace7ecf3190a.png"><br><br>  Stop your choice here on this texture: <br><br><img width="256" height="128" src="https://habrastorage.org/getpro/geektimes/post_images/33c/61d/4af/33c61d4af46fe5c8c1c2f279434f4afe.png"><br><br>  The texture will be stored in the resource file: <br><br><blockquote> <code><font color="black"><font color="#008000"><i>// <br> // Texture <br> //</i></font> <br> <br> IDR_TEXTURE_EARTH     TEXTURE <font color="#CC0000">"Earth.jpg"</font></font></code> </blockquote> <br>  Experienced programmers probably noticed that instead of the usual <i>BITMAP</i> I used <i>TEXTURE</i> .  Yes, and the file itself is taken with the extension <i>JPEG</i> , not <i>BMP</i> .  This is done in order to reduce the size of the executable. <br>  But, in the future, we need to work with a <i>bitmap</i> .  For this, I wrote a function that will load textures from resources into a <i>Bitmap</i> : <br><br><blockquote> <code><font color="black"><font color="#0000FF">inline</font> HBITMAP LoadTextureFromResource(HMODULE _hModule, LPCTSTR _lpName, LPCTSTR _lpType) { <br> HRSRC hRsrc = FindResource(_hModule, _lpName, _lpType); <br> <font color="#0000FF">if</font> (NULL == hRsrc) <font color="#0000FF">return</font> NULL; <br> <br> HGLOBAL hGlobal = LoadResource(_hModule, hRsrc); <br> <font color="#0000FF">if</font> (NULL == hGlobal) <font color="#0000FF">return</font> NULL; <br> <br> HBITMAP hBitmap = NULL; <br> DWORD dwSize = SizeofResource(_hModule, hRsrc); <br> <br> HGLOBAL hData = GlobalAlloc(GMEM_MOVEABLE, dwSize); <br> CopyMemory(GlobalLock(hData), LockResource(hGlobal), dwSize); <br> GlobalUnlock(hData); <br> <br> IStream *pStream = NULL; <br> HRESULT hr = CreateStreamOnHGlobal(hData, FALSE, &amp;pStream); <br> <font color="#0000FF">if</font> (SUCCEEDED(hr)) { <br> IPicture *pPicture = NULL; <br> hr = OleLoadPicture(pStream, dwSize, TRUE, IID_IPicture, (LPVOID*)&amp;pPicture); <br> <br> <font color="#0000FF">if</font> (SUCCEEDED(hr)) { <br> pPicture-&gt;get_Handle((OLE_HANDLE *)&amp;hBitmap); <br> hBitmap = (HBITMAP)CopyImage(hBitmap, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION); <br> <br> pPicture-&gt;Release(); pPicture = NULL; <br> } <font color="#008000"><i>// if</i></font> <br> pStream-&gt;Release(); pStream = NULL; <br> } <font color="#008000"><i>// if</i></font> <br> <br> GlobalFree(hData); hData = NULL; <br> UnlockResource(hGlobal); hGlobal = NULL; <br> <br> <font color="#0000FF">return</font> hBitmap; <br> } <font color="#008000"><i>// LoadTextureFromResource</i></font></font></code> </blockquote> <br><br>  Now you need to load the texture and calculate the texture coordinates.  To do this, change the declaration of the array of vertices and declare a variable in which the texture will be stored <br><br><blockquote> <code><font color="black"><font color="#0000FF">class</font> CScene { <br> <font color="#0000FF">private</font> : <br> <br> ... <br> <br> <font color="#0000FF">struct</font> { <br> GLfloat x,y,z; <font color="#008000"><i>//  </i></font> <br> GLfloat u,v; <font color="#008000"><i>//  </i></font> <br> } m_vertices[numberOfVertices]; <font color="#008000"><i>//  </i></font> <br> <br> ... <br> <br> <font color="#0000FF">struct</font> { <br> GLuint  id; <font color="#008000"><i>//  </i></font> <br> HBITMAP hBitmap; <font color="#008000"><i>//   </i></font> <br> } m_textureOfEarth; <br> <br> ... <br> <br> }; <font color="#008000"><i>// class CScene</i></font></font></code> </blockquote> <br>  After that, we will change the previously described functions by adding functionality that works with textures.  And draw a globe. <br><br><blockquote> <code><font color="black">CScene::CScene( <font color="#0000FF">void</font> ) { <br> <font color="#008000"><i>///        </i></font> <br> <font color="#0000FF">const</font> GLfloat fRadius = 1.0; <br> <br> <font color="#0000FF">for</font> ( <font color="#0000FF">int</font> alpha = 90, index = 0; alpha &lt;= 270; alpha += step) { <br> <font color="#0000FF">const int</font> angleOfVertical = alpha % 360; <br> <br> <font color="#0000FF">for</font> ( <font color="#0000FF">int</font> phi = 0; phi &lt;= 360; phi += step, ++index) { <br> <font color="#0000FF">const int</font> angleOfHorizontal = phi % 360; <br> <br> <font color="#008000"><i>///   </i></font> <br> ... <br> <br> <font color="#008000"><i>///   </i></font> <br> m_vertices[index].u = (360 - phi) / 360.0f; <br> m_vertices[index].v = (270 - alpha) / 180.0f; <br> } <font color="#008000"><i>// for</i></font> <br> } <font color="#008000"><i>// for</i></font> <br> <br> <font color="#008000"><i>///        </i></font> <br> ... <br> <br> <font color="#008000"><i>///    </i></font> <br> HINSTANCE hModule = GetModuleHandle(NULL); <br> m_textureOfEarth.hBitmap = LoadTextureFromResource(hModule, MAKEINTRESOURCE(IDR_TEXTURE_EARTH), _T( <font color="#CC0000">"TEXTURE"</font> )); <br> } <font color="#008000"><i>// constructor CScene</i></font> <br> <br> CScene::~CScene( <font color="#0000FF">void</font> ) { <br> <font color="#008000"><i>///  </i></font> <br> <font color="#0000FF">if</font> (NULL != m_textureOfEarth.hBitmap) { <br> DeleteObject(m_textureOfEarth.hBitmap); <br> } <font color="#008000"><i>// if</i></font> <br> } <font color="#008000"><i>// destructor CScene</i></font> <br> <br> <font color="#0000FF">inline void</font> CScene::InitArrays( <font color="#0000FF">void</font> ) { <br> <font color="#0000FF">const</font> GLsizei stride = 5 * <font color="#0000FF">sizeof</font> (GLfloat); <br> <br> ... <br> <br> glEnableClientState(GL_TEXTURE_COORD_ARRAY); <br> glTexCoordPointer(2, GL_FLOAT, stride, (GLfloat *)m_vertices + 3); <br> } <font color="#008000"><i>// InitArrays</i></font> <br> <br> <font color="#0000FF">inline void</font> CScene::InitTextures( <font color="#0000FF">void</font> ) { <br> <font color="#008000"><i>///  </i></font> <br> <font color="#0000FF">if</font> (NULL != m_textureOfEarth.hBitmap) { <br> glGenTextures(1, &amp;m_textureOfEarth.id); <br> glBindTexture(GL_TEXTURE_2D, m_textureOfEarth.id); <br> <br> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); <br> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); <br> <br> BITMAP bitmap = { 0 }; <br> GetObject(m_textureOfEarth.hBitmap, <font color="#0000FF">sizeof</font> (BITMAP), &amp;bitmap); <br> <br> glTexImage2D(GL_TEXTURE_2D, 0, 3, bitmap.bmWidth, bitmap.bmHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, bitmap.bmBits); <br> } <font color="#008000"><i>// if</i></font> <br> } <font color="#008000"><i>// InitTextures</i></font> <br> <br> <font color="#0000FF">void</font> CScene::Init( <font color="#0000FF">const int</font> _nWidth, <font color="#0000FF">const int</font> _nHeight) { <br> ... <br> <font color="#008000"><i>//  </i></font> <br> <font color="#0000FF">this</font> -&gt;InitTextures(); <br> <font color="#008000"><i>//  </i></font> <br> glEnable(GL_TEXTURE_2D); <br> } <font color="#008000"><i>// Init</i></font> <br> <br> <font color="#0000FF">inline void</font> CScene::DrawEarth( <font color="#0000FF">void</font> ) { <br> glBindTexture(GL_TEXTURE_2D, m_textureOfEarth.id); <br> glDrawElements(GL_QUAD_STRIP, numberOfIndices, GL_UNSIGNED_INT, m_indices); <br> } <font color="#008000"><i>// DrawEarth</i></font></font></code> </blockquote> <br>  Click the compilation ... And this is what the program gives us: <br><br><img width="256" height="169" src="https://habrastorage.org/getpro/geektimes/post_images/e06/01c/0ea/e0601c0ead9acc65df89ae3b9fcefde9.png"><br><br><h4>  RELIEF </h4><br>  It seems everything looks good, but something is still missing.  What?  Not enough relief.  Those.  for greater realism, you must add mountains and valleys.  How to do it? <br><br>  To transfer irregularities, it is necessary to impose several textures on one plane (make several semitransparent planes parallel to this one, but located ‚Äúslightly below‚Äù it or use multitexturing included in the OpenGL extension). <br><br>  Here, two textures are used: the original texture of the surface of the globe and the texture that reflects surface irregularities (black and white), which, relatively speaking, defines a height map (we will call it a surface map). <br><br><img width="256" height="128" src="https://habrastorage.org/getpro/geektimes/post_images/052/6cd/1b4/0526cd1b44ad2632bbc90a082446aa90.png"><br><br>  Add it to the resource file. <br><br><blockquote> <code><font color="black"><font color="#008000"><i>// <br> // Texture <br> //</i></font> <br> <br> IDR_TEXTURE_EARTH     TEXTURE <font color="#CC0000">"Earth.jpg"</font> <br> IDR_TEXTURE_BUMP      TEXTURE <font color="#CC0000">"bump.jpg"</font></font></code> </blockquote> <br>  First you need to load the original texture (1), and from the surface map we create two textures: the first (2) is exactly the same, but we reduce the brightness twice;  the second (3) is an inverted (by brightness value) surface map, for which we also reduce the brightness value twice. <br><br><blockquote> <code><font color="black"><font color="#0000FF">class</font> CScene { <br> <font color="#0000FF">private</font> : <br> <br> ... <br> <br> <font color="#0000FF">struct</font> { <br> GLuint  id; <font color="#008000"><i>//  </i></font> <br> HBITMAP hBitmap; <font color="#008000"><i>//   </i></font> <br> } m_textureOfEarth, m_textureOfBump, m_textureOfBumpInvert; <br> <br> ... <br> <br> }; <font color="#008000"><i>// class CScene</i></font> <br> <br> ... <br> <br> CScene::CScene( <font color="#0000FF">void</font> ) { <br> <font color="#008000"><i>///        </i></font> <br> ... <br> <br> <font color="#008000"><i>///        </i></font> <br> ... <br> <br> <font color="#008000"><i>///    </i></font> <br> HINSTANCE hModule = GetModuleHandle(NULL); <br> <br> m_textureOfEarth.hBitmap = LoadTextureFromResource(hModule, MAKEINTRESOURCE(IDR_TEXTURE_EARTH), _T( <font color="#CC0000">"TEXTURE"</font> )); <br> <br> m_textureOfBump.hBitmap = LoadTextureFromResource(hModule, MAKEINTRESOURCE(IDR_TEXTURE_BUMP), _T( <font color="#CC0000">"TEXTURE"</font> )); <br> <br> m_textureOfBumpInvert.hBitmap = LoadTextureFromResource(hModule, MAKEINTRESOURCE(IDR_TEXTURE_BUMP), _T( <font color="#CC0000">"TEXTURE"</font> )); <br> <font color="#0000FF">if</font> (NULL != m_textureOfBumpInvert.hBitmap) { <br> BITMAP bitmap = { 0 }; <br> GetObject(m_textureOfBumpInvert.hBitmap, <font color="#0000FF">sizeof</font> (BITMAP), &amp;bitmap); <br> <br> <font color="#008000"><i>//  </i></font> <br> LPBYTE ptr = (LPBYTE)bitmap.bmBits + (3 * bitmap.bmHeight * bitmap.bmWidth); <br> <font color="#0000FF">while</font> (--ptr &gt;= bitmap.bmBits) (*ptr) = 0xFF - (*ptr); <br> } <font color="#008000"><i>// if</i></font> <br> } <font color="#008000"><i>// constructor CScene</i></font> <br> <br> CScene::~CScene( <font color="#0000FF">void</font> ) { <br> <font color="#008000"><i>///  </i></font> <br> <font color="#0000FF">if</font> (NULL != m_textureOfEarth.hBitmap) { <br> DeleteObject(m_textureOfEarth.hBitmap); <br> } <font color="#008000"><i>// if</i></font> <br> <font color="#008000"><i>///  </i></font> <br> <font color="#0000FF">if</font> (NULL != m_textureOfBump.hBitmap) { <br> DeleteObject(m_textureOfBump.hBitmap); <br> } <font color="#008000"><i>// if</i></font> <br> <font color="#008000"><i>///  </i></font> <br> <font color="#0000FF">if</font> (NULL != m_textureOfBumpInvert.hBitmap) { <br> DeleteObject(m_textureOfBumpInvert.hBitmap); <br> } <font color="#008000"><i>// if</i></font> <br> } <font color="#008000"><i>// destructor CScene</i></font> <br> <br> <font color="#0000FF">inline void</font> CScene::InitTextures( <font color="#0000FF">void</font> ) { <br> <font color="#008000"><i>///  </i></font> <br> <font color="#0000FF">if</font> (NULL != m_textureOfEarth.hBitmap) { <br> ... <br> } <font color="#008000"><i>// if</i></font> <br> <font color="#008000"><i>///  </i></font> <br> <font color="#0000FF">if</font> (NULL != m_textureOfBump.hBitmap) { <br> glGenTextures(1, &amp;m_textureOfBump.id); <br> glBindTexture(GL_TEXTURE_2D, m_textureOfBump.id); <br> <br> glPixelTransferf(GL_RED_SCALE, 0.5); <font color="#008000"><i>//    50%,</i></font> <br> glPixelTransferf(GL_GREEN_SCALE, 0.5); <font color="#008000"><i>//     </i></font> <br> glPixelTransferf(GL_BLUE_SCALE, 0.5); <br> <br> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); <br> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); <br> <br> BITMAP bitmap = { 0 }; <br> GetObject(m_textureOfBump.hBitmap, <font color="#0000FF">sizeof</font> (BITMAP), &amp;bitmap); <br> <br> glTexImage2D(GL_TEXTURE_2D, 0, 3, bitmap.bmWidth, bitmap.bmHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, bitmap.bmBits); <br> } <font color="#008000"><i>// if</i></font> <br> <font color="#008000"><i>///  </i></font> <br> <font color="#0000FF">if</font> (NULL != m_textureOfBumpInvert.hBitmap) { <br> glGenTextures(1, &amp;m_textureOfBumpInvert.id); <br> glBindTexture(GL_TEXTURE_2D, m_textureOfBumpInvert.id); <br> <br> glPixelTransferf(GL_RED_SCALE, 0.5); <font color="#008000"><i>//    50%,</i></font> <br> glPixelTransferf(GL_GREEN_SCALE, 0.5); <font color="#008000"><i>//     </i></font> <br> glPixelTransferf(GL_BLUE_SCALE, 0.5); <br> <br> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); <br> glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); <br> <br> BITMAP bitmap = { 0 }; <br> GetObject(m_textureOfBumpInvert.hBitmap, <font color="#0000FF">sizeof</font> (BITMAP), &amp;bitmap); <br> <br> glTexImage2D(GL_TEXTURE_2D, 0, 3, bitmap.bmWidth, bitmap.bmHeight, 0, GL_BGR_EXT, GL_UNSIGNED_BYTE, bitmap.bmBits); <br> } <font color="#008000"><i>// if</i></font> <br> } <font color="#008000"><i>// InitTextures</i></font></font></code> </blockquote> <br>  The output occurs in the following sequence: first, a plane with a superimposed texture (2) is displayed, before this the following parameters must be set in OpenGL: <br><br><blockquote> <code><font color="black">glDisable(GL_BLEND); <br> glDisable(GL_LIGHTING);</font></code> </blockquote> <br>  Before displaying the next plane, the following parameters are set: <br><br><blockquote> <code><font color="black">glBlendFunc(GL_ONE, GL_ONE); <br> glDepthFunc(GL_LEQUAL); <br> glEnable(GL_BLEND);</font></code> </blockquote> <br>  The plane itself is displayed in the same place as the previous one, but ‚Äúslightly‚Äù raised relative to the previous one (so that there are no overlaps) and a superimposed texture (3). <br><br>  Before displaying the last plane, the following OpenGL parameters must be set: <br><br><blockquote> <code><font color="black">glEnable(GL_LIGHTING); <br> glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR);</font></code> </blockquote> <br>  It also displays a plane that is parallel to the previous one, but ‚Äúslightly‚Äù raised relative to them, in order to avoid intersections.  A texture is superimposed on the plane (1). <br><br><blockquote> <code><font color="black"><font color="#0000FF">inline void</font> CScene::DrawEarth( <font color="#0000FF">void</font> ) { <br> <font color="#008000"><i>///   </i></font> <br> glDisable(GL_BLEND); <br> glDisable(GL_LIGHTING); <br> <br> glBindTexture(GL_TEXTURE_2D, m_textureOfBump.id); <br> glPushMatrix(); <br> glScalef(0.99f, 0.99f, 0.99f); <br> glDrawElements(GL_QUAD_STRIP, numberOfIndices, GL_UNSIGNED_INT, m_indices); <br> glPopMatrix(); <br> <br> <font color="#008000"><i>///   </i></font> <br> glBlendFunc(GL_ONE, GL_ONE); <br> glDepthFunc(GL_LEQUAL); <br> glEnable(GL_BLEND); <br> <br> glBindTexture(GL_TEXTURE_2D, m_textureOfBumpInvert.id); <br> glPushMatrix(); <br> glScalef(0.995f, 0.995f, 0.995f); <br> glDrawElements(GL_QUAD_STRIP, numberOfIndices, GL_UNSIGNED_INT, m_indices); <br> glPopMatrix(); <br> <br> <font color="#008000"><i>///   </i></font> <br> glEnable(GL_LIGHTING); <br> glBlendFunc(GL_DST_COLOR, GL_SRC_COLOR); <br> <br> glBindTexture(GL_TEXTURE_2D, m_textureOfEarth.id); <br> glDrawElements(GL_QUAD_STRIP, numberOfIndices, GL_UNSIGNED_INT, m_indices); <br> } <font color="#008000"><i>// DrawEarth</i></font></font></code> </blockquote> <br>  The result is an image on which the relief is visible. <br><br><img width="256" height="174" src="https://habrastorage.org/getpro/geektimes/post_images/865/ac2/6b5/865ac26b5d460de627ccda3398ae5b5a.png"><br><br>  <font color="#999999">The project binaries and sources can be downloaded <a href="http://www.sharemania.ru/0226083">here.</a></font> </div><p>Source: <a href="https://habr.com/ru/post/77985/">https://habr.com/ru/post/77985/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../77979/index.html">Canobuvosti, 17th edition</a></li>
<li><a href="../77981/index.html">About fraud with copies of passports (on the Internet)</a></li>
<li><a href="../77982/index.html">JPA: Storing transfers in a database</a></li>
<li><a href="../77983/index.html">Triangular coin</a></li>
<li><a href="../77984/index.html">How to increase the rating of free programs in the AppStore</a></li>
<li><a href="../77987/index.html">Skype for Symbian is now real!</a></li>
<li><a href="../77989/index.html">Guide to creating websites from Yandex</a></li>
<li><a href="../77990/index.html">Start service I'm Sync</a></li>
<li><a href="../77994/index.html">podcasting and streaming audio program</a></li>
<li><a href="../77996/index.html">Site of the company "ChernomorStroyServis"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>