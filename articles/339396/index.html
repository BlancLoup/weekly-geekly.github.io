<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>iOS Safari 11 now can WebRTC</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A couple of weeks ago there was a release of new iPhones and iOS 11, which it was impossible not to notice. With the release, one more event, certainl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>iOS Safari 11 now can WebRTC</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/de/08/59de08c39ee15812786003.jpeg"></div><br>  A couple of weeks ago there was a release of new iPhones and iOS 11, which it was impossible not to notice.  With the release, one more event, certainly an important one for developers, happened: the long-awaited support of WebRTC appeared in the Safari browser. <br><br>  Imagine for a minute, millions of iPhones and iPads around the world began to be able to realtime audio and video in the browser.  Full-featured browser video chats, playback of live broadcasts with a low (less than a second) real-time delay, calls, conferences, and much more have become available to iOS and Mac users.  To this a long walk and finally it happened. <br><a name="habracut"></a><br><h2>  It was </h2><br>  Earlier, <a href="https://habrahabr.ru/company/flashphoner/blog/325978/">we wrote</a> about a way to play video with minimal delay in iOS Safari, and this method is still relevant for iOS 9 and iOS 10, where there is no support for WebRTC technology.  We offered to use the approach codenamed ‚ÄúWSPlayer‚Äù, which allows you to deliver a live video stream from the server using the Websocket protocol, further decode the stream using JavaScript, and draw the video stream in the HTML5 Canvas element using WebGL. here's what it looked like: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd63164ba522764315.jpeg"></div><br>  This approach allowed and now allows playing the stream on the iOS Safari browser page with a delay of about 3 seconds, but has the following disadvantages: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. Performance. <br><br>  The video stream is decoded by JavaScript.  This creates a fairly high load on the CPU of the mobile device, does not allow to play high resolutions and recycles battery power. <br><br>  2. TCP. <br><br>  The transport protocol used for video and audio is Websocket / TCP.  For this reason, it is not possible to target a delay, which may increase depending on network fluctuations. <br><br>  All this time, until iOS 11 came out, WSPlayer could play video with a relatively low latency (3 seconds), compared to HLS (20 seconds).  Now everything has changed for the better, and the JavaScript player is replaced by the native technology WebRTC, which does all the work by the means of the browser itself without decoding into JavaScript and without using Canvas. <br><br><h2>  It became </h2><br>  With the advent of WebRTC, the low latency video playback scheme in iOS Safari 11 has become identical to other browsers already supporting WebRTC, namely Chrome, Firefox, Edge. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd633faeb921061609.jpeg"></div><br><h2>  Microphone and camera </h2><br>  Above, we wrote only about playing real-time video.  However, video chat cannot be started without a camera and microphone, and this was a major obstacle and a major headache for developers who planned to support iOS Safari in their video chat or other web project with live video.  How many man-hours were spent in vain on finding a solution in iOS Safari 9 and 10, when this solution simply did not exist - Safari could not capture the camera and microphone, and this ‚Äúnebaganofich‚Äù was fixed quite recently in iOS 11. <br><br>  Launch iOS 11 Safari and request access to the camera and microphone.  It was this simple thing that we waited for and, as you can see, waited: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd6351ed8012875257.png" width="350"></div><br>  The browser asks the camera and microphone and can stream both live streams and play sound and video. <br><br>  And you can also look at the Safari browser settings and turn on / off the microphone there: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd63a6fc9009276107.png" width="350"></div><br><h2>  Camera display and streaming video playback </h2><br>  Not without its ‚Äúfeatures‚Äù.  The main distinctive feature of video playback in a video element is the fact that to play the page you need to click (tap). <br><br>  For developers, this is a clear limitation and a brake.  After all, if the customer requires - ‚ÄúI want the video to start playing automatically after the page loads‚Äù, in iOS Safari this trick will not work and the developer will have to explain that Safari and Apple are to blame for everything with their security policy. <br><br>  For users, this can be a blessing, since sites cannot play the stream without the knowledge of the user, who, by clicking on the UI element of the page, formally confirms his desire to play this video stream. <br><br><h2>  What about Mac OS? </h2><br>  There is good news for owners of MacBooks and Mac OS.  After the update, Safari 11 for Mac also earned WebRTC.  Prior to this, Mac Safari used the good old Flash Player, which allows you to do the work that WebRTC does - to press and play audio and video over the network via the RTMP and RTMFP protocols.  But with the advent of WebRTC, the need to use Flash Player for video chatting has disappeared.  Therefore, for Safari 11+ we use WebRTC, and for Safari 10 or less, we continue to use Flash Player or WebRTC plugins as a fallback mechanism. <br><br><h2>  Specify the status </h2><br>  As you can see, Safari 11 added support for WebRTC, and for Safari 9 and 10 there were fallbacks in the form of Fash Player and WebRTC plugins on Mac OS, and also WSPlayer on iOS. <br><table><tbody><tr><td><p>  Mac, Safari 10 </p><br></td><td><p>  iOS 9, 10, Safari </p></td><td><p>  Mac, Safari 11 </p></td><td><p>  iOS 11, Safari </p></td></tr><tr><td><p>  Flash player </p><br><p>  WebRTC plugins </p><br><p>  Wsplayer </p><br></td><td><p>  Wsplayer </p></td><td><p>  Webrtc </p></td><td><p>  Webrtc </p><br></td></tr></tbody></table><br><h2>  We are testing the broadcast from browser to browser </h2><br>  Now let's check the main cases in practice, and let's start with the player.  First, install the iOS 11.0.2 update with the new Safari. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd63c7e12558421578.png" width="350"></div><br>  So, as a first test, Chrome for Windows will broadcast the video stream to the server, and the viewer on iOS Safari will play the video stream via WebRTC. <br><br>  Open the Two Way Streaming example in the Chrome browser and send a WebRTC video stream with the name 1ad5 to the server.  Chrome captures video from the camera, presses to the H.264 codec in this case, and sends a live stream to the server for subsequent distribution.  Broadcast video looks like <a href="https://wcs5-eu.flashphoner.com/client2/examples/demo/streaming/two_way_streaming/two_way_streaming.html">this</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd640cb7e986459762.jpeg"></div><br>  To play, specify the name of the stream and the player in iOS Safari starts to play the stream that was previously sent to Chrome by the server.  Playing a stream on an iPhone in Safari browser looks like <a href="https://wcs5-eu.flashphoner.com/client2/examples/demo/streaming/two_way_streaming/two_way_streaming.html">this</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd6556244338282231.png"></div><br>  The delay is invisible (less than a second).  The video stream is played out smoothly, without hints of artifacts.  The playback quality is normal, you can see on the screenshots. <br><br>  And this is how video playback looks in the same example, <a href="https://wcs5-eu.flashphoner.com/client2/examples/demo/streaming/two_way_streaming/two_way_streaming.html">Two Way Streaming</a> in the Play block.  Thus, one stream can be broadcast, and the second can be played on the same browser page.  If users know the names of each other's streams, we get a simple video chat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd64e50d2278587302.png" width="350"></div><br><h2>  We are testing webcam and microphone broadcast using iOS Safari </h2><br>  As we wrote above, the main feature of WebRTC is the ability to capture the camera and microphone in the browser and send it over the network with targeted low latency.  Checking how it works in iOS Safari 11. <br><br>  We open the same demo streamer example in Safari that we opened in Chrome.  We get access to the camera and microphone.  Safari displays a dialog that prompts you to enable or disable the use of a camera and microphone. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd6351ed8012875257.png" width="350"></div><br>  After allowing access to the camera and microphone, we will see a red camera icon in the upper left corner of the browser.  So Safari shows that the camera is active and in use.  In this case, the video stream is sent to the server. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd662701f114819290.png" width="350"></div><br>  We are taking this stream in another browser, for example Chrome.  On playback, we see a stream from Safari with a cursed vertical shot, and all because the device is not turned into a horizontal position. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/de/09/59de09c617145196882595.jpeg"></div><br>  After changing the orientation of the iPhone, the stream playback picture becomes normal: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/de/09/59de094a34439660749065.jpeg"></div><br>  Capturing and streaming video is always technologically more interesting than playback, because it is here that important RTCP feeds take place, which target delay and video quality. <br><br>  At the time of this article, we did not find suitable tools for monitoring WebRTC in the browser for iOS Safari, similar to webrtc-internals for Chrome.  Let's see how the server sees the video stream captured from Safari.  To do this, we turn on monitoring and check the main graphs that describe the traffic coming from Safari. <br><br>  The first cut of the graphs shows such metrics as NACK and PLI, which are indicators of the loss of UDP packets.  For a normal network, the number of NACKs, shown in the graphs, is insignificant, about 15, therefore we consider that the analyzes are within the normal range. <br><br>  FPS video stream ranges from 29,30,31 and does not sink to low values ‚Äã‚Äã(10-15).  This means that the iPhone hardware accelerator has enough performance to encode video in H.264 codec, and there is enough processor to stream this video to the network.  For this test, we used the iPhone 6, 16 GB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd663a102397422812.png"></div><br>  The following graphs show how the video resolution and bitrate change.  Video bitrate varies in the range of 1.2 - 1.6 Mbps, video resolution remains unchanged 640x480.  This suggests that there is enough bandwidth to encode the video and Safari presses the video with the maximum bit rate.  If desired, the bit rate can be clamped within the desired limits. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd66835ce951672153.jpeg"></div><br>  Next, we check the bitrate of the audio component of the stream and the statistics of audio losses.  From the graph it is clear that the audio is not lost, the loss counter is at zero.  Audio bitrate is 30-34 kbps.  This is the Opus codec, with which Safari presses the audio stream captured from the microphone. <br><br>  And the last chart is timecode.  According to it, we estimate how synchronously the audio and video sets.  If there is no synchronicity, then visual desynchronization becomes noticeable when the voice does not keep up with the lips, or vice versa the video goes forward.  In this case, the flow with Safari comes perfectly synchronously and monotonously without the slightest deviation. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd66b4282001607834.jpeg"></div><br>  From the presented graphs, a picture typical of WebRTC and a behavior very similar to the behavior of the Google Chrome browser is visible: the NACK and PLI feedbacks come in, FPS varies slightly, the bitrate floats.  That is, we get the WebRTC that we‚Äôve been waiting for. <br><br>  Pay attention to changing the height and width.  For example, if you change the position of the device to the horizontal, the resolution of the stream will change to the opposite, for example from 640x480 to 480x640, as in the graph below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd66c0445450743621.jpeg"></div><br>  The orange line on the graph shows the width, and the blue height of the image.  At 05:21:17, we turn the iPhone, which streams the stream, to the horizontal position and the resolution of the stream changes exactly to the opposite 480 in width and 640 in height. <br><br><h2>  We test video playback from IP-camera, in WebRTC for iOS Safari </h2><br>  An IP camera is most often a portable Linux server that provides streams using the RTSP protocol.  In this test, we take video from an IP camera with H.264 support and play this video in the iOS Safari browser via WebRTC.  To do this, in the player shown above, enter instead of the name of the stream, its RTSP address. <br><br>  Playing a stream from an IP camera in Safari via WebRTC looks like <a href="https://wcs5-eu.flashphoner.com/client2/examples/demo/streaming/embed_player/sample.html">this</a> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/59/d5/fd/59d5fd6803e26703606679.png" width="350"></div><br>  The video in this case plays back smoothly, without any problems with the picture.  But there is still a lot depends on the source of the stream - on how the video from the camera will go to the server. <br><br>  As a result, we successfully tested the following 3 cases: <br><br><ul><li>  Broadcast from Chrome browser to Safari </li><li>  Capturing a camera and microphone from Safari to Chrome </li><li>  Playing video from an IP camera in iOS Safari </li></ul><br><h2>  A little about the code </h2><br>  For broadcasting video streams, we use a universal API ( <a href="https://flashphoner.com/wcs-web-sdk">Web SDK</a> ), which in terms of translation looks like this: <br><br><pre><code class="php hljs">session.createStream({name:<span class="hljs-string"><span class="hljs-string">'stream22'</span></span>,display:document.getElementById(<span class="hljs-string"><span class="hljs-string">'myVideo'</span></span>)}).publish();</code> </pre> <br>  Here we set the unique name of the stream stream22 and use the div element: <br><br><pre> <code class="php hljs">&lt;div id=<span class="hljs-string"><span class="hljs-string">'myVideo'</span></span>&gt;&lt;/div&gt;</code> </pre> <br>  To display the captured camera on a web page. <br><br>  Playing the same video stream in the browser works like this: <br><br><pre> <code class="php hljs">session.createStream({name:<span class="hljs-string"><span class="hljs-string">'stream22'</span></span>,display:document.getElementById(<span class="hljs-string"><span class="hljs-string">'myVideo'</span></span>)}).play();</code> </pre> <br>  Those.  denote the stream name again and specify the div element in which you want to place the video for playback.  With the subsequent call of the play () method. <br><br>  iOS Safari, is currently the only browser in which you need to click on the page element to make the video play. <br><br>  Therefore, we added a small code, specifically for iOS Safari, which ‚Äúactivates‚Äù the video element before playing the stream, by calling the following <a href="">code</a> : <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Flashphoner.getMediaProviders()[<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-string"><span class="hljs-string">"WSPlayer"</span></span>) { Flashphoner.playFirstSound(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Browser.isSafariWebRTC() &amp;&amp; Flashphoner.getMediaProviders()[<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-string"><span class="hljs-string">"WebRTC"</span></span>) || Flashphoner.getMediaProviders()[<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-string"><span class="hljs-string">"MSE"</span></span>) { Flashphoner.playFirstVideo(remoteVideo); }</code> </pre><br>  This code in the standard player is called by clicking on the Play button, and thus we fulfill the requirement of Apple and correctly start playing. <br><br><pre> <code class="php hljs">Flashphoner.playFirstVideo(remoteVideo);</code> </pre> <br><h2>  In conclusion </h2><br>  iOS 11 Safari has finally received WebRTC support, and this support is unlikely to be fixed in the next updates.  Therefore, we boldly use this opportunity and make real-time streaming video and calls in this browser.  Install further iOS 11.x updates and look forward to new fixes and feature bugs.  Good streaming! <br><br><h2>  Links </h2><br>  <a href="https://flashphoner.com/">WCS</a> - the server with which I tested broadcasts on iOS 11 Safari <br>  <a href="https://wcs5-eu.flashphoner.com/client2/examples/demo/streaming/two_way_streaming/two_way_streaming.html">Two Way Streaming</a> - An Example Translator <br>  <a href="https://github.com/flashphoner/flashphoner_client/tree/wcs_api-2.0/examples/demo/streaming/two_way_streaming">Source Two Way Streaming</a> - source tape stream <br>  <a href="https://wcs5-eu.flashphoner.com/client2/examples/demo/streaming/player/player.html">Player</a> - an example of a player <br>  <a href="https://github.com/flashphoner/flashphoner_client/tree/wcs_api-2.0/examples/demo/streaming/player">Source Player</a> - player sources <br>  <a href="https://flashphoner.com/pleer-dlya-vosproizvedeniya-s-nizkoj-zaderzhkoj-v-ios-safari/%3Flang%3Dru">WSPlayer</a> - play low latency streams in iOS 9, 10 Safari </div><p>Source: <a href="https://habr.com/ru/post/339396/">https://habr.com/ru/post/339396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../339386/index.html">Creator of Open Data Science about Slack, xgboost and GPU</a></li>
<li><a href="../339388/index.html">"Back to the Future": Blockchain Today and Tomorrow</a></li>
<li><a href="../339390/index.html">Jenkins Task Management</a></li>
<li><a href="../339392/index.html">Airflow is a tool to conveniently and quickly develop and maintain batch data processing processes.</a></li>
<li><a href="../339394/index.html">APDEX and 1C Performance Measurements</a></li>
<li><a href="../339398/index.html">Leading from big and smart data fields: SmartData 2017 Piter conference program</a></li>
<li><a href="../339400/index.html">Kotlin in Action released in Russian</a></li>
<li><a href="../339402/index.html">Unified Repository for Enterprise Architecture Management</a></li>
<li><a href="../339404/index.html">We are improving communication between employers and applicants at My Circle (correspondence + company contact persons)</a></li>
<li><a href="../339406/index.html">C / C ++ code optimization</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>