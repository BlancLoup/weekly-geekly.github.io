<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Digital Smoothing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 This article made me write a post habrahabr.ru/post/183986 , where it is not quite correct to use some kind of image smoothing algorith...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Digital Smoothing</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  This article made me write a post <a href="http://habrahabr.ru/post/183986/">habrahabr.ru/post/183986</a> , where it is not quite correct to use some kind of image smoothing algorithm. <br><br>  Go right to the point. <br><br>  Mathematical models of digital signals - vectors and matrices, whose elements are numbers.  Numbers can be binary (binary signal), decimal ("normal" signal) and so on.  Any sound, any image and video can be converted into a digital signal <sup>1</sup> : sound into a vector, an image into a matrix, and video into a sequential set of matrices.  Therefore, a digital signal is, one may say, a universal object for the presentation of information. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The task of smoothing is, in fact, the task of filtering a signal from stepwise (stepwise) changes.  It is believed that the useful signal does not contain them.  The stepped signal due to the set of sharp, but small in amplitude, level drops contains high-frequency components that are not present in the smoothed signal.  Therefore, for some smoothing algorithm, it is first necessary to determine how different frequency components are attenuated.  In other words, it is necessary to construct the amplitude-frequency characteristic of the corresponding filter, otherwise the probability of ‚Äúrunning into‚Äù the artifacts is great. <br><br>  The smoothing task can be used when thinning signals, that is, when, for example, you need to display a large image on a small screen.  Or when the sampling rate of sound is reduced, for example, from 48000 Hz to 44100 Hz.  Reducing the sampling rate is an insidious operation that requires preprocessing of the signal (low-pass filtering), but this is a topic for another conversation ... <br><br>  Let's give an example of ‚Äúbad‚Äù anti-aliasing. <br><img src="https://habrastorage.org/storage2/caa/4a9/045/caa4a90451517ce0cbe7f528645e5911.gif"><br><br>  It would seem that the usual averaging and the output signal should be ‚Äúsmooth‚Äù.  But how to determine how he became "smoother"?  Did we overdo it?  Or maybe some coefficients are not chosen by 1/3?  Or maybe averaged over five points?  How to determine how attenuated the frequency components in the signal?  How to find <b>your</b> (that is, for a specific task) optimum? <br>  I will try to answer these and some other questions in such a way that the ‚Äúordinary‚Äù programmer can substantiate his algorithm - I hope not only the algorithm on the topic ‚ÄúSmoothing‚Äù, as the ideas will be presented very general, <b>forcing you to think for yourself</b> ... <br><a name="habracut"></a><br><br><h4>  Signals </h4><br><br>  In this paragraph, a signal is a vector, that is, an array of a certain number of numbers.  For example, a vector of four elements <b>s</b> = (2,5; 5; 0; -5). <br><br>  For simplicity, only decimal real numbers will be considered. <br><br>  One of the most common and clear signals is the digitized sound.  The size of the signal depends on the duration of the sound and on the frequency with which the samples are taken (on the sampling frequency).  Elements-signal numbers depend on the current amplitude of the sound measured by the sampling and storage device. <br><br>  As already mentioned, one of the easiest ways to smoothing is <br><img src="https://habrastorage.org/storage2/c4b/402/3ca/c4b4023caa728489dc36a9d34b708c7f.png">  (one) <br>  where <i>s</i> is the original signal, <i>v</i> is the smoothed signal. <br><br>  Method (1) is based on the smoothing property of summation, because it is clear to everyone that the average value, calculated as the sum of many random numbers, with increasing number of summed numbers becomes less and less similar to random variable <sup>2</sup> , which, simply speaking, is noise <sup>3</sup> . <br><br>  But what is the basis of the choice of coefficients in equation (1)?  On the fact that the mean is calculated?  It seems to be yes, but ... And if you take not three items, but sixteen?  And thirty-two? .. Why are the samples more and more distant from the central element s [i] taken with the same weight?  After all, it may be that the relationship between readings will gradually weaken with increasing distance <sup>4</sup> between them? <br><br>  If we consider the example of the pronunciation of the word "watermelon" ten times in a row and try to track the relationship between the samples of the recorded signal, we can find a weakening of the dependence between the more and more distant samples.  Naturally, if we consider the ‚Äúlong distances‚Äù, the sounds will be repeated by repeating the same word and the dependence will increase and decrease again, and so on.  But, as a rule, ‚Äúlong distances‚Äù are not considered when smoothing, since noises appear in the vicinity of individual sounds, and not words, phrases and sentences.  Noise acting at the level of words or even phrases is clearly artificial (sound effects) or exotic natural (echo).  This is already "non-random" noise, which requires a separate study.  Here we consider ‚Äúpure‚Äù noise, which, to put it in simple terms, is annoyingly noisy and in no way resembles any useful signal. <br><br>  Based on simple reasoning, it becomes obvious that the number of terms in (1) (the order of the filter) should depend on how strongly the neighboring samples depend on each other.  For example, it makes no sense to take a filter of the thirtieth order, if only ten counts are observed, following each other.  In fact, it‚Äôs not even that ‚Äúthere‚Äôs no point‚Äù, but it‚Äôs impossible, because if the samples are practically unrelated, then an excessive smoothing of the useful signal will begin (‚Äúdevouring‚Äù syllables).  But the third-order filter here will not be optimal in the degree of use of information about the useful signal, since, as already mentioned, there is a dependence of about ten neighboring samples.  Therefore, you can ‚Äútry your luck‚Äù with the help of a ninth-order filter, naturally, increasing the load on the processor-calculator.  Here it is necessary to determine, most likely experimentally, and is this game worth the candle? .. <br><br>  How to assess how closely related the next samples?  Calculate the autocorrelation function (ACF).  Those who wish can suggest experimenting on the recording of different words, phrases, repeating phrases and the subsequent construction of the ACF (since, for example, the Matlab program allows you to do this without particularly thinking about the code and formulas). <br><br>  So how do you choose the filter coefficients in (1)? <br><br>  In this case, it is convenient to consider the response of the filter to a single impact, that is, to a signal of the form <br><img src="https://habrastorage.org/storage2/88e/f51/126/88ef51126cc78cab8ba4727d69b3505f.png"><br><br>  For example, the filter (1) will give the following response (impulse response) <br><img src="https://habrastorage.org/storage2/824/438/79e/82443879ed0ac6de39a0fe33deeadf18.png"><br>  whence we can conclude that after smoothing the duration of the signal became equal to three elements.  And if you take a filter of five elements? .. Correctly, the duration of the output signal will be equal to five elements.  How useful this is is determined by the specific situation (task). <br><br>  By the way, the long-awaited artifact is already there!  The impulse response (1) is, in fact, a rectangular impulse that is not at all smooth! .. Strange, yes?  And if you take a five-point filter?  Then at the output we get a longer rectangular pulse, but with a smaller amplitude.  It doesn't work out very well ... The simplest test speaks of the unsuitability of simple averaging for smoothing. <br><br>  Let's look at the filter (1) from the frequency side (we have already looked at the time line). <br><br>  If the signal is sound, then it is quite well described by a set of harmonic signals <sup>5</sup> (‚Äúsinusoids‚Äù) and the degree of attenuation of a specific sinusoid depends on its frequency.  Again, with proper selection of a smoothing filter, none of the useful sinusoids should disappear completely, that is, the <b>amplitude-frequency characteristic of the</b> filter in the operating frequency range should be fairly uniform. <br><br>  Let us pass one single-tone signal of a certain frequency through the filter in question, of course, without going beyond the limits of the sampling theorem.  Let the time discretization step <i>T <sub>d</sub></i> be equal to one, that is, the samples go in steps of one second.  Take a signal with frequency <i>f</i> = 1 / (3 <i>T <sub>d</sub></i> ) = 1/3 Hz, i.e. <br><img src="https://habrastorage.org/storage2/94e/524/0bd/94e5240bd1b6ad6b6fcbb2daa977b00c.gif"><br><br>  Confine ourselves to two periods <br><img src="https://habrastorage.org/storage2/92f/471/cd0/92f471cd0801ded8adade0cb55494e57.gif"><br><br>  The response of the filter (1) will be equal to <br><img src="https://habrastorage.org/storage2/cf5/c38/9dd/cf5c389dd6fed39b0a924a3d9a6113a2.png"><br><br>  Strangely enough, they got almost zero ... It turns out that some components of the useful signal can be lost. <br><br>  Check the response to a slightly higher frequency signal. <img src="https://habrastorage.org/storage2/fca/f90/43f/fcaf9043fec33d502371eaf5ee360c69.png"><br><img src="https://habrastorage.org/storage2/296/53f/8d8/29653f8d89c61969e0abac25bf5a125a.png"><br><br>  As you can see, the shape of the signal is not lost.  What's the matter? .. <br><br>  The point is that the amplitude-frequency characteristic of the filter (1) is not monotonous in the working frequency band (in the range from zero to half of the sampling frequency) and has one zero at a frequency three times lower than the sampling frequency.  How to show it? <br><br>  Simply put, to determine the frequency response of the filter, it is necessary to find the ratio of the spectrum at the output of the filter to the spectrum at the input. <br><br>  Denote the spectrum of the signal <i>s</i> [ <i>i</i> ] at the input as <i>S</i> ( <i>f</i> ), then the spectrum of the signal <i>s</i> [ <i>i</i> -1] delayed by one cycle <i>T <sub>d</sub></i> is expressed through the spectrum of the original signal as <br><img src="https://habrastorage.org/storage2/c72/900/f0f/c72900f0f984caa58aee8cf7a5ab9fdd.gif">  (2) <br>  where <i>j</i> is the imaginary unit. <br><br>  The spectrum of the advanced signal <i>s</i> [ <i>i</i> +1] is expressed as <br><img src="https://habrastorage.org/storage2/b26/c87/fe4/b26c87fe45058d633a8611dad7f3d7b5.gif">  (3) <br><br>  What does imaginary unit mean?  And how can you justify (2) and (3)? <br>  If we write the known [1, 2] series for sine, cosine and exponent <br><img src="https://habrastorage.org/storage2/5ce/a38/fd7/5cea38fd765c42afc282a90fb818c2ec.gif">  (four) <br>  then by choosing the number <i>j</i> , such that <i>j</i> <sup>2</sup> = ‚Äì1, the last row can be expressed through the first two <br><img src="https://habrastorage.org/storage2/588/871/d9a/588871d9a2f37485307174bc013143ea.gif">  (five) <br>  which means that any complex number can be written through an exponent with an imaginary index.  The modulus of the number (5) is equal to one (the square root of the sum of squares of the imaginary and real parts), therefore, to write any complex number in the form (5), it must be divided and multiplied by its own module <br><img src="https://habrastorage.org/storage2/ec3/e80/f78/ec3e80f78affdde6e4832e73f5cf9a99.gif">  (6) <br><br>  From (5) and (6) it follows that if in the exponent we can select an imaginary unit multiplied by a real number, then this number is an argument of a complex number. <br><br>  In this case, the signals are considered, therefore the modulus of a complex number corresponds to the amplitude of the harmonic signal, and the argument is the phase.  If, for example, take a signal of the form <br><img src="https://habrastorage.org/storage2/8a5/c8b/13a/8a5c8b13a5241de6c0a727c3982673b8.gif">  (7) <br>  then we can distinguish the amplitude <i>A</i> and the phase F. The multiplier <img src="https://habrastorage.org/storage2/7f1/6a6/8f3/7f16a68f3e3df43cb22149dfd87e80c8.gif">  - It is also a phase, and in some cases it is taken out of the brackets.  For example, when passing a signal (7) through a filter, it is important to know the phase difference between the signals at the input and output, which the filter introduces at a given frequency <i>f</i> . <br><br>  If the signal (7) is delayed by the value of <i>t</i> <sub>0</sub> , then the same signal will be obtained, but shifted in phase by a constant value <br><img src="https://habrastorage.org/storage2/34a/6ee/ffa/34a6eeffa7b41dfac96cceffe9d3433c.gif">  (eight) <br>  that is, when an arbitrary signal is delayed, all its frequency components are shifted in phase by an amount depending on the current frequency and the delay value.  This may explain formulas (2) and (3).  Therefore, when analyzing any algorithm, the <b>phase-frequency characteristic</b> is also important, which shows how long the filter (algorithm) delays each frequency component of the input signal.  Low frequencies and high frequencies will generally have a different delay in the filter. <br><br>  From (1), (2) and (3) it follows that the frequency response of the filter (transfer function) will be <br><img src="https://habrastorage.org/storage2/448/8ea/daf/4488eadaf2b1f4195f89515a0de28359.gif">  (9) <br><br>  Since the spectrum of the output signal is linearly expressed through the spectrum of the input signal, then at the output (9) the spectrum of the input signal is successfully reduced.  Further, we note that the frequency response of the filter (1) is real, that is, this filter does not introduce phase distortion <sup>6</sup> .  We achieved this (most likely, unconsciously) due to the symmetry of formula (1): each count at the output of the filter is equal to the sum of the current and two adjacent samples. <br><br>  Physically, such an algorithm is realizable only in the presence of storage devices, since it uses advance readings (to calculate the readout <i>s</i> [ <i>i</i> ], the readout <i>s</i> [ <i>i</i> +1] is required).  Currently, this is not a big problem and, as a rule, use symmetric algorithms.  If phase distortions will be useful, then - please, the main thing is to consciously apply any algorithm and look at it from different angles: from frequency and time. <br><br>  It is easy to build a graph of dependence (9) on frequency.  For simplicity, the normalized frequency <i>f</i> <sub>0</sub> = <i>f T <sub>d</sub></i> is entered, the useful range of which is [0 ... 0.5].  Signal components with frequencies above half the sampling frequency should be absent according to the sampling theorem (before digitizing, the signal is passed through the appropriate low-pass filters).  The sampling rate indicates the number of readings by the digital device per second.  If, for example, one clock cycle <i>T <sub>d</sub></i> is equal to one millisecond, then a thousand samples should be returned in one second. <br><br>  Analyzing (9) it can be noted that the transmission coefficient is at a certain interval less than zero, and the amplitude is by definition a positive quantity ... The way out is to build the transfer function modulus by removing the minus sign in the phase characteristic, which, nevertheless, is not a constant (zero).  If we take the number "minus one", then it can be represented by the formula (5) as <br><img src="https://habrastorage.org/storage2/2ac/051/2f4/2ac0512f4004e122f4f2595cf82ca70e.gif">  (ten) <br>  that is, a complex number having the unit ‚Äúunit‚Äù and the phase ‚Äú180 degrees‚Äù (‚Äúpi‚Äù). <br><br>  Thus, the three-point symmetric algorithm (1) for some ‚Äúhigh‚Äù frequencies introduces a phase shift of 180 degrees, that is, it simply inverts the input signal.  This effect can be noticed by analyzing the response considered above to the normalized frequency of 2/5 Hz. <br><br><img src="https://habrastorage.org/storage2/778/7c0/323/7787c0323449fe552509dd7d0d0c3cf3.png"><br>  <i>Fig.</i>  <i>1. Amplitude-frequency and phase-frequency characteristics of a three-point symmetric smoothing algorithm</i> (1) <br><br>  From fig.  1 immediately follows that a signal with a frequency of 1/3 will be suppressed by this algorithm, and signals having a frequency higher than 1/3 will be inverted.  Thus, the useful working frequency range can be safely reduced from [0 ... 0.5] to [0 ... 1/3].  If we are not satisfied with the rapid decay of the transmission coefficient, we will have to determine another algorithm that has a more rectangular amplitude-frequency characteristic and, at the same time, it is not yet known what phase ... <br><br>  In essence, the obtained non-monotonic frequency response is a consequence of the rectangular shape of the impulse response ..., 0, 0, ..., 1/3, 1/3, 1/3, 0, 0, ....  Therefore, the impulse response is an easy way to notice gross flaws in the algorithms.  The frequency response, despite some difficulty in calculating it, is convenient in that it allows you to notice and correct more subtle flaws than we do. <br><br>  If we now write algorithm (1) in a more general form <br><img src="https://habrastorage.org/storage2/e5a/507/26a/e5a50726a975e497a0c3e4b637bd696e.gif">  (eleven) <br>  then, based on the knowledge of the frequency response, you can try to choose the coefficients so <br>  so that the amplitude-frequency characteristic becomes monotonous in the working frequency range (0 ... 0.5).  For this, at least, the absence of zeros within the working range is necessary. <br><br>  Since we have no reason to single out the delayed reading <i>s</i> [i ‚Äì 1] with respect to the leading <i>s</i> [i + 1], we equate the coefficients <i>a</i> <sub>1</sub> and <i>a</i> <sub>3</sub> .  After we write down the transfer coefficient <br><img src="https://habrastorage.org/storage2/805/06f/29f/80506f29fe900602d81d0fe7a07e442b.gif">  (12) <br><br>  We will try to move the first zero to the frequency <i>f</i> <sub>0</sub> = 0.5.  For this, the equality a <sub>2</sub> = 2a <sub>1</sub> must be satisfied, that is, the weight of the side samples must be two times less than the weight of the central one.  Then a more optimal algorithm will look like this. <br><img src="https://habrastorage.org/storage2/160/3c6/627/1603c6627f416752148e8acfd92da0b7.gif">  (13) <br><br>  How to choose in (13) a single coefficient <i>a</i> <sub>1</sub> ? <br><br>  Let's look at algorithm (13) from the point of view of the <b>impulse transient characteristic</b> .  For this we find the response to a single jump <img src="https://habrastorage.org/storage2/7d6/4b1/21a/7d64b121a46913d243582478509976ad.gif">  : <br><img src="https://habrastorage.org/storage2/3ab/e06/6ac/3abe066ac89ce37c2a775399a1607b92.gif">  (14) <br><br>  As you can see, in order to maintain the output amplitude in the steady state, equal to one, you need to choose the coefficient a <sub>1</sub> = 1/4.  That is, the sum of all coefficients must be equal to one. <br><br>  Finally, for the finished algorithm <br><img src="https://habrastorage.org/storage2/827/0ce/f3b/8270cef3b56b2e5b2e76ce6df03146f9.gif">  (sixteen) <br>  You can build (Fig. 2) frequency characteristics: amplitude and phase. <br><br><img src="https://habrastorage.org/storage2/50f/4cf/7d9/50f4cf7d938b34b2b710063067c97a0e.png"><br>  <i>Fig.</i>  <i>2. Amplitude-frequency and phase-frequency characteristics of a three-point symmetric smoothing algorithm (16)</i> <br><br>  Analysis of fig.  2 shows that the phase distortions have disappeared, and the amplitude characteristic has become monotonous in the working frequency band [0 ... 0.5].  In a sense, we squeezed out of the three-point filter "everything". <br><br>  Now it becomes obvious that simple averaging is by no means always optimal, especially when there are a lot of averaged samples. <br><br><h4>  Images </h4><br><br>  As for the images, here to some extent everything is the same as for the signals: amplitude and phase distortions, impulse characteristics, signal energy, the main difference is that matrices are used instead of vectors.  It should also be noted that for images there is no time coordinate, but there is a coordinate of space, therefore there are spatial sampling rates.  This difference is rather formal, since it does not affect the mathematics of algorithms at all. <br><br>  Let us now consider the ‚Äúsimplest‚Äù algorithm for smoothing an image by neighboring points (Fig. 3).  Count <i>v</i> <sub>00</sub> at the output of the filter <br><img src="https://habrastorage.org/storage2/941/e54/e65/941e54e65d514db52432308ac19b69c6.gif">  (17) <br><br><img src="https://habrastorage.org/storage2/1d0/072/176/1d007217671352f6f974eb404cf1ece0.png"><br>  <i>Fig.</i>  <i>3. Scheme of smoothing the image by neighboring points</i> <br><br>  In formula (17), the three terms <i>A</i> , <i>B,</i> and <i>C</i> are specially distinguished, since the four corresponding internal terms of <i>B</i> and <i>C</i> have their own distances from the central reference <i>s</i> <sub>00</sub> .  It is natural to assume here that the maximum weight will be for the term <i>A</i> , then in descending order - for <i>B</i> and <i>C.</i> <br><br>  For images, the spectrum and transmission coefficient will be two-dimensional, that is, they will depend on two frequencies: the first frequency - horizontally, the second - vertically (everything is conditional here, for definiteness). <br><br>  The filter (17) has the following transfer coefficient <br><img src="https://habrastorage.org/storage2/433/1b6/c0c/4331b6c0c8161149f10f48e7dff5c98a.gif">  (18) <br><br>  If we take, for example, about thirty discrete frequencies and construct (Fig. 4) a contour plot of the frequency response module (18), then we can see distortions similar to those in Fig.  1. The bottom left corner correspond to the lowest frequencies.  There is a failure of the frequency response at frequencies that are 1/3 of the sampling frequency (in this case, the sampling frequency is 64 in both coordinates). <br><br><img src="https://habrastorage.org/storage2/2d6/438/a6f/2d6438a6f6c578919e66bdfc60b2e88a.png"><br>  <i>Fig.</i>  <i>4. Amplitude-frequency characteristic of nine-point symmetric smoothing algorithm</i> (17) <br><br>  Shuffling coefficients for samples in Fig.  3, you can get the following smoothing algorithm <br><img src="https://habrastorage.org/storage2/e76/55e/56a/e7655e56a766e11ffd7c8cd7ed14d45d.gif">  (nineteen) <br><br>  And if a single impact is placed in the center of the image, then the response of the filter (19) will look like <br><img src="https://habrastorage.org/storage2/8eb/bd9/bc4/8ebbd9bc4f7196286a449c30751d0d81.gif">  (20) <br><br>  In fact, (20) is the impulse response of the filter (these are the nine main samples, since the others are zero).  The sum of all counts of the impulse response is equal to one.  The frequency response of the filter (19) has the form shown in Fig.  five. <br><br><img src="https://habrastorage.org/storage2/270/5e9/e07/2705e9e07bed10bf92403c5f0f63429c.png"><br>  <i>Fig.</i>  <i>5. Amplitude-frequency characteristic of nine-point symmetric smoothing algorithm</i> (19) <br><br>  Again we see (compare Fig. 4 and Fig. 5) the improvement of the ordinary averaging algorithm. <br><br><h4>  Summary </h4><br><br>  When developing digital signal processing algorithms (smoothing and not only) one should not trust intuitive algorithms like simple averaging. <br><br>  A more general approach is the weight summation technique (only linear algorithms were considered, when samples are only multiplied by constants, and the results are added). <br><br>  Weight summation, when weights are placed more distant from the central element of the readings, is justified both statistically (the natural nature of the weakening of dependence with distance) and functionally (it is possible to choose coefficients strictly mathematically, ensuring the monotonicity of the amplitude-frequency characteristic). <br><br>  A large role is played by the amplitude-frequency characteristics of the filters, which are determined by the weighting sum coefficients.  They allow us to prove that a given filter passes a certain frequency range and blocks another.  Moreover, it is possible to determine the unevenness in the passband, in the stopband, and so on.  The greater the order of the filter, the more degrees of freedom and the better you can choose the shape of the amplitude-frequency characteristic. <br><br>  An important role is played by the phase-frequency characteristics, which are mainly determined by the degree of symmetry of the algorithm.  Real-time algorithms, when the countdown at the filter output appears at the moment of arrival of the first sample, cannot provide a uniform phase response (constant, most often ‚Äúzero‚Äù), since they cannot be symmetrical.  Such algorithms introduce a delay into the input signal: for example, a smoothed image can generally shift along both coordinates.  If the image is complex (that is, it has many frequency components), then its phase distortions can distort it noticeably, and not just shift it along the coordinates, which is approximately true for simple images. <br><br>  You should also pay attention to the impulse response of the filter corresponding to a certain algorithm.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This allows a simple way to look at the operation of the filter directly, that is, in the time scale for the signal or in the scale of spatial coordinates - for the image. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, an energy analysis of the algorithm is needed, which allows determining the signal loss at the output of the corresponding filter. This analysis is conveniently carried out within the framework of the impulse transient response.</font></font><br><br><h4>  Footnotes </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Always with losses, since the frequency of operation and the digit capacity of digital devices are limited </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. The average stabilizing property is valid if the characteristics of the random number generator are constant, that is, ideally, the generator should produce a random value with a given distribution law </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. If, of course, the observed noise - this is not an encrypted useful signal, which becomes random for those who do not have a key ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. For a sound signal, the distance between samples is a certain time interval </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. We can assume that any oh signal can be represented as a sum of sinusoids of multiple frequencies, but sound in nature is obliged to "well" decompose in a series of frequencies </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6. Simplifiedly, you can say so, for details see below</font></font><br><br><h4>  Sources </h4><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Trigonometric functions [Electronic resource], access mode: free, </font></font><a href="http://ru.wikipedia.org/wiki/%25D2%25F0%25E8%25E3%25EE%25ED%25EE%25EC%25E5%25F2%25F0%25E8%25F7%25E5%25F1%25EA%25E8%25E5_%25F4%25F3%25ED%25EA%25F6%25E8%25E8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ru.wikipedia.org/wiki/%D2%F0% E8% E3% EE% ED% EEC% E5% F2% F0% E8% F7% E5 % F1% EA% E8% E5_% F4% F3% ED% EA% F6% E8% E8</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2. Exhibitor [Electronic resource], access mode: free, </font></font><a href="http://ru.wikipedia.org/wiki/%25DD%25EA%25F1%25EF%25EE%25ED%25E5%25ED%25F2%25E0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ru.wikipedia.org/wiki/%DD%EA%F1% EF% EE% ED% E5% ED% F2% E0</font></font></a> </div><p>Source: <a href="https://habr.com/ru/post/184728/">https://habr.com/ru/post/184728/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../184718/index.html">GoPro history + Hero 3 Black Edition review</a></li>
<li><a href="../184720/index.html">‚ÄúHappy Autumn‚Äù: Happy Farm announces a competition of IT startups - residents of the third cycle</a></li>
<li><a href="../184722/index.html">Three useful monads</a></li>
<li><a href="../184724/index.html">Ragdoll physics do-it-yourself. Part one</a></li>
<li><a href="../184726/index.html">The game on JavaScript "Corners"</a></li>
<li><a href="../184730/index.html">Introduction to Lightweight modular staging and Scala virtualized</a></li>
<li><a href="../184732/index.html">Writing ORM for Delphi</a></li>
<li><a href="../184734/index.html">The site Boeing the opportunity to track the position of the aircraft is almost like in the simulator</a></li>
<li><a href="../184736/index.html">Digg Reader "Almost Ready"</a></li>
<li><a href="../184738/index.html">Work with cURL on android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>