<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How isometric worlds are created</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all played amazing isometric games , be it the first Diablo, Age of Empires or Commandos. When you first meet with an isometric game, you can ask y...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How isometric worlds are created</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/98f/0a5/583/98f0a55831dcb6d0cc48ab9421f4225e.png" alt="image"><br><br>  We all played amazing <em>isometric games</em> , be it the first Diablo, Age of Empires or Commandos.  When you first meet with an isometric game, you can ask yourself: is it <em>two-dimensional</em> , <em>three-dimensional,</em> or something completely different.  The world of isometric games itself has a magical appeal to developers.  Let's try to solve the mystery of isometric projection and create a simple isometric level. <br><br>  For this, I decided to use <a href="https://phaser.io/" rel="external">Phaser</a> with code on JS.  The result is an interactive HTML5 application. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Please note that this is not a Phaser development tutorial, we simply use it to easily familiarize yourself with the basic concepts of creating an isometric scene.  In addition, Phaser has easy ways to create isometric content, such as the <a href="http://rotates.org/phaser/iso/" rel="external">Phaser Isometric Plugin</a> . <br><br>  To simplify the creation of the scene, we will use tiles. <br><a name="habracut"></a><br><h2>  1. Games based on tiles </h2><br>  In two-dimensional tile games, each visual element is broken into small pieces of standard size, called tiles.  From such tiles, based on the level data (usually a two-dimensional array), the game world is formed. <br><br>  Most often in tile games used <em>top</em> or <em>side view</em> .  Let's present a standard two-dimensional view from above with two tiles - a <em>grass</em> <em>tile</em> and a <em>wall tile</em> shown in the figure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4e9/ded/199/4e9ded199c959094cc5503694f2a8335.png"><br><br>  Both of these tiles are square images of the same size, that is, the <em>height</em> and <em>width of the</em> tiles are the same.  Suppose that the level of the game is a lawn bounded on all sides by walls.  In this case, the level data is such a two-dimensional array: <br><br><pre><code class="javascript hljs">[ [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] ]</code> </pre> <br>  Here, <code>0</code> is the grass tile, and <code>1</code> is the wall tile.  Placing the tiles according to the level data, we will create a fenced lawn shown in the figure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/668/31a/088/66831a0887c3a5b40560e9052e2f367c.png"><br><br>  You can take another step and add corner tiles, as well as separate tiles of vertical and horizontal walls.  This will require five additional tiles, in addition, you will have to change the level data: <br><br><pre> <code class="javascript hljs">[ [<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>] ]</code> </pre> <br>  See the image below, where I marked the tiles with numbers corresponding to their values ‚Äã‚Äãin the level data: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/703/a52/c39/703a52c393c2be98f52df2a510f9a7c1.png"><br><br>  We have dealt with the concept of tile levels, let's now look at how to use simple pseudo-code of a two-dimensional grid to assemble our level: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, loop through rows) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j, loop through columns) x = j * tile width y = i * tile height tileType = levelData[i][j] placetile(tileType, x, y)</code> </pre> <br>  If we use the above image tiles with equal width and height, then we get the same level dimensions.  If the width and height of the tile in our example are 50 pixels, then the total size of the level will be 300 by 300 pixels. <br><br>  As mentioned above, tiles are usually used in games with a top or side view.  For an isometric view, we need to implement <em>an isometric projection</em> . <br><br><h2>  2. Isometric projection </h2><br>  The best technical explanation for <em>isometric projection</em> , I think, is given in this <a href="http://flarerpg.org/tutorials/isometric_intro/">article by Clint Bellanger</a> : <blockquote>  We tilt the camera in two axes (turn the camera 45 degrees sideways, then 30 degrees down).  This creates a rhombic grid, in which the width of the cells is twice the height.  This style has become popular due to strategic games and action-RPG.  If we look at the cube in this form, we see its three sides (the top and two sides). </blockquote><br>  Although this sounds a bit tricky, the implementation of this type is quite simple.  We need to understand how two-dimensional and isometric spaces correspond, that is, to understand the relationship between the level data and the view.  We need to convert the <em>Cartesian</em> coordinates of the top view into isometric coordinates.  The figure below shows a graphical transformation: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/83b/4a2/6a5/83b4a26a5855b2733610faf7aedf9ea4.jpg"><br><br><h3>  Isometric tile placement </h3><br>  Let us try to simplify the connection between the level data stored in a two-dimensional array and the isometric view, that is, the process of converting Cartesian coordinates to isometric.  We will create an isometric view for our fenced lawn.  The two-dimensional implementation of this level was a simple two-cycle iteration, arranging square tiles offset by their width and height.  For an isometric view, the pseudocode remains the same, but the <code>placeTile()</code> function changes. <br><br>  The original function simply draws the images of the tiles in the <code>x</code> and <code>y</code> passed to it, and for the isometric view we need to calculate the corresponding isometric coordinates.  The equations for this are presented below.  <code>isoX</code> and <code>isoY</code> represent the isometric coordinates X and Y, and <code>cartX</code> and <code>cartY</code> are the Cartesian coordinates X and Y: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     : isoX = cartX - cartY; isoY = (cartX + cartY) / 2;</span></span></code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     : cartX = (2 * isoY + isoX) / 2; cartY = (2 * isoY - isoX) / 2;</span></span></code> </pre> <br>  Yes, that's all.  These simple equations create the magic of isometric projection.  Here are Phaser utility functions that can be used to convert from one system to another using the very convenient <code>Point</code> class: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cartesianToIsometric</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cartPt</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempPt=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point(); tempPt.x=cartPt.x-cartPt.y; tempPt.y=(cartPt.x+cartPt.y)/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (tempPt); }</code> </pre> <br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isometricToCartesian</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">isoPt</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempPt=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point(); tempPt.x=(<span class="hljs-number"><span class="hljs-number">2</span></span>*isoPt.y+isoPt.x)/<span class="hljs-number"><span class="hljs-number">2</span></span>; tempPt.y=(<span class="hljs-number"><span class="hljs-number">2</span></span>*isoPt.y-isoPt.x)/<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (tempPt); }</code> </pre> <br>  So, we can use the auxiliary <code>cartesianToIsometric</code> method to convert input 2D coordinates to isometric inside the <code>placeTile</code> method.  Except for this, the display code remains the same, but we need to create new tile images.  We cannot use old square tiles from the top view.  The figure below shows the new isometric tiles of grass and walls along with the finished isometric level: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/761/309/d5d/761309d5dea39d5403ba432d9177befe.png"><br><br>  Incredible, right?  Let's see how the usual two-dimensional position is converted to isometric: <br><br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">2</span></span>D point = [<span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//      isoX = 100 - 100; // = 0 isoY = (100 + 100) / 2; // = 100 Iso point == [0, 100];</span></span></code> </pre> <br>  That is, the input data <code>[0, 0]</code> converted to <code>[0, 0]</code> , and <code>[10, 5]</code> - to <code>[5, 7.5]</code> . <br><br>  For our fenced lawn, we can determine the passable areas by checking whether the value of the element of the array is equal to <code>0</code> in the desired coordinate.  If equal, then this is grass.  To do this, we need to determine the coordinates of the array.  We can find the coordinates of a tile in the level data from its Cartesian coordinates using this function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTileCoordinates</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cartPt, tileHeight</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempPt=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point(); tempPt.x=<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(cartPt.x/tileHeight); tempPt.y=<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(cartPt.y/tileHeight); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(tempPt); }</code> </pre> <br>  (Here we assume that the height and width of the tile are the same, as happens in most cases.) <br><br>  That is, knowing the pair of screen (isometric) coordinates, we can find the coordinates of the tile by calling the function: <br><br><pre> <code class="javascript hljs">getTileCoordinates(isometricToCartesian(screen point), tile height);</code> </pre> <br>  This point on the screen can be, say, the position of the mouse cursor or the item being picked up. <br><br><h3>  Registration Points </h3><br>  In Flash, you can choose arbitrary graphics points as a base point or <code>[0,0]</code> .  An analogue of this in the Phaser is the <code>Pivot</code> .  When we have the graphics, say, at point <code>[10,20]</code> , then this point <code>Pivot</code> corresponds to <code>[10,20]</code> .  By default, <code>[0,0]</code> or <code>Pivot</code> is considered the left upper point.  If you try to create the level above using this code, you will not get the desired result.  Instead, you will have a flat land without walls, as shown below: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1f/307/03b/b1f30703b5971c986f2283ab3a848572.png"><br><br>  This is because the tile images are of different sizes, and we do not take into account the height attribute of the wall tile.  The figure below shows the different tile images we use and the white circle, in which by default they are [0,0]: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/546/2b6/a44/5462b6a446ff1031cc7324b361d972cc.png"><br><br>  Note that when using base points (Pivot), by default the hero is in the wrong place.  Also note that we lose the height of the wall when we draw it with the base point by default.  The picture on the right shows how they should be positioned correctly so that the height of the wall tile is taken into account and the hero is in the middle of the grass tile.  This problem can be solved in different ways. <br><br><ol><li>  Make the sizes of the images of all the tiles the same, and correctly place the graphics in the image.  At the same time, in each tile image, many empty areas are created. </li><li>  Manually set the base point for each tile so that they are positioned correctly. </li><li>  Draw tiles with a certain offset. </li></ol><br>  For this tutorial, I chose the third method, because it will work even in a framework in which you cannot change the base points. <br><br><h2>  3. Motion in isometric coordinates </h2><br>  You should never move characters or objects in isometric coordinates directly.  Instead, we will manage the data of the game world in Cartesian coordinates and simply use the above functions to update the position on the screen.  For example, if we want to move a character forward in the positive direction along the Y axis, then we can simply increase its <code>y</code> property in two-dimensional coordinates, and then convert the final position to isometric coordinates: <br><br><pre> <code class="javascript hljs">y = y + speed; placetile(cartesianToIsometric(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point(x, y)))</code> </pre> <br>  Let's summarize all the new concepts that we have studied, and try to implement a working example of an object moving in an isometric world.  You can use the necessary graphical resources from the <code>assets</code> folder in <a href="https://github.com/juwalbose/Isometric-Theory-Phaser">the</a> git source code <a href="https://github.com/juwalbose/Isometric-Theory-Phaser">repository</a> . <br><br><h3>  Depth sorting </h3><br>  If you tried to move the image of the ball in a fenced garden, you noticed problems with <em>sorting by depth</em> .  If there are moving elements in the isometric world, then besides the usual location, we need to take care of the <em>sorting by depth</em> .  Proper sorting ensures that objects closer to the screen will be drawn on top of more distant objects.  As mentioned in <a href="http://gamedev.tutsplus.com/tutorials/implementation/cheap-and-easy-isometric-levels/">this article</a> , the simplest sorting method is to use the Cartesian Y coordinate: the higher the object is on the screen, the sooner it should be drawn.  This may work well for simple isometric scenes, but it would be better to redraw the entire isometric scene while moving according to the coordinates of the tile in the array.  Let me explain this approach in detail using the pseudocode for drawing a level: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, loop through rows) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (j, loop through columns) x = j * tile width y = i * tile height tileType = levelData[i][j] placetile(tileType, x, y)</code> </pre> <br>  Imagine that an object or character is on a tile <code>[1,1]</code> , that is, on the topmost green tile in an isometric form.  For the level to be properly drawn, the character needs to be drawn after the corner tile of the wall, the left and right tile of the wall, and the ground are drawn, as shown in the figure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b99/783/124/b99783124b6923eae6b29dbaf4d4c279.png"><br><br>  If we perform the rendering cycle in accordance with the pseudocode, the middle corner wall will be drawn first, then the cycle will continue to draw all the walls in the upper right part until it reaches the right corner.  In the next cycle, he will draw a wall to the left of the character, and then a grass tile on which the character stands.  Since we have determined that this is the tile that the character takes, we draw the character <em>after the</em> grass tile.  Thus, if on the free three tiles of the grass next to the character's tile there were walls, then these walls would overlap the character, ensuring correct sorting by depth. <br><br><h2>  4. Creating graphics </h2><br>  Isometric graphics can, but need not be, pixel art.  When working with isometric pixel art, it is useful to study <a href="http://www.gotoandplay.it/_articles/2004/10/tcgtipa.php">the RhysD manual</a> , which contains everything you need.  The theory can be studied in <a href="https://ru.wikipedia.org/wiki/%25D0%2598%25D0%25B7%25D0%25BE%25D0%25BC%25D0%25B5%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0_%25D0%25B2_%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D1%2580%25D0%25BD%25D1%258B%25D1%2585_%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0%25D1%2585">Wikipedia</a> . <br><br>  When creating isometric graphics, you need to follow the following rules: <br><br><ul><li>  Start with an empty isometric grid and stick to it with pixel-by-pixel accuracy. </li><li>  Try to break the graphics into simple isometric tile images. </li><li>  Make each tile <em>passable</em> or <em>impassable</em> .  Otherwise it will be difficult to work with tiles containing both passable and impassable areas. </li><li>  Most tiles should be seamless so that they can level the level in any direction. </li><li>  Shadows are difficult to create if you do not use a solution with layers, in which the shadows are first drawn on the ground layer, and then the character is drawn on the upper layer (or trees and other objects).  If you do not use several layers, then make sure that the shadows fall forward and, for example, do not cover the hero standing behind the tree. </li><li>  If you need to use a tile image larger than the standard size of an isometric tile, then try to choose a size that is a multiple of the standard tile size.  In such cases, it is better to use layers so that you can cut the graphics into different pieces depending on its height.  For example, a tree can be cut into three parts - the root, the trunk and the foliage.  So it will be easier to sort the depths, because it will be possible to draw parts in the corresponding layers that correspond to their heights. </li></ul><br>  Isometric tiles larger than a single tile size cause problems when sorting by depth.  Such problems are discussed in the following articles: <br><br><h4>  Posts on the topic </h4><br><ul><li>  <a href="http://stackoverflow.com/questions/11166667/isometric-depth-sorting-issue-with-big-objects">Bigger tiles</a> </li><li>  <a href="http://gamedev.stackexchange.com/questions/44966/isometric-drawing-order-with-larger-than-single-tile-images-drawing-order-algo">Splitting and Painter's algorithm</a> </li><li>  <a href="http://www.openspace-engine.com/support/tutorials/mapStructure">Splash up larger tiles</a> </li></ul><br><h2>  5. Isometric characters </h2><br>  First we need to decide on the directions in which we can move in our game.  Usually in games it is allowed to move in four or eight directions.  Look at the figure below to understand the connection between two-dimensional and isometric space: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5e0/5cb/d34/5e05cbd34b170c4429ea17919dad7913.png"><br><br>  Please note that in a game with a top view, when you press the <strong>up</strong> key, the character will move vertically upwards, but in an isometric game, it will move at a 45 degree angle towards the upper right corner. <br><br>  For the top view, we can create one set of animations of a character looking in one direction, and then just rotate all the animations.  For an isometric character's graphics, you need to create an animation for each of the allowed directions, that is, to move in eight directions, you need to create eight animations for each action. <br><br>  For ease of understanding, directions are commonly referred to as ‚Äúnorth,‚Äù ‚Äúnorth-west,‚Äù ‚Äúwest,‚Äù and so on.  In the frames of the character in the picture are shown frames of a fixed position, starting from the southeast and clockwise: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18b/ec6/bdb/18bec6bdb750f9a5a2061dd7a07c75af.png"><br><br>  We will have the characters in the same way as the tiles.  The movement of the character is performed by calculating the Cartesian coordinates and converting them into isometric ones.  Suppose you use a keyboard to control a character. <br><br>  We will assign two variables, <code>dX</code> and <code>dY</code> , the value of which depends on the control keys pressed.  By default, these variables are equal to <code>0</code> , and the values ‚Äã‚Äãare assigned to them according to the table below, where <code></code> , <code></code> , <code></code> and <code></code> mean, respectively, the <strong>upper</strong> , <strong>lower</strong> , <strong>right</strong> and <strong>left</strong> direction keys.  A value of <code>1</code> under the key indicates that the key is pressed, <code>0</code> means that it is not pressed. <br><br><pre> <code class="javascript hljs">      dX dY ================ <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span></code> </pre> <br>  Now, using the <code>dX</code> and <code>dY</code> we can update the Cartesian coordinates as follows: <br><br><pre> <code class="javascript hljs">newX = currentX + (dX * speed); newY = currentY + (dY * speed);</code> </pre> <br>  So, <code>dX</code> and <code>dY</code> are a change in the position of the character in X and Y, depending on the keystrokes.  As stated above, we can easily calculate new isometric coordinates: <br><br><pre> <code class="javascript hljs">Iso = cartesianToIsometric(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point(newX, newY))</code> </pre> <br>  Having received a new isometric position, we must <em>move the</em> character to this position.  Based on the <code>dX</code> and <code>dY</code> we can understand in which direction the character is looking and use the appropriate animation.  After moving the character, do not forget to redraw the level with the appropriate sorting by depth, because the character's tile coordinates may change. <br><br><h3>  Collision detection </h3><br>  Collision detection is performed by checking whether the tile in the new computed position of the object is impassable.  So, after finding a new position, we can‚Äôt immediately move a character there, we first need to check what kind of tile it takes. <br><br><pre> <code class="javascript hljs">tile coordinate = getTileCoordinates(isometricToCartesian(current position), tile height); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isWalkable(tile coordinate)) { moveCharacter(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  ; }</span></span></code> </pre> <br>  In the <code>isWalkable()</code> function, we check whether the value of the level data array in the given coordinate is passable.  We also need to update the direction in which the character is looking, <em>even if he is not moving</em> , in case he is confronted with an impassable tile. <br><br>  This looks like the right solution, but it will only work for objects without a volume.  To calculate collisions, we consider only one point (the center point of the character).  In fact, we need to find all four angles from a given two-dimensional center point and calculate the collisions for all these angles.  If any of the corners falls into an impassable tile, then the character cannot be moved. <br><br><h3>  Depth sorting with characters </h3><br>  Consider a character and a tree tile in an isometric world that <em>have the same image size</em> , no matter how unnatural it looks. <br><br>  To understand the depth sorting well, we need to understand that when the X and Y coordinates of a character are smaller than those of a tree, the tree overlaps the character.  When the X and Y coordinates of a character are larger than those of a tree, the character overlaps the tree.  When their X coordinates are equal, then the decision is made only on the Y coordinate: an object with a higher Y coordinate overlaps another one.  If the Y coordinates coincide, then the decision is made only on X: an object with a large X overlaps another. <br><br>  As mentioned above, the simplified version of the algorithm consists in a simple drawing of levels from distant tiles (ie, <code>tile[0][0]</code> ) to neighbors, line by line.  If a character takes a tile, first we draw a land tile, and then draw the character tile.  This will work well because the character cannot occupy the tile walls. <br><br><h2>  6. Time for a demo! </h2><br>  Here is a Phaser <a href="https://jsfiddle.net/juwalbose/w1tnu9qc/">demo</a> .  Click the mouse to switch to the interactive area, and then control the character with the arrow keys.  To move diagonally, press two keys. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  7. Collected items </h2><br>  Assembled objects are objects that can be picked up at a level, usually just stepping on them.  For example, it could be coins, crystals, ammunition, etc. <br><br>  Item data can be stored directly in the level data, as shown below: <br><br><pre> <code class="javascript hljs">[ [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] ]</code> </pre> <br>  In this level data, we use <code>8</code> to denote an object on a grass tile ( <code>1</code> and <code>0</code> , as before, denote grass and walls).  This can be a tile image with a grass tile on which an image of an object is superimposed.  According to this logic, we will need two different states of the tile for each tile on which the item may be located: one with the item, and the other without it, which is displayed after receiving the item. <br><br>  Usually in isometric graphics there are many passable tiles.  Suppose we have 30 of them. If we use the above approach, then if we have N lifted items, we will need N x 30 to the existing 30 tiles. This is not very efficient.  Therefore, we should create such combinations dynamically.  To solve this problem, you can use the same method that we used above to place your character.  When we get to the tile with the item, we first draw the grass tile, and then place the item on it.  Thus, in addition to the 30 passable tiles, we need all N tiles of items, but we will need numerical values ‚Äã‚Äãto denote each combination in the level data.  In order not to enter N x 30 values, you can store a separate <code>pickupArray</code> array for storing data about objects, separate from <code>levelData</code> .  The finished level with the item is shown below: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/813/1b2/7d5/8131b27d5937cbf7e50e1593a9e89014.png"><br><br>  In our example, I will make it easier and will not use a separate array for objects. <br><br><h3>  Collecting items </h3><br>  Object recognition is performed in the same way as collision detection, but <em>after</em> moving a character. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(onPickupTile()){ pickupItem(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPickupTile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{<span class="hljs-comment"><span class="hljs-comment">//,        return (levelData[heroMapTile.y][heroMapTile.x]==8); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the function </font></font><code>onPickupTile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we check whether the value of the array </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the coordinate is </font></font><code>heroMapTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tile with the object. The number in the array </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the coordinate of this tile indicates the type of item. We check the collisions before moving the character, but checking the items is done after: in the case of collisions, the character will not be able to take a point if she is already occupied by an impassable tile, and in the case of items the character can move to the tile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also worth noting that collision data usually never changes, and object data changes when we pick up an item. (This usually just changes the value in the array </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, for example, from </font></font><code>8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This leads to the problem: what happens when we need to restart the level, that is, to restore all the objects at their initial points? We have no information for this, because the array </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changes when the object is picked up. The solution is to use a copy of the array level in the game and save the constant array </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. For example, we use </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>levelDataLive[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">clone the last of the first one at the beginning of the level, and then change it during the game only </font></font><code>levelDataLive[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, I create a random item on a free grass tile after each assembled item and increase the value </font></font><code>pickupCount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The function is </font></font><code>pickupItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pickupItem</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ pickupCount++; levelData[heroMapTile.y][heroMapTile.x]=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    spawnNewPickup(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You probably noticed that we check the availability of items always when the character is on the tile. </font><font style="vertical-align: inherit;">This can happen several times a second (we check only when the user moves, but we can repeat it over and over again in one tile), but the above logic will be executed without error. </font><font style="vertical-align: inherit;">Once we assign the array data </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">value </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the first detection of lifting the object, all subsequent checks </font></font><code>onPickupTile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will return to the tile </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">See </font></font><a href="http://jsfiddle.net/juwalbose/gvso9w0m"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> interactive example.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Trigger Tiles </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As the name implies, trigger tiles trigger some actions when a player steps on them or presses a key on them. They can teleport the player to another location, open the gate, create enemies, and so on. In a sense, collected items are simply a special type of trigger: when a player steps on a coin tile, the coin disappears and the coin counter increases. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's see how you can realize the door that takes the player to another level. The tile next to the door will trigger. When a player presses the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> key </font><font style="vertical-align: inherit;">, it moves to another level. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/57a/446/98c/57a44698ca9b7cb42db1407d9b170548.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To change levels, you just need to replace the current array </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with an array of a new level, and then assign a new position and direction</font></font><code>heroMapTile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">character. </font><font style="vertical-align: inherit;">Suppose there are two levels with doors through which you can pass. </font><font style="vertical-align: inherit;">Since the land tile next to the door will be the active tile in both levels, you can use it as a new character position appearing on the level. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The logic of implementation here is the same as for the collected items. </font><font style="vertical-align: inherit;">To store the values ‚Äã‚Äãof the trigger tiles, we again use an array </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In our example, it </font></font><code>2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will mean a tile with a door, and the value next to it will be a trigger. </font><font style="vertical-align: inherit;">I used </font></font><code>101</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>102</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, having decided that any tile with a value greater than 100 will be the active tile, and the value minus 100 will be the level to which it leads:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> level1Data= [[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">102</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> level2Data= [[<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">101</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>], [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>]];</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The test code for the trigger trigger event is shown below: </font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xKey=game.input.keyboard.addKey(Phaser.Keyboard.X); xKey.onUp.add(triggerListener);<span class="hljs-comment"><span class="hljs-comment">//  Signal listener   up function triggerListener(){ var trigger=levelData[heroMapTile.y][heroMapTile.x]; if(trigger&gt;100){//  trigger-=100; if(trigger==1){//   1 levelData=level1Data; }else {//   2 levelData=level2Data; } for (var i = 0; i &lt; levelData.length; i++) { for (var j = 0; j &lt; levelData[0].length; j++) { trigger=levelData[i][j]; if(trigger&gt;100){//         heroMapTile.y=j; heroMapTile.x=i; heroMapPos=new Phaser.Point(heroMapTile.y * tileWidth, heroMapTile.x * tileWidth); heroMapPos.x+=(tileWidth/2); heroMapPos.y+=(tileWidth/2); } } } } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function </font></font><code>triggerListener()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">checks whether the value of the data array of the triggers in the given coordinate is greater than 100. </font><font style="vertical-align: inherit;">If so, then we determine which level we need to go to by subtracting 100 from the tile value. </font><font style="vertical-align: inherit;">The function finds the tile trigger in the new one </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which will be the coordinate of the character creation. </font><font style="vertical-align: inherit;">I made the trigger activate when the </font><strong><font style="vertical-align: inherit;">x</font></strong><font style="vertical-align: inherit;"> key was </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">released</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">if you simply read a key that is pressed, we will end up in a cycle that will move us between levels while the key is being pressed, because the character is always created on a new level on the active tile. </font><font style="vertical-align: inherit;">Here is a working </font><a href="http://jsfiddle.net/juwalbose/qe0v3L1s"><font style="vertical-align: inherit;">demo</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Try to pick up objects, stepping on them, and change levels, standing in front of the door and pressing </font><strong><font style="vertical-align: inherit;">x</font></strong><font style="vertical-align: inherit;"> .</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><a href="http://jsfiddle.net/juwalbose/qe0v3L1s"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 9. Shells </font></font></h2><br> <em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We call </font><em><font style="vertical-align: inherit;">shells</font></em><font style="vertical-align: inherit;"> what moves in a certain direction at a certain speed, for example, a bullet, a magic spell, a ball, etc. Everything related to characters is applicable to shells, with the exception of height: shells usually do not roll on the ground, but fly at a certain height. The bullet flies at the level of the character‚Äôs waist, and the ball may even jump. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interestingly, the isometric height corresponds to the height in a two-dimensional side view, although smaller in magnitude. There are no complex transformations. If the ball in Cartesian coordinates is ten pixels above the ground, then in isometric coordinates it can be above the ground at 10 or 6 pixels. (In our case, the corresponding axis will be the Y axis.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's try to realize the ball, galloping in our fenced garden. For extra realism, we will add a shadow to the ball. All that is needed is to add the height of the rebound to the isometric value of the Y ball. The value of the rebound height will change frame by frame depending on gravity, and as soon as the ball touches the ground, we will change the sign of the current speed along the Y axis. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before we start to deal with jumps in the isometric system, we will try to implement them in a two-dimensional Cartesian system. We denote the force of the ball rebound variable </font></font><code>zValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. To begin with, imagine that the ball rebound force is 100, that is </font></font><code>zValue = 100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use two variables: </font></font><code>incrementValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that initially has a value </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>gravity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that has a value </font></font><code>-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In each frame we will subtract</font></font><code>incrementValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font></font><code>zValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and subtract </font></font><code>gravity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font></font><code>incrementValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to create a damping effect. </font><font style="vertical-align: inherit;">When it </font></font><code>zValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reaches </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, it means that the ball has reached the ground. </font><font style="vertical-align: inherit;">At this moment we change the sign </font></font><code>incrementValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, multiplying it by </font></font><code>-1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and turning it into a positive number. </font><font style="vertical-align: inherit;">This means that from the next frame the ball will start moving upwards, that is, it will rebound.</font></font><br><br>  Here is how it looks in code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(game.input.keyboard.isDown(Phaser.Keyboard.X)){ zValue=<span class="hljs-number"><span class="hljs-number">100</span></span>; } incrementValue-=gravity; zValue-=incrementValue; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(zValue&lt;=<span class="hljs-number"><span class="hljs-number">0</span></span>){ zValue=<span class="hljs-number"><span class="hljs-number">0</span></span>; incrementValue*=<span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For an isometric view, the code also remained the same, with a slight difference: we use a lower initial value </font></font><code>zValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The following shows how it </font></font><code>zValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adds to the value of the isometric coordinate of the </font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ball when drawing.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawBallIso</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isoPt= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point();<span class="hljs-comment"><span class="hljs-comment">//       var ballCornerPt=new Phaser.Point(ballMapPos.x-ball2DVolume.x/2,ballMapPos.y-ball2DVolume.y/2); isoPt=cartesianToIsometric(ballCornerPt);//           gameScene.renderXY(ballShadowSprite,isoPt.x+borderOffset.x+shadowOffset.x, isoPt.y+borderOffset.y+shadowOffset.y, false);//     gameScene.renderXY(ballSprite,isoPt.x+borderOffset.x+ballOffset.x, isoPt.y+borderOffset.y-ballOffset.y-zValue, false);//     }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See interactive </font></font><a href="http://jsfiddle.net/juwalbose/cx02Lh9t"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The role played by the shadow is very important, it adds the realism of this illusion. </font><font style="vertical-align: inherit;">In addition, notice that we now use two screen coordinates (x and y) to represent the three dimensions in isometric coordinates ‚Äî the Y axis in screen coordinates is also the Z axis in isometric coordinates. </font><font style="vertical-align: inherit;">This can be confusing.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Finding a path and moving on it. </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finding a path and moving along it is a rather complicated process. </font><font style="vertical-align: inherit;">To find the path between two points, there are many different solutions using different algorithms, but since it </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a two-dimensional array, everything is much simpler than it could be. </font><font style="vertical-align: inherit;">We have clearly defined unique nodes that can be occupied by the player, and we can easily check whether it is possible to pass through them.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Posts on the topic </font></font></h3><br><ul><li> <a href="http://www.policyalmanac.org/games/aStarTutorial.htm" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A * Pathfinding for Beginners</font></font></a> </li><li> <a href="http://gamedev.tutsplus.com/tutorials/implementation/goal-based-vector-field-pathfinding/" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Goal-Based Vector Field Pathfinding</font></font></a> </li><li> <a href="http://gamedev.tutsplus.com/tutorials/implementation/speed-up-a-star-pathfinding-with-the-jump-point-search-algorithm/" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speed ‚Äã‚ÄãUp A * Pathfinding With Jump Point Search Algorithm</font></font></a> </li><li> <a href="http://gamedev.tutsplus.com/tutorials/implementation/understanding-steering-behaviors-path-following/" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The "Path Following" Steering Behavior</font></font></a> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A detailed overview of the pathfinding algorithms is too large for this article, but I will try to explain the most common method: the shortest path algorithm, the most famous implementations of which are A * and the Dijkstra algorithm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our goal is to find the nodes connecting the start node to the end node. </font><font style="vertical-align: inherit;">From the start node, we visit all eight neighboring nodes, and mark them as visited. </font><font style="vertical-align: inherit;">This process repeats recursively for each new visited node.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each thread keeps track of the nodes visited. </font><font style="vertical-align: inherit;">When passing to neighboring nodes, already visited nodes are skipped (recursion is stopped). </font><font style="vertical-align: inherit;">The process continues until we reach the end node where the recursion is completed and the entire path passed is returned as an array of nodes. </font><font style="vertical-align: inherit;">Sometimes the end node cannot be reached, that is, the path search fails. </font><font style="vertical-align: inherit;">Usually we find several paths between nodes. </font><font style="vertical-align: inherit;">In this case, we choose one of them with the minimum number of nodes.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finding the way </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is foolish to reinvent the wheel when it comes to clearly described algorithms, so we will use existing solutions to find the way. </font><font style="vertical-align: inherit;">In Phaser, we need a JavaScript solution, so I chose </font></font><a href="http://easystarjs.com/" rel="external"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EasyStarJS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The initialization of the search engine is performed as follows:</font></font><br><br><pre> <code class="javascript hljs">easystar = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EasyStar.js(); easystar.setGrid(levelData); easystar.setAcceptableTiles([<span class="hljs-number"><span class="hljs-number">0</span></span>]); easystar.enableDiagonals();<span class="hljs-comment"><span class="hljs-comment">//  ,      easystar.disableCornerCutting();//        </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the array </font></font><code>levelData</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains only </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we can immediately transfer it to the array of nodes. </font></font><code>0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We denoted the passable node by </font><font style="vertical-align: inherit;">value </font><font style="vertical-align: inherit;">. We also included the ability to move diagonally, but turned it off when the movement occurs near the corners of impassable tiles. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is done because with a diagonal movement a character can crash into an impassable tile. In this case, the collision recognition system will not allow the character to go through. In addition, it should be noted that in the example I completely deleted the recognition of collisions, because in our example of the character artificial intelligence will move along the way and it is not required. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will recognize mouse click on any free tile in the level and calculate the path using the function</font></font><code>findPath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The callback method </font></font><code>plotAndMove</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">receives an array of nodes of the created path. </font><font style="vertical-align: inherit;">We mark the path found on </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="javascript hljs">game.input.activePointer.leftButton.onUp.add(findPath) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findPath</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(isFindingPath || isWalking)<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos=game.input.activePointer.position; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> isoPt= <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point(pos.x-borderOffset.x,pos.y-borderOffset.y); tapPos=isometricToCartesian(isoPt); tapPos.x-=tileWidth/<span class="hljs-number"><span class="hljs-number">2</span></span>;<span class="hljs-comment"><span class="hljs-comment">//       -  tapPos.y+=tileWidth/2; tapPos=getTileCoordinates(tapPos,tileWidth); if(tapPos.x&gt;-1&amp;&amp;tapPos.y&gt;-1&amp;&amp;tapPos.x&lt;7&amp;&amp;tapPos.y&lt;7){//    if(levelData[tapPos.y][tapPos.x]!=1){//   isFindingPath=true; //    easystar.findPath(heroMapTile.x, heroMapTile.y, tapPos.x, tapPos.y, plotAndMove); easystar.calculate(); } } } function plotAndMove(newPath){ destination=heroMapTile; path=newPath; isFindingPath=false; repaintMinimap(); if (path === null) { console.log("No Path was found."); }else{ path.push(tapPos); path.reverse(); path.pop(); for (var i = 0; i &lt; path.length; i++) { var tmpSpr=minimap.getByName("tile"+path[i].y+"_"+path[i].x); tmpSpr.tint=0x0000ff; //console.log("p "+path[i].x+":"+path[i].y); } } }</span></span></code> </pre> <br><img src="https://habrastorage.org/getpro/habr/post_images/98f/0a5/583/98f0a55831dcb6d0cc48ab9421f4225e.png"><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Driving on the way </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Having received the path in the form of an array of nodes, we must force the character to move along it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose we want the character to move to the tile we clicked on. </font><font style="vertical-align: inherit;">First we look for the path between the node occupied by the character and the node that is clicked. </font><font style="vertical-align: inherit;">If the path is found, then we need to move the character to the first node of the node array, marking it as a destination. </font><font style="vertical-align: inherit;">Having reached the destination node, we check if there are any more nodes in the array of nodes, and if so, then mark the next node as the destination point, and so on, until we reach the destination node.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Also, each time a node is reached, we will change the direction of the player based on the current node and the new destination node. Between the nodes we just go in the right direction until we reach the destination node. This is a very simple AI, and in our example it is implemented in a method </font></font><code>aiWalk</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">partially shown below:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aiWalk</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(path.length==<span class="hljs-number"><span class="hljs-number">0</span></span>){<span class="hljs-comment"><span class="hljs-comment">//  if(heroMapTile.x==destination.x&amp;&amp;heroMapTile.y==destination.y){ dX=0; dY=0; isWalking=false; return; } } isWalking=true; if(heroMapTile.x==destination.x&amp;&amp;heroMapTile.y==destination.y){//   ,  ,   //  ,         stepsTaken++; if(stepsTaken&lt;stepsTillTurn){ return; } console.log("at "+heroMapTile.x+" ; "+heroMapTile.y); //     heroMapSprite.x=(heroMapTile.x * tileWidth)+(tileWidth/2)-(heroMapSprite.width/2); heroMapSprite.y=(heroMapTile.y * tileWidth)+(tileWidth/2)-(heroMapSprite.height/2); heroMapPos.x=heroMapSprite.x+heroMapSprite.width/2; heroMapPos.y=heroMapSprite.y+heroMapSprite.height/2; stepsTaken=0; destination=path.pop();//     if(heroMapTile.x&lt;destination.x){ dX = 1; }else if(heroMapTile.x&gt;destination.x){ dX = -1; }else { dX=0; } if(heroMapTile.y&lt;destination.y){ dY = 1; }else if(heroMapTile.y&gt;destination.y){ dY = -1; }else { dY=0; } if(heroMapTile.x==destination.x){ dX=0; }else if(heroMapTile.y==destination.y){ dY=0; } //...... } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need to</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filter out the right mouse points. </font><font style="vertical-align: inherit;">To do this, we determine that we clicked in a passable area, and not on the wall tile or another impassable tile. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another interesting moment of coding AI: we do not want the character to turn to face the next tile in the array of nodes as soon as it reaches the current one, because such an instantaneous turn will lead to the character walking along the boundaries of the tiles. </font><font style="vertical-align: inherit;">Instead, we should wait for the character to walk a few steps to the tile, and then start looking for the next destination. </font><font style="vertical-align: inherit;">It is also best to manually place the character in the middle of the current tile just before the turn, so that everything looks the best. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can see the working </font></font><a href="http://jsfiddle.net/juwalbose/pu0gt7nc/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11. Isometric scrolling </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the level area is much larger than the screen area, it is necessary to perform </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scrolling</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/243/73a/78f/24373a78ff8cb3d92bf3bc98e2643196.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The visible screen area can be viewed as a small rectangle in a large right-guard area of ‚Äã‚Äãthe entire level area. Scrolling is a simple movement of the inner rectangle in the inner one. Usually in the scrolling process, the position of the character in the screen rectangle remains constant - most often it is located in the center of the screen. Interestingly, to implement scrolling, we only need to track the corner point of the inner rectangle.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This corner point, which we denote in Cartesian coordinates, falls into one of the tiles in the level data. To scroll, we increase the position of the corner point along the X and Y axes in Cartesian coordinates. Now we can convert this point to isometric coordinates and use them to draw the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New converted values ‚Äã‚Äãin isometric space should be the angle of the screen, that is, new </font></font><code>(0, 0)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Therefore, when parsing and drawing the level data, we subtract this value from the isometric position of each tile. We can determine if the new tile position is within the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatively, we can draw an isometric tile grid of size </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x x y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the screen </font><font style="vertical-align: inherit;">so that the draw cycle is effective for large levels.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All these steps can be expressed as follows: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Update the Cartesian coordinates X and Y of the corner point. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Transformation into isometric space. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subtracting this value from the isometric position of drawing each tile. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drawing on the screen only a specified number of tiles, starting from this new angle. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Advanced: Tile rendering only if the new isometric drawing position is within the screen. </font></font></li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cornerMapPos=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cornerMapTile=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point(<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> visibleTiles=<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Phaser.Point(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>); <span class="hljs-comment"><span class="hljs-comment">//... function update(){ //... if (isWalkable()) { heroMapPos.x += heroSpeed * dX; heroMapPos.y += heroSpeed * dY; //     cornerMapPos.x -= heroSpeed * dX; cornerMapPos.y -= heroSpeed * dY; cornerMapTile=getTileCoordinates(cornerMapPos,tileWidth); //    heroMapTile=getTileCoordinates(heroMapPos,tileWidth); //       renderScene(); } } function renderScene(){ gameScene.clear();//  ,    var tileType=0; //    var startTileX=Math.max(0,0-cornerMapTile.x); var startTileY=Math.max(0,0-cornerMapTile.y); var endTileX=Math.min(levelData[0].length,startTileX+visibleTiles.x); var endTileY=Math.min(levelData.length,startTileY+visibleTiles.y); startTileX=Math.max(0,endTileX-visibleTiles.x); startTileY=Math.max(0,endTileY-visibleTiles.y); //   for (var i = startTileY; i &lt; endTileY; i++) { for (var j = startTileX; j &lt; endTileX; j++) { tileType=levelData[i][j]; drawTileIso(tileType,i,j); if(i==heroMapTile.y&amp;&amp;j==heroMapTile.x){ drawHeroIso(); } } } } function drawHeroIso(){ var isoPt= new Phaser.Point();//       var heroCornerPt=new Phaser.Point(heroMapPos.x-hero2DVolume.x/2+cornerMapPos.x,heroMapPos.y-hero2DVolume.y/2+cornerMapPos.y); isoPt=cartesianToIsometric(heroCornerPt);//        2D- gameScene.renderXY(sorcererShadow,isoPt.x+borderOffset.x+shadowOffset.x, isoPt.y+borderOffset.y+shadowOffset.y, false);//     gameScene.renderXY(sorcerer,isoPt.x+borderOffset.x+heroWidth, isoPt.y+borderOffset.y-heroHeight, false);//     } function drawTileIso(tileType,i,j){//    var isoPt= new Phaser.Point();//       var cartPt=new Phaser.Point();//    . cartPt.x=j*tileWidth+cornerMapPos.x; cartPt.y=i*tileWidth+cornerMapPos.y; isoPt=cartesianToIsometric(cartPt); //         . if(tileType==1){ gameScene.renderXY(wallSprite, isoPt.x+borderOffset.x, isoPt.y+borderOffset.y-wallHeight, false); }else{ gameScene.renderXY(floorSprite, isoPt.x+borderOffset.x, isoPt.y+borderOffset.y, false); } }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that the increment of the corner point occurs in the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opposite</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> direction to the update of the character‚Äôs position as it moves. </font><font style="vertical-align: inherit;">Thanks to this, the character remains in the same place relative to the screen. </font><font style="vertical-align: inherit;">See this </font></font><a href="http://jsfiddle.net/juwalbose/duzbpbky/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (use the arrow keys to scroll, click to increase the visible grid).</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A couple of notes: </font></font><br><br><ul><li>           ,         . </li><li>     ,     ,       . ,          X  Y,     X     ,   Y     .   ,        . </li><li>  -       ,       . </li><li>       ,           .          <em></em>  .                    .      ? </li></ul><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This tutorial is mainly intended for beginners learning isometric game worlds. </font><font style="vertical-align: inherit;">Many of the concepts presented here have other, slightly more complex solutions, and I deliberately chose the simplest ones. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps this guide will not solve all the problems you have, but the information obtained will allow you to develop these concepts to create more complex solutions. </font><font style="vertical-align: inherit;">For example, the implemented simple sorting by depth will not help in the case of levels with several floors and platform tiles moving from one floor to another. </font><font style="vertical-align: inherit;">But this is a task for another tutorial.</font></font></div><p>Source: <a href="https://habr.com/ru/post/332922/">https://habr.com/ru/post/332922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332912/index.html">27000 errors in the Tizen operating system</a></li>
<li><a href="../332914/index.html">20 materials about the methods of successful traffic to the site</a></li>
<li><a href="../332916/index.html">We implement touch logger for Android using CVE-2016‚Äì5195</a></li>
<li><a href="../332918/index.html">Gremlins and ELF magic: what if the ELF file is a container?</a></li>
<li><a href="../332920/index.html">Deploy and demonize the ASP.NET Core Linux application as a background service.</a></li>
<li><a href="../332924/index.html">Tcl / Tk. GUI development for command line utilities</a></li>
<li><a href="../332928/index.html">Implementing Elliptic curve Menezes-Vanstone cryptosystem based on the OpenSSL API</a></li>
<li><a href="../332930/index.html">Solution of the promo task from BI.ZONE CTF</a></li>
<li><a href="../332934/index.html">Setting up object archiving in SAP ERP for beginners</a></li>
<li><a href="../332936/index.html">Method of non-iterative learning of a single-layer network of direct distribution with a linear activation function</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>