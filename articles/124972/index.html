<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a match-3 game using Flash and ActionScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All colleagues, hello. 
 I am a beginner FlashGame developer. I liked the lesson on creating a game on the mechanics of match-three. I understood the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a match-3 game using Flash and ActionScript</h1><div class="post__text post__text-html js-mediator-article">  All colleagues, hello. <br>  I am a beginner FlashGame developer.  I liked the lesson on creating a game on the mechanics of match-three.  I understood the lesson myself the first time, but why did I do the translation?  First of all, I hope this will help someone who is not good at English.  Secondly, the translation allowed me to parse the entire code by bone, very carefully.  And thirdly, starting from this mechanics you can start creating the mach-3 of your dreams.  And it doesn't have to be in Flash. <br><br>  Before I begin, I will issue a couple of agreements.  The lesson is taken by me from the book Gary Rosenzweig - <a href="http://www.amazon.com/ActionScript-3-0-Game-Programming-University/dp/0789747324/ref%3Dsr_1_1%3Fie%3DUTF8%26qid%3D1311688659%26sr%3D8-1">"ActionScript 3.0 Game Programming University"</a> .  I already wrote in my personal blog that not all of our flash developers have a positive attitude towards this book.  The translation may seem a bit wooden and not very pleasant by ear.  Some words, expressions may have more appropriate analogues in Russian.  If this is critical, correct.  The program uses an additional class PointBurst.  I will not describe it now, but most likely I will do it in a personal blog, because  This is quite an interesting class.  Just until we know that this class gives the effect of pop-up points in a certain place. <br>  And finally, I did not invent anything new, but simply made a translation, i.e.  all thanks to the author of the book Gary Rosenzweig. <br><br><img src="https://habrastorage.org/storage1/4a00de37/a48a81f3/6fd7ffdf/ff6a3be9.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  <i><b>Field (board)</b> = game board where chips are located, visual display</i> <i><br></i>  <i><b>Chip (piece)</b> = an element that we combine with others.</i> <i><br></i>  <i><b>Line (match)</b> = row or column, a sequence of at least 3 chips of the same type.</i> <i><br></i>  <i><b>Grid (grid)</b> = 2-dimensional matrix, which in digital form duplicates the board.</i> <br><br>  <b>Review of the functionality of the game.</b> <br>  The sequence of all events in the game includes 12 steps, where each step is a separate task. <br>  <b>1. Creating a randomly generated playing field.</b> <br>  Creating a field of 8x8 with randomly spaced chips, each of which can have 7 different display options. <br>  <b>2. Check on line.</b> <br>  There are some restrictions on the initial placement of chips on the field.  First, the field at the start of the game should not contain lines. <br>  <b>3. Check on the possibility of the first move.</b> <br>  The second limitation is to give the player at least one turn.  That is, the field should not be initially unsolvable composition. <br>  <b>4. The player chooses 2 chips.</b> <br>  Chips must be next to each other (vertically or horizontally) and their exchange of places occurs with the aim of forming a line. <br>  <b>5. Chips are swapped.</b> <br>  Here we use the simplest animation. <br>  <b>6. Check on line.</b> <br>  After the exchange we are looking for lines on the field.  If the lines are not found, change the chips back in places. <br>  <b>7.When finding the line, reward the player with points.</b> <br>  <b>8. Remove lines from the field.</b> <br>  <b>9. We shift the upper pieces to the place of the disappeared.</b> <br>  <b>10. We fill the formed emptiness.</b> <br>  <b>11. Check again on the line.</b>  <b>Returning to paragraph 6.</b> <br>  After all the chips have fallen down on the empty seats, and new ones have filled the voids, you need to re-check on the line. <br>  <b>12. Check on the possibility of a move.</b> <br>  Before you transfer a move to a player, you need to make sure that there are possible moves on the field. <br><br>  <b>Our clip and class MatchThree</b> <br>  <b>ClipThree.fla</b> clip <b>is</b> very simple.  In addition to the <b>Arial</b> font in the library, we have here a clip of seven frames.  In the <b>Color</b> layer in each frame a different type of chips.  The upper <b>Select</b> layer is used to frame (highlight) the selected chip and will be activated by the <b>visible</b> property. <br><br><img src="https://habrastorage.org/storage1/fad2f444/593b026c/3189ceaa/8f4b8090.jpg"><br><br>  Let's take a look at the basic class definitions, while not looking at the logic of the game.  Here we have only the most basic imports and nothing more. <br><br><blockquote>  package <font color="#66cc66">{</font> <br>  <font color="#0066CC">import</font> flash.  <font color="#006600">display</font> .  <font color="#66cc66">*</font> ; <br>  <font color="#0066CC">import</font> flash.  <font color="#006600">events</font> .  <font color="#66cc66">*</font> ; <br>  <font color="#0066CC">import</font> flash.  <font color="#0066CC">text</font> .  <font color="#66cc66">*</font> ; <br>  <font color="#0066CC">import</font> flash.  <font color="#006600">utils</font> .  <font color="#006600">Timer</font> ; </blockquote><br><br>  We have the following constants: one indicates the type of the chip (seven different variants) and three constants for orienting the position on the screen. <br><br><blockquote>  <font color="#0066CC">public</font> <font color="#000000">class</font> MatchThree <font color="#0066CC">extends</font> <font color="#0066CC">MovieClip</font> <font color="#66cc66">{</font> <br>  <font color="#808080">// constants</font> <br>  <font color="#808080">// number of chip types</font> <br>  <font color="#0066CC">static</font> const numPieces: uint = <font color="#cc66cc">7</font> ; <br>  <font color="#808080">// distance between two chips</font> <br>  <font color="#0066CC">static</font> const spacing: <font color="#0066CC">Number</font> = <font color="#cc66cc">45</font> ; <br>  <font color="#808080">// left indent</font> <br>  <font color="#0066CC">static</font> const offsetX: <font color="#0066CC">Number</font> = <font color="#cc66cc">120</font> ; <br>  <font color="#808080">// indent from above</font> <br>  <font color="#0066CC">static</font> const offsetY: <font color="#0066CC">Number</font> = <font color="#cc66cc">30</font> ; </blockquote><br><br>  Game settings will be stored in 5 different variables.  First, the grid will contain links to all the chips ( <b>Pieces</b> ).  The grid is a two-dimensional array.  Each element of the grid ( <b>grid</b> ) will contain an array of 8 chips ( <b>Pieces</b> ).  All of this will look like a matrix, an 8x8 array, and we can access any chip through the <b>grid [x] [y]</b> link. <br>  The <b>GameSprite sprite</b> will contain all the sprites and movie clips we create.  So we will separate them from any other graphics already existing on the stage. <br>  The variable <b>firstPiece</b> will contain a link to the first clicked chip. <br>  Two logical ( <b>Boolean</b> ) variables <b>isDropping</b> , <b>isSwapping</b> will keep track of which chips we need to animate at the moment.  The <b>gameScore</b> variable will hold player points. <br><br><blockquote>  <font color="#808080">// game grid and necessary settings</font> <br>  <font color="#0066CC">private</font> <font color="#000000">var</font> grid: <font color="#0066CC">Array</font> ; <br>  <font color="#0066CC">private</font> <font color="#000000">var</font> gameSprite: Sprite; <br>  <font color="#0066CC">private</font> <font color="#000000">var</font> firstPiece: Piece; <br>  <font color="#0066CC">private</font> <font color="#000000">var</font> isDropping, isSwapping: <font color="#0066CC">Boolean</font> ; <br>  <font color="#0066CC">private</font> <font color="#000000">var</font> gameScore: <font color="#0066CC">int</font> ; </blockquote><br><br>  <b>Grid Setup</b> <br>  The first functions will determine the variables of the game, including the setting of the grid. <br>  Setting game variables <br>  To start the game, it is necessary to determine, initialize all game variables.  Let's start by creating a grid ( <b>grid</b> ), a 8x8 two-dimensional array.  Then use the <b>setUpGrid</b> function to populate this array. <br><br>  <i>Note.</i> <i><br></i>  <i>There is no need to fill all elements of the array with empty slots for initialization.</i>  <i>When setting a value for any element of the array, all previous elements are filled with the value <b>undefined</b> .</i>  <i>For example, in the newly created array, we assign the third element (under the index [2]) the value <b>‚ÄúMy String‚Äù</b> .</i>  <i>The array will have a length ( <b>length</b> ) equal to 3, and the elements [0] and [1] will get the values <b>undefined</b> .</i> <br><br>  Next we define the variables <b>isDropping</b> , <b>isSwapping</b> and <b>gameScore</b> .  We also set a listener on the <b>ENTER_FRAME</b> event to start all the movements of the chips in the game. <br><br><blockquote>  <font color="#808080">// initialize the grid () and start the game</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> startMatchThree <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#808080">// creation and initialization of the grid (grid)</font> <br>  grid = <font color="#000000">new</font> <font color="#0066CC">Array</font> <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> gridrows: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; gridrows <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; gridrows ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  grid.  <font color="#0066CC">push</font> <font color="#66cc66">(</font> <font color="#000000">new</font> <font color="#0066CC">Array</font> <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> <br>  setUpGrid <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br>  isDropping = <font color="#000000">false</font> ; <br>  isSwapping = <font color="#000000">false</font> ; <br>  gameScore = <font color="#cc66cc">0</font> ; <br>  addEventListener <font color="#66cc66">(</font> Event. <font color="#006600">ENTER_FRAME</font> , movePieces <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  <b>Grid Setup</b> <br>  To create and initialize the grid ( <b>grid</b> ) use the loop with the condition <b>while (true)</b> .  In the loop, create mesh elements.  Also create a <b>gameSprite</b> sprite that will contain the movie clips of our chips.  Then add 64 random chips using the <b>addPiece</b> function.  We will consider this function later, but for now we‚Äôll just know that it adds a chip to the grid and to <b>gameSprite</b> . <br><br><blockquote>  <font color="#0066CC">public</font> <font color="#000000">function</font> setUpGrid <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#808080">// loop until we create a playable mesh</font> <br>  <font color="#b1b100">while</font> <font color="#66cc66">(</font> <font color="#000000">true</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#808080">// create sprite</font> <br>  gameSprite = <font color="#000000">new</font> Sprite <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br><br>  <font color="#808080">// add 64 random chips</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> col: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; col <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; col ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> row: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; row <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; row ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  addPiece <font color="#66cc66">(</font> col, row <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> </blockquote><br><br>  Next, check the two conditions necessary to start the game.  The <b>lookForMatches</b> function returns an array of found lines.  This function will also be discussed later.  At the moment we know that the function will return 0 if there are no lines on the screen.  The <b>continue</b> statement skips the rest of the loop and returns us to its beginning. <br>  After that, call the function <b>lookForPossibles</b> , which will check if there are any possible moves on the field.  If there are no moves, the function will return <b>false</b> , and this will mean that you cannot start the game. <br>  If we have passed both of these conditions, the <b>break</b> statement will interrupt the cycle, and we will add a <b>gameSprite</b> to the scene. <br><br><blockquote>  <font color="#808080">// try again if there are lines on the field</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> lookForMatches <font color="#66cc66">(</font> <font color="#66cc66">)</font> . <font color="#0066CC">length</font> <font color="#66cc66">!</font> = <font color="#cc66cc">0</font> <font color="#66cc66">)</font> <font color="#b1b100">continue</font> ; <br><br>  <font color="#808080">// try again if there are no moves on the field</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> lookForPossibles <font color="#66cc66">(</font> <font color="#66cc66">)</font> == <font color="#000000">false</font> <font color="#66cc66">)</font> <font color="#b1b100">continue</font> ; <br><br>  <font color="#808080">// no lines, and there is a move, interrupt the cycle</font> <br>  <font color="#b1b100">break</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#808080">// add sprite</font> <br>  addChild <font color="#66cc66">(</font> gameSprite <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  <b>Adding chips</b> <br>  The <b>addPiece</b> function creates a random chip in a specific column and column, and assigns it a location on the screen. <br><blockquote>  <font color="#808080">// create a random chip, add it to the sprite and the grid</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> addPiece <font color="#66cc66">(</font> col, row: <font color="#0066CC">int</font> <font color="#66cc66">)</font> : Piece <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> newPiece: Piece = <font color="#000000">new</font> Piece <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br>  newPiece.  <font color="#006600">x</font> = col <font color="#66cc66">*</font> spacing + offsetX; <br>  newPiece.  <font color="#006600">y</font> = row <font color="#66cc66">*</font> spacing + offsetY; </blockquote><br><br>  Each piece is set in the assigned row and column.  To do this, use two dynamic properties of <b>col</b> and <b>row</b> .  Also, a token has a <b>type</b> property that contains a number corresponding to the type of the token and the frame in which its movie clip is located. <br><br><blockquote>  newPiece.  <font color="#006600">col</font> = col; <br>  newPiece.  <font color="#006600">row</font> = row; <br>  newPiece.  <font color="#0066CC">type</font> = <font color="#0066CC">Math</font> .  <font color="#006600">cell</font> <font color="#66cc66">(</font> <font color="#0066CC">Math</font> . <font color="#0066CC">random</font> <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">*</font> <font color="#cc66cc">7</font> <font color="#66cc66">)</font> ; <br>  newPiece.  <font color="#0066CC">gotoAndStop</font> <font color="#66cc66">(</font> newPiece. <font color="#0066CC">type</font> <font color="#66cc66">)</font> ; </blockquote><br><br>  The <b>Select</b> Movie Clip inside the <b>Piece</b> clip is a frame that hovers over the clicked chip.  Initially, its <b>visible</b> property will be <b>false</b> .  Clip <b>Piece</b> chips we add to <b>gameSprite</b> .  In order to add a chip to the grid ( <b>grid</b> ) we use double straight brackets <b>grid [col] [row] = newPiece</b> .  On each chip we will hang the listener ( <b>click listener</b> ).  Then return the link to the chip ( <b>Piece</b> ).  We will not use this link in the <b>setUpGrid</b> function, but use it later when creating new tokens to replace voids. <br><br><blockquote>  newPiece.  <font color="#006600">select</font> .  <font color="#0066CC">visible</font> = <font color="#000000">false</font> ; <br>  gameSprite.  <font color="#006600">addChild</font> <font color="#66cc66">(</font> newPiece <font color="#66cc66">)</font> ; <br>  grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> = newPiece; <br>  newPiece.  <font color="#006600">addEventListener</font> <font color="#66cc66">(</font> MouseEvent. <font color="#006600">CLICK</font> , clickPiece <font color="#66cc66">)</font> ; <br>  <font color="#b1b100">return</font> newPiece; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  <b>Interaction with the player</b> <br>  When choosing a player to click a chip, our further actions depend on whether it is the first or second clicked chip.  If it was the first chip, it stands out.  If the player clicks on this chip again, the selection will be removed. <br><br><blockquote>  <font color="#808080">// player clicks on the chip</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> clickPiece <font color="#66cc66">(</font> event: MouseEvent <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> piece: Piece = Piece <font color="#66cc66">(</font> event. <font color="#006600">currentTarget</font> <font color="#66cc66">)</font> ; <br><br>  <font color="#808080">// first chip selected</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> firstPiece == <font color="#000000">null</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  piece.  <font color="#006600">select</font> .  <font color="#0066CC">visible</font> = <font color="#000000">true</font> ; <br>  firstPiece = piece; <br><br>  <font color="#808080">// re-click on the first chip</font> <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#66cc66">(</font> firstPiece == piece <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  piece.  <font color="#006600">select</font> .  <font color="#0066CC">visible</font> = <font color="#000000">false</font> ; <br>  firstPiece = <font color="#000000">null</font> ; </blockquote><br><br>  When a player clicks on a second chip, different from the first one, we must determine whether it is possible to make an exchange.  First we remove the selection from the first chip.  Then we will check whether they are neighbors vertically or horizontally from the second.  In both cases, call the function <b>makeSwap</b> .  She will make an exchange and establish whether lines have formed.  In any case, the variable <b>firstPiece</b> is nullified ( <b>null</b> ) and becomes ready for the next player choice.  If the chips are not neighbors, we believe that the player dropped his choice from the first chip and started from the second <br><br><blockquote>  <font color="#808080">// click on the second chip</font> <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#66cc66">{</font> <br>  firstPiece.  <font color="#006600">select</font> .  <font color="#0066CC">visible</font> = <font color="#000000">false</font> ; <br><br>  <font color="#808080">// same row, check the neighborhood in the column</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> <font color="#66cc66">(</font> firstPiece. <font color="#006600">row</font> == piece. <font color="#006600">row</font> <font color="#66cc66">)</font> <font color="#66cc66">&amp;&amp;</font> <font color="#66cc66">(</font> <font color="#0066CC">Math</font> . <font color="#0066CC">abs</font> <font color="#66cc66">(</font> firstPiece. <font color="#006600">col-</font> piece. <font color="#006600">col</font> <font color="#66cc66">)</font> == <font color="#cc66cc">1</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  makeSwap <font color="#66cc66">(</font> firstPiece, piece <font color="#66cc66">)</font> ; <br>  firstPiece = <font color="#000000">null</font> ; <br><br>  <font color="#808080">// same column, check the neighborhood in the row</font> <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#66cc66">((</font> <font color="#66cc66">(</font> firstPiece. <font color="#006600">col</font> == piece. <font color="#006600">col</font> <font color="#66cc66">)</font> <font color="#66cc66">&amp;&amp;</font> <font color="#66cc66">(</font> <font color="#0066CC">Math</font> . <font color="#0066CC">abs</font> <font color="#66cc66">(</font> firstPiece. <font color="#006600">row</font> -piece. <font color="#006600">row</font> <font color="#66cc66">)</font> == <font color="#cc66cc">1</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  makeSwap <font color="#66cc66">(</font> firstPiece, piece <font color="#66cc66">)</font> ; <br>  firstPiece = <font color="#000000">null</font> ; <br><br>  <font color="#808080">// no neighborhood, discard the first chip selection</font> <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#66cc66">{</font> <br>  firstPiece = piece; <br>  firstPiece.  <font color="#006600">select</font> .  <font color="#0066CC">visible</font> = <font color="#000000">true</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> </blockquote><br><br>  The <b>makeSwap</b> function swaps chips and checks if lines are formed on the field.  If not, change chips back in places.  If yes, and the exchange is possible, the variable <b>isSwapping</b> takes the value <b>true</b> , which gives the signal to start the animation of the movement of the chips. <br><br><blockquote>  <font color="#808080">// start of the two chip exchange animation</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> makeSwap <font color="#66cc66">(</font> piece1, piece2: Piece <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  swapPieces <font color="#66cc66">(</font> piece1, piece2 <font color="#66cc66">)</font> ; <br><br>  <font color="#808080">// check if the exchange was successful</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> lookForMatches <font color="#66cc66">(</font> <font color="#66cc66">)</font> . <font color="#0066CC">length</font> == <font color="#cc66cc">0</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  swapPieces <font color="#66cc66">(</font> piece1, piece2 <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#66cc66">{</font> <br>  isSwapping = <font color="#000000">true</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> </blockquote><br><br>  To make an exchange, we must save the location of the first chips in a temporary storage.  Next, move the first chip to the second one, and the second one to the saved coordinates of the first one. <br><br><img src="https://habrastorage.org/storage1/35d37100/4462582f/3493222f/3607e7b1.jpg"><br><br>  After the exchange, we need to update the values ‚Äã‚Äãin the grid. <br><br><blockquote>  <font color="#808080">// exchange two chips</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> swapPieces <font color="#66cc66">(</font> piece1, piece2: Piece <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#808080">// exchange the row and col values</font> <br>  <font color="#000000">var</font> tempCol: uint = piece1.  <font color="#006600">col</font> ; <br>  <font color="#000000">var</font> tempRow: uint = piece1.  <font color="#006600">row</font> ; <br>  piece1.  <font color="#006600">col</font> = piece2.  <font color="#006600">col</font> ; <br>  piece1.  <font color="#006600">row</font> = piece2.  <font color="#006600">row</font> ; <br>  piece2.  <font color="#006600">col</font> = tempCol; <br>  piece2.  <font color="#006600">row</font> = tempRow; <br><br>  <font color="#808080">// change the position in the grid (grid)</font> <br>  grid <font color="#66cc66">[</font> piece1.  <font color="#006600">col</font> <font color="#66cc66">]</font> <font color="#66cc66">[</font> piece1.  <font color="#006600">row</font> <font color="#66cc66">]</font> = piece1; <br>  grid <font color="#66cc66">[</font> piece2.  <font color="#006600">col</font> <font color="#66cc66">]</font> <font color="#66cc66">[</font> piece2.  <font color="#006600">row</font> <font color="#66cc66">]</font> = piece2; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  The exchange is completely reversible and it is very important, because in the future we will often have to use it.  Indeed, in reality, we do not know whether the exchange will lead to the formation of lines until we produce it.  Therefore, we first change the chips, check on the line and return them back if no lines are found. <br><br>  <b>Chip Motion Animation</b> <br>  We use an interesting, but not obvious method of animation.  We know about each chip in which row and column it is, due to the dynamic properties of <b>row</b> and <b>col</b> .  And also we can find out its location on the screen based on the properties of <b>x</b> and <b>y</b> .  Do not forget about the constants <b>spacing</b> , <b>offsetX</b> , <b>offsetY</b> .  For example, a chip in column 3 will get the value <b>x = 3 * spacing + offset</b> .  What happens if the chip moves to another column?  If we assign a <b>col</b> value of 4 to the chip, then <b>x = 4 * spacing + offset</b> , which is 45 pixels to the right.  Therefore, we will make the chip move to the right, closer to its destination.  If you do this every frame, then soon the chip will rise to its new destination and stop moving (its values <b>col</b> and <b>x</b> will match each other). <br>  Using this technique, you can animate any piece as it moves to a new place.  We don't even have to set up animation at the level of the movie clip.  All we have to do is change the <b>col</b> property or <b>row of</b> chips ( <b>Piece</b> ).  And the <b>movePieces</b> function will take care of the rest. <br>  The <b>movePieces</b> function <b>is</b> called every frame, because we set it up at the very beginning of the class, with the help of the listener.  It checks all chips for matching values ‚Äã‚Äãof <b>col</b> and <b>row</b> with <b>x</b> and <b>y</b> . <br><br>  <b>Note.</b> <br>  In the <b>movePieces</b> function <b>,</b> we use step 5 every frame.  This value must always be a multiple of the <b>spacing</b> value.  If <b>spacing</b> were equal, for example, 48, we would use 4, 6 or 8. <br><br><blockquote>  <font color="#808080">// if a chip is out of place, move it a little closer</font> <br>  <font color="#808080">// this happens in the case of exchange, or falling chips</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> movePieces <font color="#66cc66">(</font> event: Event <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> madeMove: <font color="#0066CC">Boolean</font> = <font color="#000000">false</font> ; <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> row: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; row <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; row ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> col: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; col <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; col ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> <font color="#66cc66">!</font> = <font color="#000000">null</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br><br>  <font color="#808080">// shift down</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#006600">y</font> <font color="#66cc66">&lt;</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#006600">row</font> <font color="#66cc66">*</font> spacing + offsetY <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> .  <font color="#006600">y</font> + = <font color="#cc66cc">5</font> ; <br>  madeMove = <font color="#000000">true</font> ; <br><br>  <font color="#808080">// move up</font> <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#006600">y</font> <font color="#66cc66">&gt;</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#006600">row</font> <font color="#66cc66">*</font> spacing + offsetY <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> .  <font color="#006600">y</font> - = <font color="#cc66cc">5</font> ; <br>  madeMove = <font color="#000000">true</font> ; <br>  <font color="#808080">// shift to the right</font> <br><br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#006600">x</font> <font color="#66cc66">&lt;</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#006600">col</font> <font color="#66cc66">*</font> spacing + offsetX <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> .  <font color="#006600">x</font> + = <font color="#cc66cc">5</font> ; <br>  madeMove = <font color="#000000">true</font> ; <br><br>  <font color="#808080">// shift left</font> <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#006600">x</font> <font color="#66cc66">&gt;</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#006600">col</font> <font color="#66cc66">*</font> spacing + offsetX <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> .  <font color="#006600">x</font> - = <font color="#cc66cc">5</font> ; <br>  madeMove = <font color="#000000">true</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> </blockquote><br><br>  At the beginning of the <b>movePieces</b> function <b>,</b> we set the <b>madeMove</b> flag to <b>false</b> .  Then, in the case of any offset, reset it to <b>true</b> .  If there was no offset in either direction, <b>madeMove</b> remains equal to <b>false</b> .  Then we compare this flag with the <b>isDropping</b> and <b>isSwapping properties</b> .  If <b>isDropping is</b> <b>true</b> , and <b>madeMove is</b> <b>false</b> , then all the falling chips are in place.  It's time to check the field on the line. <br>  If <b>isSwapping is true</b> and <b>madeMove is false</b> , then two chips have just completed the exchange.  And in this case, check the field on the line. <br><br><blockquote>  <font color="#808080">// all drops completed</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> isDropping <font color="#66cc66">&amp;&amp;</font> <font color="#66cc66">!</font> madeMove <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  isDropping = <font color="#000000">false</font> ; <br>  findAndRemoveMatches <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br><br>  <font color="#808080">// all exchanges completed</font> <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#b1b100">if</font> <font color="#66cc66">(</font> isSwapping <font color="#66cc66">&amp;&amp;</font> <font color="#66cc66">!</font> madeMove <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  isSwapping = <font color="#000000">false</font> ; <br>  findAndRemoveMatches <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> </blockquote><br><br>  <b>Line search</b> <br>  Our program has two difficult tasks.  And the first one is the search for lines.  The task of finding them is quite difficult and is not solved by a simple method. <br><br>  Dividing the task into small steps. <br>  Let's try to divide the task into smaller subtasks, and we will do this until we reduce the subtask to a simple solution. <br>  So, the <b>findAndRemoveMatches</b> function is divided into two parts.  Find lines and remove them.  The second task, removal, is simple in its essence.  Remove chips from <b>gameSprite</b> , set zeros in the grid to the place of the deleted chips and reward the player with points. <br><br>  <i>Note</i> <i><br></i>  <i>The number of points depends on the number of chips in the line.</i>  <i>Three chips mean (3-1) * 50 or 100 points for each chip.</i>  <i>Four chips, (4-1) * 50 or 150 points for a chip, at least 600 points.</i> <br><br>  Also, after removing the chips, it is necessary to reset down those that were over the deleted ones.  This is also a rather difficult task. <br>  So, we have two challenges, find the lines and decide what to do with the chips over the disappeared ones.  We will assign these tasks to the <b>lookForMatches</b> and <b>affectAbove functions</b> .  We will do the rest right in the <b>findAndRemoveMatches</b> function. <br><br>  <b>Function findAndRemoveMatches</b> <br>  We loop through all the lines and put them into an array.  We give points for each line.  Next, we go through all the chips that need to be removed and remove them. <br><br>  <i>Note</i> <i><br></i>  <i>When we take a complex task and assign its solution to functions that we have not yet defined, this is called <b>top-down programming</b> .</i>  <i>Instead of thinking and puzzling over how to look for lines, we will shift this to the <b>lookForMatches</b> function.</i>  <i>That is, we build our program from top to bottom, taking care of how everything looks as a whole, and the functions to which we shift the tasks, we consider later.</i> <br><br><blockquote>  <font color="#0066CC">public</font> <font color="#000000">function</font> findAndRemoveMatches <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#808080">// create a list of lines</font> <br>  <font color="#000000">var</font> matches: <font color="#0066CC">Array</font> = lookForMatches <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> i: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; i <font color="#66cc66">&lt;</font> matches. <font color="#0066CC">length</font> ; i ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> numPoints: <font color="#0066CC">Number</font> = <font color="#66cc66">(</font> matches <font color="#66cc66">[</font> i <font color="#66cc66">]</font> . <font color="#006600">length</font> - <font color="#cc66cc">1</font> <font color="#66cc66">)</font> <font color="#66cc66">*</font> <font color="#cc66cc">50</font> ; <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> j: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; j <font color="#66cc66">&lt;</font> matches <font color="#66cc66">[</font> i <font color="#66cc66">]</font> . <font color="#0066CC">length</font> ; j ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> gameSprite. <font color="#006600">contains</font> <font color="#66cc66">(</font> matches <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> j <font color="#66cc66">]</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> pb = <font color="#000000">new</font> PointBurst <font color="#66cc66">(</font> <font color="#0066CC">this</font> , numPoints, matches <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> j <font color="#66cc66">]</font> . <font color="#006600">x</font> , matches <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> j <font color="#66cc66">]</font> . <font color="#006600">y</font> <font color="#66cc66">)</font> ; <br>  addScore <font color="#66cc66">(</font> numPoints <font color="#66cc66">)</font> ; <br>  gameSprite.  <font color="#006600">removeChild</font> <font color="#66cc66">(</font> matches <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> j <font color="#66cc66">]</font> <font color="#66cc66">)</font> ; <br>  grid <font color="#66cc66">[</font> matches <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> j <font color="#66cc66">]</font> .  <font color="#006600">col</font> <font color="#66cc66">]</font> <font color="#66cc66">[</font> matches <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> j <font color="#66cc66">]</font> .  <font color="#006600">row</font> <font color="#66cc66">]</font> = <font color="#000000">null</font> ; <br>  affectAbove <font color="#66cc66">(</font> matches <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> j <font color="#66cc66">]</font> <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> </blockquote><br><br>  The <b>findAndRemoveMatches</b> function performs two tasks.  First, <b>addNewPieces</b> fills in the missing number of chips in a column.  Then call <b>lookForPossibles</b> to make sure that the player still has moves on the field.  It is only needed if new lines are no longer found.  This happens if <b>findAndRemoveMatches</b> was called after new chips fell, and no lines were found. <br><br><blockquote>  <font color="#808080">// add a new chip at the top of the field</font> <br>  addNewPieces <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br><br>  <font color="#808080">// no lines found, check for the possibility of running</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> matches. <font color="#0066CC">length</font> == <font color="#cc66cc">0</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> <font color="#66cc66">!</font> lookForPossibles <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  endGame <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> </blockquote><br><br>  <b>LookForMatches function</b> <br>  The purpose of the function is to create an array of the found lines.  We determine the lines of more than 2 chips.  To do this, do a round in a loop, first in rows, then in columns.  Check the segment of the first 6 chips in each row.  It makes no sense to check from 7 and 8, as they will not be able to form lines from more than 2 chips. <br>  The functions <b>getMatchHoriz</b> and <b>getMatchVert</b> determine the length of the line from the beginning of the element passed to them.  For example, if the element <b>[3] [6]</b> is a type 4 token, <b>[4] [6] is</b> also a type 4 token, and <b>[5] [6] is a</b> token of type 1, the call to <b>getMatchHoriz (3.6)</b> will return 2 because the line is found from 2 chips. <br>  If a line is found, it will be effective to skip a couple of cycles and jump a couple of steps forward.  For example, we have a line in <b>[2] [1]</b> , <b>[2] [2]</b> , <b>[2] [3]</b> and <b>[2] [4]</b> , we simply check <b>[2] [1]</b> , return the result 4 and skipping <b>[2] [2]</b> , <b>[2] [3]</b> , <b>[2] [4]</b> to immediately start with <b>[2] [5]</b> . <br>  For each line found using <b>getMatchHorizon</b> or <b>getMatchVert,</b> they return an array containing each chip in the line.  We add these arrays to the <b>lookForMatches</b> function in the <b>matches</b> array. <br><br><blockquote>  <font color="#808080">// return an array of all found lines</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> lookForMatches <font color="#66cc66">(</font> <font color="#66cc66">)</font> : <font color="#0066CC">Array</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> matchList: <font color="#0066CC">Array</font> = <font color="#000000">new</font> <font color="#0066CC">Array</font> <font color="#66cc66">(</font> <font color="#66cc66">)</font> ; <br><br>  <font color="#808080">// search for horizontal lines</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> row: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; row <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; row ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> col: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; col <font color="#66cc66">&lt;</font> <font color="#cc66cc">6</font> ; col ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> match: <font color="#0066CC">Array</font> = getMatchHoriz <font color="#66cc66">(</font> col, row <font color="#66cc66">)</font> ; <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> match. <font color="#0066CC">length</font> <font color="#66cc66">&gt;</font> <font color="#cc66cc">2</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  matchList.  <font color="#0066CC">push</font> <font color="#66cc66">(</font> match <font color="#66cc66">)</font> ; <br>  col + = match.  <font color="#006600">length</font> - <font color="#cc66cc">1</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br><br>  <font color="#808080">// search for vertical lines</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> col = <font color="#cc66cc">0</font> ; col <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; col ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> row = <font color="#cc66cc">0</font> ; row <font color="#66cc66">&lt;</font> <font color="#cc66cc">6</font> ; row ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  match = getMatchVert <font color="#66cc66">(</font> col, row <font color="#66cc66">)</font> ; <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> match. <font color="#0066CC">length</font> <font color="#66cc66">&gt;</font> <font color="#cc66cc">2</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  matchList.  <font color="#0066CC">push</font> <font color="#66cc66">(</font> match <font color="#66cc66">)</font> ; <br>  row + = match.  <font color="#006600">length</font> - <font color="#cc66cc">1</font> ; <br>  <font color="#66cc66">}</font> <br><br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#b1b100">return</font> matchList; <br>  <font color="#66cc66">}</font> </blockquote><br>  <b>GetMatchHorizon</b> and <b>getMatchVert functions</b> <br>  Let's <b>sort the getMatchHorizon</b> function.  Given the column and row passed into it, she checks the next chip for a match.  If so, it is added to the array.  Continues to move horizontally until it encounters a mismatch.  Then she reports that the array is compiled.  It can even be composed of a single chip, if the next does not match.  And it can return a few. <br><br><blockquote>  <font color="#808080">// search for horizontal lines from a given point</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> getMatchHoriz <font color="#66cc66">(</font> col, row <font color="#66cc66">)</font> : <font color="#0066CC">Array</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> match: <font color="#0066CC">Array</font> = <font color="#000000">new</font> <font color="#0066CC">Array</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> <font color="#66cc66">)</font> ; <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> i: <font color="#0066CC">int</font> = <font color="#cc66cc">1</font> ; col + i <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; i ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#0066CC">type</font> == grid <font color="#66cc66">[</font> col + i <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#0066CC">type</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  match.  <font color="#0066CC">push</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col + i <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">return</font> match; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#b1b100">return</font> match; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  The <b>getMatchVert</b> function <b>is</b> almost identical to <b>getMatchHorizon</b> , except that the search is performed not by rows but by columns. <br><br><blockquote>  <font color="#808080">// search for vertical lines from a given point</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> getMatchVert <font color="#66cc66">(</font> bol, row <font color="#66cc66">)</font> : <font color="#0066CC">Array</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> match: <font color="#0066CC">Array</font> = <font color="#000000">new</font> <font color="#0066CC">Array</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> <font color="#66cc66">)</font> ; <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> i: <font color="#0066CC">int</font> = <font color="#cc66cc">1</font> ; row + i <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; i ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#0066CC">type</font> == grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row + i <font color="#66cc66">]</font> . <font color="#0066CC">type</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  match.  <font color="#0066CC">push</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row + i <font color="#66cc66">]</font> <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> <font color="#b1b100">else</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">return</font> match; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#b1b100">return</font> match; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  <b>Function affectAbove</b> <br>  Consider <b>affectAbove</b> .  We pass the chip into it, and we expect her to tell all the chips above her that she can move a step down.  In the cycle we look through the chips in the column above the current one.  For example, if the current <b>[5] [6]</b> , then check <b>[5] [5]</b> , <b>[5] [4]</b> , <b>[5] [3]</b> , <b>[5] [2]</b> , <b>[5] [1]</b> , <b>[ 5] [0]</b> in that order.  The row value of these chips is increased by 1. In addition, they transmit new data about their location to the grid.  Remember that with the <b>movePieces</b> function <b>,</b> we don‚Äôt have to worry about animation.  We just give the chip a new location. <br><br><blockquote>  <font color="#808080">// causes all the chips above the passed into the function to move down</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> affectAbove <font color="#66cc66">(</font> piece: Piece <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> row: <font color="#0066CC">int</font> = piece. <font color="#006600">row</font> - <font color="#cc66cc">1</font> ; row <font color="#66cc66">&gt;</font> = <font color="#cc66cc">0</font> ; row-- <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> piece. <font color="#006600">col</font> <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> <font color="#66cc66">!</font> = <font color="#000000">null</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  grid <font color="#66cc66">[</font> piece.  <font color="#006600">col</font> <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> .  <font color="#006600">row</font> ++; <br>  grid <font color="#66cc66">[</font> piece.  <font color="#006600">col</font> <font color="#66cc66">]</font> <font color="#66cc66">[</font> row + <font color="#cc66cc">1</font> <font color="#66cc66">]</font> = grid <font color="#66cc66">[</font> piece.  <font color="#006600">col</font> <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> ; <br>  grid <font color="#66cc66">[</font> piece.  <font color="#006600">col</font> <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> = <font color="#000000">null</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> </blockquote><br><br>  <b>AddNewPieces function</b> <br>  The next function we need to write is <b>addNewPieces</b> .  It checks all empty ( <b>null</b> ) cells in the grid and fills them with new chips.  Although the <b>col</b> and <b>row</b> values ‚Äã‚Äãget their final value, y gets the value at the top of the screen, so the chips fall down.  The variable <b>isDropping</b> takes <b>true</b> , which indicates the animation of the falling chip. <br><br><blockquote>  <font color="#808080">// if there is no chip in the column, add a new one falling from above.</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> addNewPieces <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> col: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; col <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; col ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> missingPieces: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> row: <font color="#0066CC">int</font> = <font color="#cc66cc">7</font> ; row <font color="#66cc66">&gt;</font> = <font color="#cc66cc">0</font> ; row-- <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> == <font color="#000000">null</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> newPiece: Piece = addPiece <font color="#66cc66">(</font> col, row <font color="#66cc66">)</font> ; <br>  newPiece.  <font color="#006600">y</font> = offsetY-spacing-spacing <font color="#66cc66">*</font> missingPieces ++; <br>  isDropping = <font color="#000000">true</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> </blockquote><br><br>  <b>Search for possible moves</b> <br>  Finding possible lines is not much easier than finding lines. <br>  The easiest way is to go through the board, making an exchange for each piece.  <b>[0] [0]</b> with <b>[1] [0]</b> , then <b>[1] [0]</b> with <b>[2] [0]</b> , etc.  With each exchange, we look for lines, and when we find the first one, we stop searching and return <b>true</b> .  Such a brute-force approach will work, but it will be very slow, especially on older machines.  There is a more efficient way. <br>  What options can we have to draw a line?  Usually these are two chips of the same type in a row.  The third chip is different in type, but can be exchanged for any of the three in free directions.  Or, two chips of the same type are separated by one chip of another type, and now an exchange in 2 directions can occur. <br>  The figure shows us these two cases divided into 6 patterns. <br><br><img src="https://habrastorage.org/storage1/c74a1f69/0aea100c/aea0b9af/74f58db7.jpg"><br><br>  Now, knowing that there are only a few templates that we have to find, we can begin using the <b>lookForMatches</b> function on the principle of top-down programming, and we will take care of the template search function later. <br>  Looking at the picture we will see two black chips that are included in the line and 3 chips that may possibly be of the same type.  Denote the leftmost black chip as <b>[0] [0]</b> .  We see that the chip <b>[1] [0] of</b> the same type.  It remains to find the same chip on the position <b>[-1] [- 1]</b> , <b>[-2] [0]</b> or <b>[-1] [1]</b> .  And also on the other hand <b>[2] [- 1]</b> , <b>[2] [1]</b> and <b>[3] [0]</b> .  So, we have to find in 6 positions at least one matching chip. <br><br><img src="https://habrastorage.org/storage1/60662eeb/b7288c1b/221d40a6/5c765e4f.jpg"><br><br>  When you call a function, we will pass into it an array of two chips matching in type, and an array of chips surrounding a third, of which at least one must match.  It will look something like this. <br>  <b>matchPattern ( <font color="red">col, row, [[1, 0]]</font> , <font color="blue">[[-2, 0], [- 1, -1], [- 1, 1], [2, -1], [2, 1], [3, 0]]</font> )</b> <br>  We also need a similar function for the other examples of patterns in fig.  8.9.  They are both vertical. <br>  The <b>lookForPossibles</b> function searches all board positions. <br><br><blockquote>  <font color="#808080">// check for possible moves on drawing up lines on the field</font> <br>  <font color="#0066CC">public</font> <font color="#000000">function</font> lookForPossibles <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> col: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; col <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; col ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> row: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; row <font color="#66cc66">&lt;</font> <font color="#cc66cc">8</font> ; row ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br><br>  <font color="#808080">// Possible horizontal, two in a row</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> matchPattern <font color="#66cc66">(</font> col, row, <font color="#66cc66">[</font> <font color="#66cc66">[</font> <font color="#cc66cc">1</font> , <font color="#cc66cc">0</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#66cc66">[</font> - <font color="#cc66cc">2</font> , <font color="#cc66cc">0</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> - <font color="#cc66cc">1</font> , - <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> - <font color="#cc66cc">1</font> , <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#cc66cc">2</font> , - <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#cc66cc">2</font> , <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#cc66cc">3</font> , <font color="#cc66cc">0</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">return</font> <font color="#000000">true</font> ; <br>  <font color="#66cc66">}</font> <br><br>  <font color="#808080">// Possible horizontal, two on opposite sides</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> matchPattern <font color="#66cc66">(</font> col, row, <font color="#66cc66">[</font> <font color="#66cc66">[</font> <font color="#cc66cc">2</font> , <font color="#cc66cc">0</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#66cc66">[</font> <font color="#cc66cc">1</font> , - <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#cc66cc">1</font> , <font color="#cc66cc">1</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">return</font> <font color="#000000">true</font> ; <br>  <font color="#66cc66">}</font> <br><br>  <font color="#808080">// possible vertical, two in a row</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> matchPattern <font color="#66cc66">(</font> col, row, <font color="#66cc66">[</font> <font color="#66cc66">[</font> <font color="#cc66cc">0</font> , <font color="#cc66cc">1</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#66cc66">[</font> <font color="#cc66cc">0</font> , - <font color="#cc66cc">2</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> - <font color="#cc66cc">1</font> , - <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#cc66cc">1</font> , - <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> - <font color="#cc66cc">1</font> , <font color="#cc66cc">2</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#cc66cc">1</font> , <font color="#cc66cc">2</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#cc66cc">0</font> , <font color="#cc66cc">3</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">return</font> <font color="#000000">true</font> ; <br>  <font color="#66cc66">}</font> <br><br>  <font color="#808080">// Possible vertical, two on opposite sides</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> matchPattern <font color="#66cc66">(</font> col, row, <font color="#66cc66">[</font> <font color="#66cc66">[</font> <font color="#cc66cc">0</font> , <font color="#cc66cc">2</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#66cc66">[</font> - <font color="#cc66cc">1</font> , <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> <font color="#cc66cc">1</font> , <font color="#cc66cc">1</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">return</font> <font color="#000000">true</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br><br>  <font color="#808080">// no possible lines found</font> <br>  <font color="#b1b100">return</font> <font color="#000000">false</font> ; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  Although the <b>matchPattern</b> function will perform an important task, it is not a big one in itself.  She gets the type of chips from certain <b>col</b> and <b>row</b> .  Then she goes through the <b>mustHave</b> list and checks the chips in the appropriate positions.  If no match is found, the double line is not found, there is no point in continuing and the function returns <b>false</b> .  Otherwise, every <b>needOne token is</b> checked.  If at least one token is the same type, return <b>true</b> .  If none, return <b>false</b> . <br><br><blockquote>  <font color="#0066CC">public</font> <font color="#000000">function</font> matchPattern <font color="#66cc66">(</font> col, row: uint, mustHave, needOne: <font color="#0066CC">Array</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#000000">var</font> thisType: <font color="#0066CC">int</font> = grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> .  <font color="#0066CC">type</font> ; <br>  <font color="#808080">// make sure there is a second chip of the same type</font> <br><br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> <font color="#000000">var</font> i: <font color="#0066CC">int</font> = <font color="#cc66cc">0</font> ; i <font color="#66cc66">&lt;</font> mustHave. <font color="#0066CC">length</font> ; i ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> <font color="#66cc66">!</font> matchType <font color="#66cc66">(</font> col + mustHave <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> <font color="#cc66cc">0</font> <font color="#66cc66">]</font> , row + mustHave <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , thisType <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">return</font> <font color="#000000">false</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br><br>  <font color="#808080">// make sure that the third chip matches the other two</font> <br>  <font color="#b1b100">for</font> <font color="#66cc66">(</font> i = <font color="#cc66cc">0</font> ; i <font color="#66cc66">&lt;</font> needOne. <font color="#0066CC">length</font> ; i ++ <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> matchType <font color="#66cc66">(</font> col + needOne <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> <font color="#cc66cc">0</font> <font color="#66cc66">]</font> , row + needOne <font color="#66cc66">[</font> i <font color="#66cc66">]</font> <font color="#66cc66">[</font> <font color="#cc66cc">1</font> <font color="#66cc66">]</font> , thisType <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#b1b100">return</font> <font color="#000000">true</font> ; <br>  <font color="#66cc66">}</font> <br>  <font color="#66cc66">}</font> <br>  <font color="#b1b100">return</font> <font color="#000000">false</font> ; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  All comparisons in <b>matchPattern are</b> made via <b>matchType</b> .  Let's design it as a separate function.  we will often refer to chips that are not in the grid.  For example, if we pass in <b>matchPattern</b> <b>col</b> and <b>row</b> <b>[5] [0]</b> , then it makes no sense to check the chips -1, for example 4 -1, since  they do not fall into the net. <br>  The function will check if the chip is on the field, and if so, it will compare its type with the required one. <br><br><blockquote>  <font color="#0066CC">public</font> <font color="#000000">function</font> matchType <font color="#66cc66">(</font> col, row, <font color="#0066CC">type</font> : <font color="#0066CC">int</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#808080">// make sure the chip does not go beyond the field</font> <br>  <font color="#b1b100">if</font> <font color="#66cc66">(</font> <font color="#66cc66">(</font> col <font color="#66cc66">&lt;</font> <font color="#cc66cc">0</font> <font color="#66cc66">)</font> <font color="#66cc66">||</font> <font color="#66cc66">(</font> col <font color="#66cc66">&gt;</font> <font color="#cc66cc">7</font> <font color="#66cc66">)</font> <font color="#66cc66">||</font> <font color="#66cc66">(</font> row <font color="#66cc66">&lt;</font> <font color="#cc66cc">0</font> <font color="#66cc66">)</font> <font color="#66cc66">||</font> <font color="#66cc66">(</font> row <font color="#66cc66">&gt;</font> <font color="#cc66cc">7</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#b1b100">return</font> <font color="#000000">false</font> ; <br>  <font color="#b1b100">return</font> <font color="#66cc66">(</font> grid <font color="#66cc66">[</font> col <font color="#66cc66">]</font> <font color="#66cc66">[</font> row <font color="#66cc66">]</font> . <font color="#0066CC">type</font> == <font color="#0066CC">type</font> <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  <b>Score and End Game</b> <br>  In the <b>findAndRemoveMatches</b> function <b>,</b> we called <b>addScore</b> to add points to the player.  This simple function summarizes the points and transfers the necessary data to a text field on the screen. <br><br><blockquote>  <font color="#0066CC">public</font> <font color="#000000">function</font> addScore <font color="#66cc66">(</font> numPoints: <font color="#0066CC">int</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  gameScore + = numPoints; <br>  <font color="#0066CC">MovieClip</font> <font color="#66cc66">(</font> root <font color="#66cc66">)</font> .  <font color="#006600">scoreDisplay</font> .  <font color="#0066CC">text</font> = <font color="#0066CC">String</font> <font color="#66cc66">(</font> gameScore <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  If there are no more possible moves on the field, the endGame function takes us on the timeline to the <b>gameover</b> frame.  It also uses <b>swapChildIndex</b> to push the gameSprite into the background, so all the sprites of the <b>gameover</b> frame will be above the playing field. <br>  We do this in order not to remove the playing field after the end of the game, but leave it to the player for consideration. <br><br><blockquote>  <font color="#0066CC">public</font> <font color="#000000">function</font> endGame <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  <font color="#808080">// move to background</font> <br>  setChildIndex <font color="#66cc66">(</font> gameSprite, <font color="#cc66cc">0</font> <font color="#66cc66">)</font> ; <br>  <font color="#808080">// go to the game end screen</font> <br>  <font color="#0066CC">gotoAndStop</font> <font color="#66cc66">(</font> <font color="#ff0000">"gameover"</font> <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> </blockquote><br><br>  We will remove the grid when the player is ready to move on.  To do this, call the <b>cleanup</b> function. <br><br><blockquote>  <font color="#0066CC">public</font> <font color="#000000">function</font> cleanUp <font color="#66cc66">(</font> <font color="#66cc66">)</font> <font color="#66cc66">{</font> <br>  grid = <font color="#000000">null</font> ; <br>  removeChild <font color="#66cc66">(</font> gameSprite <font color="#66cc66">)</font> ; <br>  gameSprite = <font color="#000000">null</font> ; <br>  removeEventListener <font color="#66cc66">(</font> Event. <font color="#006600">ENTER_FRAME</font> , movePieces <font color="#66cc66">)</font> ; <br>  <font color="#66cc66">}</font> </blockquote><br>  On the timeline, the <b>cleanUp</b> function binds to the <b>playAgain</b> button and starts before starting a new game. <br><br>  <b>Modification of the game</b> <br>  The important decision to take is how many types of chips you want to use in the game.  Most match3 games use six.  Using seven faster will result in an unsolvable combination. <br><br>  Well, that's basically all.  We have a ready-made engine for creating a game based on the match3 mechanics.  I hope that someone will give impetus to the creation of games. <br><br>  Sources can be downloaded <a href="">here</a> .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And I do not insist, but you can always buy this book, than express the most effective thanks to the author.</font></font><br><br>  <b>UPD.</b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A small addition.</font></font></b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> How else can you improve the game. Well, first hints. Everyone probably noticed tips in games on such mechanics. When a player does nothing for a long time, two chips begin to wink with which you can make an exchange. All this can be done with the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lookForPossibles</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">. And how, will remain as homework. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Second, bonus chips. You can always include another Bonus layer of the same type as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Select</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in our USB flash drive </font><font style="vertical-align: inherit;">. And fit the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bonus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> property to the chip </font><font style="vertical-align: inherit;">. And then I think it is clear how to use the click on this chip and additional points. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now an important note, prompted from the comments in a personal blog. This is not mentioned in the book anywhere, but it is better not to miss this moment.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. In the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setUpGrid</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> we in a loop create the initial field of the game. And each cycle we add chips, regardless of whether the field was created playable or not. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. In the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addPiece</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><b><font style="vertical-align: inherit;">,</font></b><font style="vertical-align: inherit;"> we hang a listener ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addEventListener</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><font style="vertical-align: inherit;">on each </font><b><font style="vertical-align: inherit;">piece</font></b><font style="vertical-align: inherit;"> . And with its (chips) removal, we do not remove it ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">removeEventListener</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What should we get out of here? Such defects will sooner or later lead to memory leaks. What corrections can we make to our code? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Add chips when we have a playable field in front of us. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Use the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weakReference</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> flag </font><font style="vertical-align: inherit;">. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Example: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object.addEventListener (Event.CLICK, handleClick false, 0, true)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When removing chips, it is recommended to use </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">removeEventListener</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks for the tips.</font></font></div><p>Source: <a href="https://habr.com/ru/post/124972/">https://habr.com/ru/post/124972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../124965/index.html">What is consulting about? And for what?</a></li>
<li><a href="../124966/index.html">The strange behavior of the dev server when using the GAE Plugin for Eclipse Indigo (3.7)</a></li>
<li><a href="../124968/index.html">Why is everything: the answer to Yandex from the developers of Shop-Script</a></li>
<li><a href="../124969/index.html">Is there life on the site?</a></li>
<li><a href="../124970/index.html">Intel Data Center Tour</a></li>
<li><a href="../124974/index.html">Objective-C: a rubist look</a></li>
<li><a href="../124975/index.html">Google +1 plus has gone on sale: what will come of the social network crossing with a search</a></li>
<li><a href="../124976/index.html">First arrest for possession of the virus</a></li>
<li><a href="../124978/index.html">Clustering Algorithm a-quasi-equivalence</a></li>
<li><a href="../124980/index.html">Which Ruby do you prefer to use for Rails 2.3 projects?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>