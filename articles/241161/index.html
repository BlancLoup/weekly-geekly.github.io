<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How I made friends with asynchronous JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript meets developers asynchronously can be said almost from the threshold. It starts with DOM events, ajax, timers, and library methods associa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How I made friends with asynchronous JavaScript</h1><div class="post__text post__text-html js-mediator-article"><img align="right" src="https://habrastorage.org/files/008/4de/fb8/0084defb8257442fbccd1fd3f5a898df.png">  JavaScript meets developers asynchronously can be said almost from the threshold.  It starts with DOM events, ajax, timers, and library methods associated with animation (for example, jQuery methods fadeIn / fadeOut, slideUp / slideDown).  In general, all this is not very difficult and to deal with asynchrony at this stage is not a problem.  However, as soon as we turn to writing more or less complex applications that combine all of the above, an asynchronous stream can make it very difficult to understand what is happening in the code.  Chains of asynchronous actions, for example, animation&gt; ajax request&gt; initialization -&gt; animation, create a rather complex architecture that does not follow the strict bottom-up direction.  In this article I intend to tell you about my experience in overcoming the difficulties associated with asynchronous JS. <br><a name="habracut"></a><br>  I remember, at first, one of the most amazing moments in JavaScript for me was the following: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>; i++){ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(i); }, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  It was amazing to see: <br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  Instead of the expected: <br><pre> <code class="javascript hljs"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br>  <i>Tedious entry</i> <br><br>  So I realized that asynchrony should not be perceived as something that is executed when you ‚Äúapproximately‚Äù expect this (0 milliseconds, for example), and when the execution of the ‚Äúsynchronous‚Äù flow (blocking) ends, i.e., ‚Äúas soon as the opportunity ".  It is not easy to make a sensible analogy, since in real life almost all processes are asynchronous.  Imagine you are the manager of a construction company.  You have received an order to build a house on a turnkey basis, but only a third-party company has permission for a certain type of work on this site (for example, building a house), and you have to contact them.  You already have a well-established algorithm: pour the foundation, build a house, paint the house, refine the plot and so on, however, in our case you don‚Äôt build a house and don‚Äôt even know when it will be built.  This is an asynchronous process, your task is to simply transfer the layout to the company and get the finished building.  When you build a house, everything is simple, your attention is focused on the current process: construction, then painting and so on.  However, now you are not building a house.  And you somehow need to organize the work of your team, given the circumstances.  This best explains why it‚Äôs not worthwhile to block the flow of execution for asynchronous processes ‚Äî it is idle.  If the thread does not block, then as long as an asynchronous action occurs, you can do something else. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The most common mistake, newbie, in terms of JavaScript looks like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">layout</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//...         //...   ,   JS  (  house) } function paintRoof(house, color){ house.roof.color = color return house; } var layout = {/*  - */}, house = {}; Build(layout, house); paintRoof(house, 'red');</span></span></code> </pre><br>  Obviously, it will return a <i>TypeError</i> and say that it cannot read the roof property in undefined, since  house.foof will still be undefined (it just simply did not have time to build).  We must somehow wait until the house is initialized, but we do not know when this will happen. <br><br>  I apologize for the tedious introduction, then I will try to explain how in the context of the topic of this article you can solve this problem with the help of JavaScript. <br><br><h4>  Idea </h4><br>  In fact, there are not so many tools.  Returning to the example of a construction company, you, as a manager, know which processes are dependent on each other.  All operations with the house (painting, interior arrangement, etc.) are impossible until the house itself is built.  However, for example, digging a pool, erecting a fence and some other actions are quite realizable.  How to settle the workflow?  Obviously, as long as the contractors build the house, we will go about our business, but we also need to decide how we will know when they finish their work (as ridiculous as it sounds in real life).  There are two ideas: <br><ul><li>  Periodically asking contractors if the house is ready or not? </li><li>  Ask contractors to tell us when the house is ready. </li></ul><br>  From the point of view of JavaScript, there are three options: <br><ul><li>  Periodically check the system status, which can change only as a result of the asynchronous function. </li><li>  Register the callback function (callback), and transfer control to it, at the end of the asynchronous process. </li><li>  At the end of the asynchronous action, post an event that we will listen to in order to hang some handler on it. </li></ul><br>  Consider these options closer. <br>  I argue that the first option is no good, because it is built on timers and numerous checks.  In the simplest case, states are boolean variables.  But after all, asynchronous functions can be a processing of an object that has not only 2 states, but much more.  And we must respond to each combination of completed states differently.  Imagine 3 asynchronous calls that can affect system states only by changing the boolean variable from false to true when the asynchronous action ends.  This situation already generates 8 (2 <sup>3</sup> ) general system states.  You can see for yourself that such an architecture is practically incompatible, and in complex applications, simplicity of layout is often the decisive factor.  Checking combinations of states is not an easy task, especially if they are not subject to any logic.  Obviously, in terms of cleanliness and clarity of the code, this is a complete nightmare. <br><br><div class="spoiler">  <b class="spoiler_title">You do not want such fragments to flash in your code?</b> <div class="spoiler_text"><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(state1 == <span class="hljs-string"><span class="hljs-string">'success'</span></span> &amp;&amp; state2 == <span class="hljs-string"><span class="hljs-string">'success'</span></span>){ ... }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(state1 == <span class="hljs-string"><span class="hljs-string">'success'</span></span> &amp;&amp; state2 == <span class="hljs-string"><span class="hljs-string">'error'</span></span>){ ... }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(state1 == <span class="hljs-string"><span class="hljs-string">'error'</span></span> &amp;&amp; state2 == <span class="hljs-string"><span class="hljs-string">'success'</span></span>){ ... }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(state1 == <span class="hljs-string"><span class="hljs-string">'error'</span></span> &amp;&amp; state2 == <span class="hljs-string"><span class="hljs-string">'error'</span></span>){ ... }<span class="hljs-keyword"><span class="hljs-keyword">else</span></span>{ setTimeout(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.callee, <span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        } },50</span></span></code> </pre><br></div></div><br>  So what options do we have? <br><br><h3>  The first option is the Promise way. </h3><br>  It's very simple, we pass the callback function to the asynchronous function that it will call when finished. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">layout, onComplete</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... async onComplete(house); } Build(layout, function(buildedHouse){ return house = paintRoof(buildedHouse, 'red'); });</span></span></code> </pre><br>  This path will lead you sooner or later to PromiseAPI, which provides an opportunity to respond to 2 logical results of completing an asynchronous action: in case of success and in case of error.  If you do not implement yourself or do not use ready-made implementations of PromiseAPI (such as <a href="https://github.com/kriskowal/q">Q</a> ), then, by analogy with popular implementations, you can transfer 2 callbacks for asynchronous functions for different results.  This way you solve the problem of constant tracking changes.  Now, when changes occur, the callback functions work themselves. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">layout, success, error</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//...   ok - true ,     return ok ? success(house) : error(new Error("-   ")); } Build(layout, function(buildedHouse){ return house = paintRoof(buildedHouse, 'red'); }, function(error){ throw(error); } );</span></span></code> </pre><br><br>  This approach also has obvious disadvantages.  First, the functions are too intricate in the case of a sequence of asynchronous actions, for example, if there are already 3 of them, then it may look like this: <br><br><pre> <code class="javascript hljs">async1(args, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{ async2(response, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{ async3(response, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{ hooray(response); <span class="hljs-comment"><span class="hljs-comment">//   Node.js. }); }); });</span></span></code> </pre><br>  And secondly, lack of management flexibility: when developing application pieces, we take responsibility in ensuring the correct execution of callbacks on ourselves.  The problem is not even a guarantee, <b>some of the callbacks will work exactly, that's the whole essence of Promise</b> .  The problem is that if we again want to <i>assemble competitive events</i> , we do not know which callback will work first, but sometimes it is important to us.  Another problem: we register callbacks of some modules inside asynchronous functions of other modules, further, they work and we have to either connect callbacks through the backdoor to the external state of the application, or use global (or adjacent between the modules) data.  Both that and other option, we will tell so, not the best idea.  We have to carefully design the architecture, specially sharpened to prevent mixing of competitive events, while we could use a much higher level abstraction and apply it in all similar cases.  If it immediately occurred to you that you can create some kind of wrapper over an asynchronous stream, then congratulations, the idea of ‚Äã‚ÄãPromiseAPI has reached you.  Fortunately, now there is an opportunity to write in the style: <br><br><pre> <code class="javascript hljs">async1.then(async2).then(async3).then(hooray);</code> </pre><br>  The most beautiful thing is that you can always choose a design pattern that, as it were, encourages us to use PromiseAPI, including it as our own component.  Most modern MV * JavaScript frameworks are based on this.  A good example is the $ q service in Angular.js. <br>  As a nishtyak, and if you follow the news, it will not surprise you that some modern browsers already support the native implementation of the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a> .  Considering the specifications of PromiseAPI is beyond the scope of this article, but I highly recommend reading <a href="http://habrahabr.ru/post/209662/">this article</a> and familiarizing yourself with the <a href="http://wiki.commonjs.org/wiki/Promises">Common.js Promises</a> specification. <br><br><h3>  The second option is Pub / Sub path. </h3><br>  The asynchronous function reports that it ended by posting an event.  In this case, we logically separate the part of the code that publishes events from the part of the code that responds to events.  This can be justified if the application we write can be clearly logically divided into several modules, each of which performs strictly delineated functionality, but, moreover, they need to interact. <br><div class="spoiler">  <b class="spoiler_title">Example</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> manager = {<span class="hljs-comment"><span class="hljs-comment">/* */</span></span>} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">layout</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//...  ,    manager.emit({ "type" : "ready", "msg" : " ", "house" : buildedHouse }); } manager.on("ready", function(event){ return house = paintRoof(event.house, 'red'); }); Build(layout);</span></span></code> </pre><br></div></div><br><br>  At first glance, this approach is not much different from registering callback functions in asynchronous methods, but the main difference is that you yourself control the interaction between the event publisher and the subscriber, which gives some freedom, but is associated with some costs (see the pattern ‚Äú Mediator").  The main disadvantage of this approach is that you need an event subscriber who listens on the object for the occurrence of an event and calls a registered callback.  It does not have to be a separate object (as in the previous example), there are many implementation options.  Often, different ‚Äúlogical layers‚Äù arise between modules, - pseudomodules serving the interaction of modules outside the context of other modules.  However, in comparison with promises, this approach is more flexible. <br><div class="spoiler">  <b class="spoiler_title">An asynchronous function can return an object with a binding method ‚Äî just like the PromiseAPI, the asynchronous function returns a promise object.</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Build</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">layout</span></span></span><span class="hljs-function">) </span></span>{ ... return { <span class="hljs-attr"><span class="hljs-attr">bind</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event, callback</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// bind } } } var house = Build(layout); house.bind('ready', function(event){...});</span></span></code> </pre><br></div></div><br>  Strictly speaking, this is only a matter of implementing the Pub / Sub pattern.  How you do it is not so important.  If you wrote on NodeJS, you should be familiar with <a href="http://nodejs.org/api/events.html">EventEmitter</a> , then you understand how important (and cool!) It is to be able for any class to use the methods of issuing and listening to events.  If we are talking about programming for the browser, there are quite a few options.  Most likely you, sooner or later, decide to use the trigger methods of the framework you are using, most of the MV * frameworks allow you to do this easily and painlessly (and some <a href="https://angularjs.org/">:)</a> allow you not to do it at all).  In any case, the theory is described in sufficient detail.  One of the positive examples is the combination of modular-facade-mediator patterns, more details on this can be found <a href="http://largescalejs.ru/the-mediator-pattern/">here</a> . <br><br><h3>  Design </h3><br>  When you start writing more or less large applications, you want to separate the logical parts of the architecture so that you can develop and maintain them separately from each other.  In asynchronous programming, the modules do not return the result immediately after calling the API method, and therefore the sequential execution of requests to the module and processing responses by other parts of the application is fundamentally impossible.  The ability to register a processor inside the module from the outside is quite a satisfactory method, but you have to understand that if you plan to expand the interaction between modules, you can come to a ‚Äúcallback hell‚Äù that should be avoided.  On the other hand.  Sometimes there are quite simple modules that provide the final API, which is unlikely to scale, then the architecture on the direct implementation of callbacks can also satisfy your requirements. <br><div class="spoiler">  <b class="spoiler_title">For example, a module based on jQuery managing ajax-preloader</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> AjaxPreloader = (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AjaxPreloader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spinner</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.spinner = spinner; } AjaxPreloader.prototype.show = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">onComplete</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.spinner.fadeIn(onComplete); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }; AjaxPreloader.prototype.hide = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">onComplete</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.spinner.fadeOut(onComplete); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AjaxPreloader; })(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> preloader = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AjaxPreloader($(<span class="hljs-string"><span class="hljs-string">"#preloader"</span></span>)); preloader.show(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ div.load(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, preloader.hide); });</code> </pre><br><br>  If you decided to switch to the PromiseApi side, you would get rid of these nestings and with a few modifications you would write like this: <br><pre> <code class="javascript hljs">preloader .show() .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> div.load(<span class="hljs-string"><span class="hljs-string">'/'</span></span>) }) .then( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">)</span></span>{}, <span class="hljs-comment"><span class="hljs-comment">//success function(error){} //error ) .always(preloader.hide);</span></span></code> </pre><br><br>  Very declarative.  And we can sleep peacefully, knowing that the AjaxPreloader module will never start returning functions that require an argument, one more callback, and so on.  If it is possible to design just such modules, do it.  The simpler the modules, and especially their public API, the better. <br></div></div><br><br>  <i>It is important to be able to understand when to choose some tools, and when others.</i> <br>  Surely you wrote small applications, and you had to use the following scheme: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = $(<span class="hljs-string"><span class="hljs-string">"#container"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ,     root.on("someEvent", function(){ // }); root.trigger("someEvent"); //    root</span></span></code> </pre><br>  In order not to register callbacks inside any application modules, and especially not to pay attention to the execution context, but, moreover, to preserve the logical separation of application parts, many simply emit a custom event on some DOM element, in order to catch it in some other place the application and perform the necessary actions.  Thus, modules depend on only one element, and we, instead of registering callbacks, simply pass an extra parameter to the module ‚Äî the document element we are going to listen on.  Strictly speaking, this is a rather controversial practice, but the idea itself is good.  When a module publishes events, and the application listens on them, it is quite convenient in many ways. <br>  For me, it has become commonplace to use a wrapper over objects, which extends modules with standard Pub / Sub methods. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">module</span></span> = PubSub({ <span class="hljs-attr"><span class="hljs-attr">load</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">)</span></span>{ ... this.emit(<span class="hljs-string"><span class="hljs-string">'loaded'</span></span>, data); } }); <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.on(<span class="hljs-string"><span class="hljs-string">'loaded'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function">)</span></span>{ ... });</code> </pre><br>  In this case, the module emits events and is itself a subscriber.  The alternative architecture - one subpart for all modules, in general, looks more centralized, but this is just one more layer between the events of the module and the application.  Most often this is not necessary, moreover, one should not think that such a repeater is essentially a facade, if it is only collecting events and registering handlers, and this is unconditional (for example, multi-level nesting of the application architecture), then this is only unnecessary interlayer.  In addition, another word against a centralized architecture is that composing competitive events in this way becomes harder and harder as the number of application modules increases.  I will not simulate rare situations where the application includes modules whose tasks include data synchronization between the server and the client, where there may be several clients, and participants publish competing joint events.  I hope you yourself understand how simplified the arrangement of heterogeneous events is when the modules can only be interconnected via a bus of subscriptions and publications.  This is very convenient when it comes to components that can interact with each other without the need to pull the centralized control unit. <br><br><h3>  Event-driven applications </h3><br>  Recently, the actual theme for me is the arrangement of events.  The unpleasant side is that events occur not only in different places, but also at different times.  To combine disparate events without any special tricks, to put it mildly, is unpleasant.  With all this, there is a special kind of application that can be described as ‚Äúhighly event-driven‚Äù, which consist of many different parts.  These parts can interact with each other, with the user, send data to the server, or just hang in a hold.  Attempts to organize all possible combinations of events using traditional imperatives if / then / else is a combinatorial brain explosion.  Oddly enough, the methodology of functional programming applied to such applications makes life much easier.  There are several libraries that provide the ability to describe complex dependencies between different events in the declarative style of the usual functional programming (see Bacon.JS, Reactive Extensions - RxJS).  I will not analyze these libraries in this article, only I will say that now I use a samopisny library, something similar to Bacon.js, but with more emphasis on the layout and destructuring of the asynchronous flow.  I provide a fragment of the working code supplied with comments: <br><div class="spoiler">  <b class="spoiler_title">A snippet of code from a mini-toy a la Swarmation using a web-socket</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   var keyups = obj.stream('keyup'), arrowUps = keyups.filter(isArrows); //   function isArrows(which){ ... } //    function vectorDirection(which){ ... } //   event.which    vector2 function allowedMoves(direction){ ... } //    function isWinerPosition(pos){ ... } //    //  enemy.moves = socket.stream('playerMoves'); //    player.moves = arrowUps.filter(allowedMoves).map(vectorDirection); //   game.ticks = timer.stream('tick'); //   game.pause = keyups.filter(function(which){ return which==19}); //     //  game.ticks.syncWith(enemy.moves).listen(redraw); //           player.moves.listen(redraw); //    game.ticks .syncWith(enemy.moves) //       .produceWith(playerMoves, function(pos1, pos2){ //      if(cmp.equals(pos1, pos2)){ //     socket.emit('win'); //    game.ticks.lock(); //    game.emit('loose', { position : pos1, }); } }); game.pause.toggle([ //      function(){ game.ticks.lock(); //    player.moves.lock(); //     socket.emit('pause'); //      - }, function(){ game.ticks.unlock(); //    player.moves.unlock(); socket.emit('run'); } ]); player.moves .filter(isWinnerPosition) //  ,      .listen(function(pos){ game.ticks.lock(); //    socket.emit('loose'); //      game.emit('win', { //   . ! position: pos }); });</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not delve into the essence of this code, this is just an example of how easy (and most importantly, declaratively, you can describe the logic of interactions between objects based on the flow of their events. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, the reader‚Äôs question: would you be interested in an article on this topic?</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I'm going to bring the library and write a demo web application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thank you for your attention, may the force be with you!</font></font></div><p>Source: <a href="https://habr.com/ru/post/241161/">https://habr.com/ru/post/241161/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../241149/index.html">SPB Frontend: October meeting</a></li>
<li><a href="../241151/index.html">Dnipropetrovsk Ciklum Speakers' Corner "Google Guava: make your code easier and faster", October 23</a></li>
<li><a href="../241153/index.html">Portal to search for like-minded people when creating projects</a></li>
<li><a href="../241155/index.html">Expressive JavaScript: Higher Order Functions</a></li>
<li><a href="../241157/index.html">About the VeeamON First-Hand Conference - Not Everything That Was in Vegas Remains in Vegas</a></li>
<li><a href="../241163/index.html">7 effective A / B testing with welcome letters</a></li>
<li><a href="../241165/index.html">Work with information partners of the hackathon. HackDay Experience</a></li>
<li><a href="../241167/index.html">Trial period for SaaS: requesting a credit card is a short-sighted undertaking</a></li>
<li><a href="../241171/index.html">New Disney cartoon rendered on 55,000 cores</a></li>
<li><a href="../241177/index.html">Gamepad of your dream! Choosing a game controller according to needs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>