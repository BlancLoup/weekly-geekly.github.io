<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understanding lvalue and rvalue in C and C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! I present to you the translation of the article Eli Bendersky , Understanding of lvalues ‚Äã‚Äãand rvalues ‚Äã‚Äãin C and C ++ . 

 From the transla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understanding lvalue and rvalue in C and C ++</h1><div class="post__text post__text-html js-mediator-article"> Hi, Habr!  I present to you the translation of the article <b>Eli Bendersky</b> , <i><a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c">Understanding of lvalues ‚Äã‚Äãand rvalues ‚Äã‚Äãin C and C ++</a></i> . <br><br>  From the translator: I <i>bring to your attention the translation of an interesting article on lvalue and rvalue in C / C ++ languages.</i>  <i>The topic is not new, but it‚Äôs never too late to know about these concepts.</i>  <i>The article is designed for beginners, or for programmers migrating from C (or other languages) to C ++.</i>  <i>Therefore, be prepared for detailed chewing.</i>  <i>If you're interested, welcome under the cat.</i> <br><a name="habracut"></a><br>  The terms <i>lvalue</i> and <i>rvalue</i> are not something that one often encounters when programming in C / C ++, and when they meet, it doesn‚Äôt immediately become clear what exactly they mean.  The most likely place to run into them is the compiler messages.  For example, when compiling the following code with the <code>gcc</code> compiler: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { foo() = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  You get the following: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="bash hljs">test.c: In <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span>: test.c:8:5: error: lvalue required as left operand of assignment</code> </pre><br>  I agree that this code is a bit contrived, and you are unlikely to write something like this, but the error message mentions <i>lvalue</i> , a term that you will not often see in C / C ++ tutorials.  Another example is illustrative when compiling the following code with <code>g++</code> : <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre><br>  You will see the following error: <br><br><pre> <code class="bash hljs">testcpp.cpp: In <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-string"><span class="hljs-string">'int&amp; foo()'</span></span>: testcpp.cpp:5:12: error: invalid initialization of non-const reference of <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'int&amp;'</span></span> from an rvalue of <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'int'</span></span></code> </pre><br>  Again, the mystical <i>rvalue</i> is mentioned in the error message.  What in C and C ++ is meant by <i>lvalue</i> and <i>rvalue</i> ?  This is the topic of this article. <br><br><h2>  Simple definition </h2><br>  To begin with, we will deliberately give the definitions of <i>lvalue</i> and <i>rvalue</i> in a simplified form.  In the future, these concepts will be considered under a magnifying glass. <br><br>  <i>lvalue (locator value)</i> is an object that takes up identifiable memory space (for example, has an address). <br><br>  <i>An rvalue is</i> defined by an exception, saying that any expression is either an <i>lvalue</i> or <i>rvalue</i> .  Thus, from the definition of <i>lvalue</i> it follows that <i>rvalue</i> is an expression that is <i>not</i> an object that takes identifiable memory space. <br><br><h2>  Elementary examples </h2><br>  The terms defined above may seem a bit fuzzy.  Therefore it is necessary to immediately consider a few simple explanatory examples.  Suppose we are dealing with an integer type variable: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> = <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  The assignment operator expects an lvalue on the left side, and <code>var</code> is an lvalue because it is an object with an identifiable memory location.  On the other hand, the following spells will lead to errors: <br><br><pre> <code class="hljs swift"><span class="hljs-number"><span class="hljs-number">4</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">var</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ERROR! (var + 1) = 4; // ERROR!</span></span></code> </pre><br>  Neither the constant <code>4</code> nor the expression <code>var + 1</code> are lvalue <br>  (which is automatically made by rvalue).  They are not lvalue, because both are temporary results of expressions that do not have a certain place in memory (that is, they can be in some temporary registers for the duration of the calculations).  Thus, the assignment in this case does not carry any semantic meaning.  In other words - there is no place to assign. <br><br>  Now it should be clear what the error message in the first code fragment means.  <code>foo</code> returns a temporary value, which is an rvalue.  Attempted assignment is an error.  That is, seeing the code <code>foo() = 2;</code>  , the compiler reports that it expects an lvalue on the left side of the assignment operator. <br><br>  However, not all assignments to the result of a function call are erroneous.  For example, using links in C ++ makes this possible: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> globalvar = <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> globalvar; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foo() = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  Here, <code>foo</code> returns a link <i>that is an lvalue</i> , which means you can give it a value.  In general, in C ++, the ability to return lvalues, as a result of a function call, is essential for the implementation of some overloaded operators.  As an example, we will overload the operator <code>[]</code> in classes that implement access by search results.  For example <code>std::map</code> : <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; mymap; mymap[<span class="hljs-number"><span class="hljs-number">10</span></span>] = <span class="hljs-number"><span class="hljs-number">5.6</span></span>;</code> </pre><br>  The assignment of <code>mymap[10]</code> works because the non-constant overload <code>std::map::operator[]</code> returns a reference that can be assigned a value. <br><br><h2>  Mutable lvalue </h2><br>  Initially, when the notion of <i>lvalue</i> was introduced in C, it literally meant ‚Äúan expression applicable on the left side of an assignment operator‚Äù.  However, later, when ISO C added the keyword <code>const</code> , this definition needed to be improved.  Really: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 'a' - lvalue a = 10; //       !</span></span></code> </pre><br>  Thus, not all lvalues ‚Äã‚Äãcan be assigned a value.  Those that can be called <i>mutable lvalues</i> (modifiable lvalues).  Formally, the C99 standard defines mutable lvalues ‚Äã‚Äãas: <br><blockquote>  [...] lvalue, the type of which is not an array, is not incomplete, has no <code>const</code> specifier, is not a structure or union containing fields (also including fields recursively nested in contained aggregates and unions) with the <code>const</code> specifier. </blockquote><br><h2>  Conversions between lvalue and rvalue </h2><br>  Figuratively speaking, language constructs that operate on the values ‚Äã‚Äãof objects require rvalue as arguments.  For example, the binary operator '+' takes two rvalues ‚Äã‚Äãas arguments and returns also rvalues: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// a - lvalue int b = 2; // b - lvalue int c = a + b; // '+'  rvalue,  a  b   rvalue //  rvalue    </span></span></code> </pre><br>  As we have seen before, <code>a</code> and <code>b</code> both lvalues.  Therefore, in the third line, they undergo an implicit <i>lvalue-to-rvalue conversion</i> .  All lvalues ‚Äã‚Äãthat are not an array, a function, and not of an incomplete type can be converted to an rvalue. <br><br>  What about the other way around?  Is it possible to convert rvalue to lvalue?  Of course not!  This would violate the essence of the lvalue, according to its definition (The absence of implicit conversion means that the rvalue cannot be used where lvalue is expected). <br><br>  This does not mean that lvalues ‚Äã‚Äãcannot be obtained from an rvalue in an explicit way.  For example, the unary operator '*' (dereference) takes an rvalue as an argument, but returns an lvalue as its result.  Consider the following valid code: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* p = &amp;arr[<span class="hljs-number"><span class="hljs-number">0</span></span>]; *(p + <span class="hljs-number"><span class="hljs-number">1</span></span>) = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK: p + 1 rvalue,  *(p + 1)  lvalue</span></span></code> </pre><br>  Conversely, the unary '&amp;' (address) operator takes an lvalue as an argument and produces an rvalue: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* bad_addr = &amp;(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// :  lvalue    '&amp;' int* addr = &amp;var; // : var - lvalue &amp;var = 40; // :  lvalue    //  </span></span></code> </pre><br>  The "&amp;" character plays a slightly different role in C ++ - it allows you to define a reference type.  It is called the ‚Äúlvalue reference‚Äù.  A non-constant reference to an lvalue cannot be assigned to an rvalue, since this would require an invalid rvalue-to-lvalue conversion: <br><br><pre> <code class="hljs cpp"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; sref = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(); <span class="hljs-comment"><span class="hljs-comment">// :   //    'std::string&amp;' // rvalue  'std::string'</span></span></code> </pre><br>  Constant references to lvalue <i>can be</i> assigned to an rvalue.  Since they are constants, the value cannot be changed by reference and therefore the problem of modifying rvalue is simply missing.  This property makes it possible for one of the fundamental idioms of C ++ to be the admission of values ‚Äã‚Äãby a constant reference as function arguments, which avoids the need to copy and create temporary objects. <br><br><h2>  CV-specified rvalues </h2><br>  If you read carefully the part of the C ++ standard regarding the lvalue-to-rvalue conversion (chapter 4.1 in the draft of the C ++ 11 standard), you can see the following: <br><blockquote>  An lvalue (3.10) on a type T that is not functional, or an array, can be converted to an rvalue.  [...] If T is not a class, the type of rvalue is a cv-unspecified version of type T. Otherwise, the type of rvalue is T. <br></blockquote>  So what does cv-unspecified mean?  The CV specifier is a term used to describe <i>const</i> and <i>volatile</i> type specifiers. <br><br>  From chapter 3.9.3: <br><blockquote>  Each type that is a cv-unspecified complete or incomplete object type or void (3.9) type has three cv-specified versions, respectively: a type with a specifier const, a type with a specifier volatile and a type with specifiers const volatile.  [...] CV-specified and cv-unspecified types are different, but they have the same presentation and alignment requirements. <br></blockquote>  But how does all this relate to rvalue?  In C, rvalues ‚Äã‚Äãnever have cv-specified types.  This property is lvalue.  However, in C ++ class rvalues ‚Äã‚Äãcan be cv-specified, which does not apply to built-in types like <code>int</code> .  Consider an example: <br><br><pre> <code class="hljs kotlin">#include &lt;iostream&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: void foo() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A::foo() const\n"</span></span>; } void foo() { std::cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"A::foo()\n"</span></span>; } }; A bar() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A(); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> A cbar() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A(); } int main() { bar().foo(); <span class="hljs-comment"><span class="hljs-comment">//  foo cbar().foo(); //  foo const }</span></span></code> </pre><br>  The second line in the <code>main</code> function will call the <code>foo() const</code> method <code>foo() const</code> , since <code>cbar</code> returns an object of type <code>const A</code> , which is different from <code>A</code>  This is exactly what was meant in the last sentence of the excerpt from the standard above.  By the way, notice that the return value of <code>cbar</code> is rvalue.  This was an example of a cv-specified rvalue in action. <br><br><h2>  Links to rvalue (C ++ 11) </h2><br>  References to rvalue and the accompanying concept <i>of transfer semantics</i> are one of the most powerful tools added to C ++ 11.  A detailed discussion on this topic is beyond the scope of this modest article (you can find a lot of material just by running ‚Äúrvalue references.‚Äù Here are some resources that I find useful: <a href="http://www.artima.com/cppsource/rvalue.html">this</a> , <a href="http://stackoverflow.com/questions/5481539/what-does-t-mean-in-c0x">this</a> and <a href="http://thbecker.net/articles/rvalue_references/section_01.html">especially this one</a> ), but I would like to cite A simple example, because I believe that this chapter is the most appropriate place to demonstrate how the understanding of lvalue and rvalue expands our ability to talk about non-trivial language concepts. <br><br>  A good half of the article was spent explaining that one of the most important differences between lvalue and rvalue is the fact that lvalue can be changed, while rvalue is not.  Well, C ++ 11 adds one crucial feature in this distinction, allowing us to have references to the rvalue and thereby change them in some cases. <br><br>  As an example, consider the simplest implementation of a dynamic array of integers.  Let's look only at the methods related to the topic of this chapter: <br><br><pre> <code class="hljs java"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Intvec</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-function">explicit </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Intvec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size_t num = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(num)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">m_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(new </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">[m_size])</span></span></span><span class="hljs-function"> </span></span>{ log(<span class="hljs-string"><span class="hljs-string">"constructor"</span></span>); } ~Intvec() { log(<span class="hljs-string"><span class="hljs-string">"destructor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_data) { delete[] m_data; m_data = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } Intvec(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Intvec&amp; other) : m_size(other.m_size), m_data(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[m_size]) { log(<span class="hljs-string"><span class="hljs-string">"copy constructor"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (size_t i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; m_size; ++i) m_data[i] = other.m_data[i]; } Intvec&amp; operator=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Intvec&amp; other) { log(<span class="hljs-string"><span class="hljs-string">"copy assignment operator"</span></span>); <span class="hljs-function"><span class="hljs-function">Intvec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tmp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other)</span></span></span></span>; std::swap(m_size, tmp.m_size); std::swap(m_data, tmp.m_data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* msg)</span></span></span><span class="hljs-function"> </span></span>{ cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"] "</span></span> &lt;&lt; msg &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } size_t m_size; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>* m_data; };</code> </pre><br>  So, here are the usual constructor and destructor, the copy constructor and the assignment operator (this is the canonical implementation of the copy assignment operator from the standpoint of exception tolerance. Using the copy constructor and then not throwing the <code>std::swap</code> exception, we can be sure that intermediate state with non-initialized memory, if an exception occurs somewhere).  They all use the logging function so that we can understand when they are actually called. <br><br>  Let's run a simple code that copies the contents of <code>v1</code> to <code>v2</code> : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Intvec</span></span> v1(<span class="hljs-number"><span class="hljs-number">20</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">Intvec</span></span> v2; <span class="hljs-attribute"><span class="hljs-attribute">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"assigning lvalue...\n"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">v2</span></span> = v1; <span class="hljs-attribute"><span class="hljs-attribute">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ended assigning lvalue...\n"</span></span>;</code> </pre><br>  And here is what we will see: <br><pre> <code class="bash hljs">assigning lvalue... [0x28fef8] copy assignment operator [0x28fec8] copy constructor [0x28fec8] destructor ended assigning lvalue...</code> </pre><br>  Which is completely logical, since it accurately reflects what is happening inside the assignment operator.  But let's assume that we want to assign <code>v2</code> some rvalue: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"assigning rvalue...\n"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">v2</span></span> = Intvec(<span class="hljs-number"><span class="hljs-number">33</span></span>); <span class="hljs-attribute"><span class="hljs-attribute">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"ended assigning rvalue...\n"</span></span>;</code> </pre><br>  Although here I only assign a value to a newly created vector, this is one of the demonstrations of the general case when some temporary rvalue is created and assigned to <code>v2</code> (this can happen for example, if the function returns a vector).  Here is what we see on the screen: <br><br><pre> <code class="bash hljs">assigning rvalue... [0x28ff08] constructor [0x28fef8] copy assignment operator [0x28fec8] copy constructor [0x28fec8] destructor [0x28ff08] destructor ended assigning rvalue...</code> </pre><br>  Wow!  Looks very troublesome.  In particular, it took an extra pair of constructor calls with a destructor to create and then delete a temporary object.  And this is sad, because inside a copying assignment operator, <i>another</i> temporary object is created and deleted.  Additional work for nothing. <br><br>  But no!  C ++ 11 gives us references to rvalue, with which you can implement "transfer semantics", and in particular "transfer assignment operator" (now I understand why I always called <code>operator=</code> copy assignment operator. In C ++ 11, this difference becomes important).  Let's add another <code>operator=</code> to <code>IntVec</code> : <br><br><pre> <code class="hljs cpp">Intvec&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(Intvec&amp;&amp; other) { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(<span class="hljs-string"><span class="hljs-string">"move assignment operator"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(m_size, other.m_size); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(m_data, other.m_data); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Double Aspersand is a <i>reference to rvalue</i> .  It means just what it promises - it gives a reference to the rvalue, which will be destroyed after the call.  We can use this fact to simply ‚Äúsneak‚Äù the insides of the rvalue - he doesn't need them anyway!  This is what is displayed on the screen: <br><br><pre> <code class="bash hljs">assigning rvalue... [0x28ff08] constructor [0x28fef8] move assignment operator [0x28ff08] destructor ended assigning rvalue...</code> </pre><br>  As we see, the new transfer assignment operator is called, since the rvalue is assigned to <code>v2</code> .  Constructor and destructor calls are still required for a temporary object that is created via <code>Intvec(33)</code> .  However, another temporary object inside the assignment statement is no longer needed.  The operator simply changes the internal rvalue buffer with its own, and thus the destructor rvalue deletes the buffer of the object itself, which will no longer be used.  Purely! <br><br>  I just want to note once again that this example is only the tip of the iceberg of the transfer semantics and references to rvalue.  As you can guess, this is a complex topic with many special cases and mysteries.  I tried only to demonstrate a very interesting application of the differences between lvalue and rvalue in C ++.  The compiler can obviously distinguish them and take care of calling the correct constructor at compile time. <br><br><h2>  Conclusion </h2><br>  You can write a lot of C ++ code, without thinking about the differences between rvalue and lvalue, omitting them as incomprehensible compiler jargon in error messages.  However, as I tried to show in this article, a better knowledge of this topic will provide a deeper understanding of certain C ++ constructs, and make parts of the C ++ standard and discussions between language experts more accessible to you. <br><br>  In the C ++ 11 standard, this topic is even more important, since C ++ 11 introduces the notion of references to rvalue and transfer semantics.  To really understand new language features, a strict understanding of rvalue and lvalue is simply necessary. </div><p>Source: <a href="https://habr.com/ru/post/348198/">https://habr.com/ru/post/348198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348188/index.html">Introduction to Data Vault</a></li>
<li><a href="../348190/index.html">Reactive work with Bluetooth in real conditions</a></li>
<li><a href="../348192/index.html">Software sound synthesis on early personal computers. Part 2</a></li>
<li><a href="../348194/index.html">Making multicolored icons using SVG symbols and CSS variables</a></li>
<li><a href="../348196/index.html">Track user actions with CSS</a></li>
<li><a href="../348200/index.html">Sean Pierce: A Real Leader</a></li>
<li><a href="../348202/index.html">Apache Ignite - calculations in grid</a></li>
<li><a href="../348204/index.html">GObject Basics</a></li>
<li><a href="../348206/index.html">Algorithm of a choice of location in Nginx</a></li>
<li><a href="../348208/index.html">Interview. How to create a high-quality knowledge base: choice of technologies, search and further support</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>