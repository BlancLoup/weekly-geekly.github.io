<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We are looking for vulnerabilities in code: theory, practice and prospects of SAST</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It would not be a big exaggeration to say that the market of static application protection testing tools (Static Application Security Testing, SAST) i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We are looking for vulnerabilities in code: theory, practice and prospects of SAST</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/4e8/0e7/58a/4e80e758a03649388e8be73c7b79d656.jpg" align="left">  It would not be a big exaggeration to say that the market of static application protection testing tools (Static Application Security Testing, SAST) is experiencing a real boom in our time.  Not a couple of months pass between the publication of the next research papers on this topic, every year more and more new static security analysis tools are brought to the market, and the SAST site in the software development process is assigned whole sections at international information security conferences.  In the context of continuous informational pressure from the suppliers of the SAST toolkit, it is not easy to understand what is true and what is nothing more than marketing tricks that hardly correlate with reality.  Let's try to understand what SAST tools really can do and how to deal with the fact that they are too tough.  To do this, we will have to dive a bit into the theory that underlies the modern means of static code security analysis. <br><br><a name="habracut"></a><br><br><h1>  Turing, Rice - these are all </h1><br>  TL / DR: the problem of static software security testing is algorithmically unsolvable. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Imagine a set of completely abstract programs P, which only know how to hang on some sets of input data and stop after a certain number of operations on others.  Obviously, the class P covers any theoretically possible programs, since this property can be attributed to any of them. <br><br>  Now imagine that one of these programs (let's call it h) is an analyzer that can answer a simple question: does an arbitrary program p from the set P hang on a given data set n?  Obviously, h will be able to answer this question only by completing its work and thereby reporting that p hangs on n.  In other words, if p (n) does not stop, then h (p (n)) should complete its work in a finite number of steps, and if p (n) stops, then h (p (n)) should hang. <br><br>  Well, now imagine what will happen if we try to answer with the help of such an analyzer the question: will it hang itself as a result of the analysis of itself analyzing itself (after all, p can be any program from P, then it can also be h)  In this case, it turns out that if h (h (n)) stops, then the analysis h (n) hangs, and if h (h (n))) hangs, then the analysis h (n) stops.  But h is precisely h (n), and, therefore, we have a contradiction here and an analyzer like h has no right to exist. <br><br>  Described is a free presentation of the proof of the Break Theorem, formulated by Allan Turing (the founder of modern theoretical informatics) in the distant 1936th.  This theorem states that there is no such program that could analyze another program and answer the question whether it will stop at a given set of input data.  Well, but can we build such a program that gives an answer to the question about any other properties of the programs? <br><br>  Since the set P includes all possible programs, we can always divide it into two classes (let it be A and B) on the basis of the fact that programs have any non-trivial invariant property.  By a non-trivial invariant property is meant a property that any program of the set P either has or does not have and at the same time all functionally identical programs (which give the same output data sets with the same input data sets), or all have this property, or all together do not possess. <br><br>  Let's imagine that there is some analyzer q that takes an arbitrary program p of the set P as input and stops if p belongs to one of the classes.  Let, for definiteness, this will be class A. Let pa be a program belonging to class A and looping at any input.  We also choose from the class B an arbitrary program pb.  For each program p, we define a program p ', which receives the x data and performs the following algorithm: <br><br><pre><code class="hljs markdown"><span class="hljs-bullet"><span class="hljs-bullet">1. </span></span>p(p) 2. pb(x)</code> </pre> <br>  Now we will build a program q ', which receives an arbitrary program p as an input, builds p' for it and calculates q (p '). <br><br>  If p 'hangs in the first step, then p' is functionally identical to pa (and belongs to class A), and, therefore, q 'should stop immediately.  If p 'passes the first step, then p' is functionally identical to pb (and belongs to the class B), and, therefore, q 'should hang.  Thus, for any program p, q '(p) stops when p (p) does not stop.  But q 'itself may also play the role of p, therefore p (p) stops only when p (p) does not stop.  Again came to a contradiction. <br><br>  The statement that there is no such program that could answer the question about the presence of any non-trivial invariant properties of an arbitrarily taken program was proved by the scientist Henry Rice in 1953.  In fact, his work generalizes the Break Theorem, since the property of stopping on a given data set is nontrivial and invariant.  Rice's theorem has an infinite number of practical meanings, depending on the properties under consideration: ‚Äúit is impossible to classify the algorithm implemented by another program using the program‚Äù, ‚Äúit is impossible to prove using the program that two other programs implement the same algorithm‚Äù, ‚Äúit is impossible using programs to prove that another program on any data sets is not included in any state ... ", etc.  And here it is worth stopping at the last example. <br><br>  At the time of execution of any (both abstract and real) algorithm by some kind of universal executing program (for example, a virtual machine emulating a full-fledged computer with an installed OS), you can take a snapshot of this machine, including the state of the executable program itself in the address space of the machine and its external environment such as disk drives, the status of external devices, etc.  and later, restoring it, continue with the program from the same place.  In fact, the entire process of executing any program is a series of alternating states, the sequence of which is determined by its code.  At the same time, if there are any errors in the configuration or implementation of both the program and the machine running it, there is a high probability that the execution process will enter a state that was not originally intended by the developers. <br><br>  And what is the vulnerability?  This is an opportunity with the help of input data to make the execution process enter into a state that will lead to the realization of any threats to the information processed by the process.  Consequently, it is possible to define the security property of any program, as its ability to remain at each moment of time, regardless of the initial input data, within a predetermined set of admissible states determining its security policy.  At the same time, the task of analyzing the security of a program obviously comes down to analyzing the impossibility of its transition to any state not resolved by the security policy on an arbitrary set of input data.  That is, to the very problem, the algorithmic unsolvability of which was long ago proved by Henry Rice. <br><br>  So it turns out, well ... the whole SAST tool market is the deception industry?  In theory - yes, in practice, everything is as usual - options are possible. <br><br><h1>  SAST theory in practice </h1><br>  Even staying in the theoretical field, it is quite possible to do a few easing to Rice's statement for real programs running in real environments.  First, in theoretical informatics, a ‚Äúprogram‚Äù means a mathematical abstraction equivalent to a Turing machine (MT) ‚Äîthe most powerful computer machine.  However, in real programs, not every fragment of their code is equivalent to MT.  Below the hierarchy of computing power are linearly-limited, stack and finite automata.  Security analysis of the last two is quite possible, even within the framework of the theoretical theory itself. <br><br>  Secondly, the distinctive feature of MT is that it has a memory of infinite size.  It is from this feature that the impossibility of obtaining all possible states of the computational process ‚Äî their simply infinite number ‚Äî follows.  However, in real computers, memory is far from infinite.  More importantly, in real programs, the number of states of interest from the point of view of the security analysis task is also of course (although it is indecently large). <br><br>  Thirdly, the calculation of the Rice program properties is a solvable problem for a number of small MTs with a small number of states and possible transitions between them.  It is difficult to imagine a real program with 2 to 4 states.  However, such a * fragment * of the program is much easier to imagine. <br><br>  Consequently, it is possible to efficiently analyze individual fragments of program code that fall under the listed criteria.  In practice, this means that: <br><br><ol><li>  the code fragment without cycles and recursion can be comprehensively analyzed, since  equivalent to the state machine; </li><li>  a fragment with cycles or recursion, the exit condition of which does not depend on the input data, can be analyzed as a finite or stack automaton; </li><li>  if the conditions for exit from a cycle or recursion depend on the input data, the length of which is limited to some reasonable threshold, then in some cases such fragment can be analyzed as a system of linearly bounded automata or small MTs. </li></ol><br>  But everything else - alas and ah - cannot be analyzed with a static approach.  Moreover, the development of a source code security analyzer is a direction in which engineers encounter EXPPACE &lt;-&gt; EXPTIME every day, and, reducing even particular cases to a subexponent, are as happy as children because it is really cool.  Think about what will be the power of the set of values ‚Äã‚Äãof the variable parm1 at the last execution point? <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parm1 = <span class="hljs-type"><span class="hljs-type">Request</span></span>.<span class="hljs-type"><span class="hljs-type">Params</span></span>[<span class="hljs-string"><span class="hljs-string">"parm1"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">count</span></span> = int.<span class="hljs-type"><span class="hljs-type">Parse</span></span>(<span class="hljs-type"><span class="hljs-type">Request</span></span>.<span class="hljs-type"><span class="hljs-type">Params</span></span>[<span class="hljs-string"><span class="hljs-string">"count"</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">count</span></span>; i++) { i % <span class="hljs-number"><span class="hljs-number">2</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ? parm1 = parm1 + i.<span class="hljs-type"><span class="hljs-type">ToString</span></span>(): parm1 = i.<span class="hljs-type"><span class="hljs-type">ToString</span></span>() + parm1; } <span class="hljs-type"><span class="hljs-type">Response</span></span>.<span class="hljs-type"><span class="hljs-type">Write</span></span>(parm1);</code> </pre><br>  That's why you can not worry too much about theoretical limitations, because it will be extremely difficult to rest on them with current computing power.  However, the listed relaxations of these restrictions set the right direction for the development of modern static analyzers, so it‚Äôs worth keeping them in mind. <br><br><h1>  DAST, IAST and all-all-all </h1><br>  In contrast to the static approach that works with the program code without actually executing it, dynamic (Dynamic Application Security Testing, DAST) implies the presence of a deployed application execution environment and its run on the most interesting from the point of view of the analysis of the input data sets.  Simplifying, it can be described as the method of "conscious scientific typing" ("let's give the program such data that is typical for such an attack and see what comes of it").  Its drawbacks are obvious: it is not always possible to quickly deploy the system being analyzed (and often just to assemble), the transition of the system to any state may be a consequence of processing previous data sets, and for a comprehensive analysis of the behavior of a real system, the number of input data must be so great that one can speak only theoretically about his limbs. <br><br>  Relatively recently, an approach that combines the advantages of SAST and DAST - an interactive analysis (Interactive ..., IAST) was considered promising.  A distinctive feature of this approach is that SAST is used to form input data sets and templates of expected results, and DAST performs system testing on these sets, optionally involving a human operator in ambiguous situations in the process.  The irony of this approach is that it has absorbed both the advantages and disadvantages of SAST and DAST, which could not but affect its practical applicability. <br><br>  But who said that in the case of dynamic analysis you need to perform the entire program entirely?  As was shown above, it is quite realistic to analyze a significant part of the code using a static approach.  What prevents to analyze with the help of dynamic only the remaining fragments?  Sounds like a plan ... <br><br><h1>  And inside her neonka </h1><br>  There are several traditional approaches to static analysis, differing by model, on the basis of which the analyzer derives certain properties of the code under study.  The most primitive and obvious is the signature search, based on the search for the occurrence of a pattern in the syntax model of the code representation (as a rule, this is either a stream of tokens or an abstract syntax tree).  Separate implementations of this approach use slightly more complex models (a semantic tree, its mapping of individual data streams to a graph, etc.), but in general this approach can be considered solely as an auxiliary, allowing to isolate suspicious places in the code for linear time. manual verification.  We will not dwell on it in more detail; those interested can turn to the <a href="https://habrahabr.ru/company/pt/blog/300946/">series of articles by</a> Ivan Kochurkin devoted to him. <br><br>  More complex approaches operate with models of execution (rather than representations or semantics) of the code.  Such models, as a rule, allow to get an answer to the question ‚Äúcan externally controlled data flow reach any point of execution at which this will lead to the emergence of a vulnerability?‚Äù.  In most cases, the model here is a variation on the theme <a href="https://en.wikipedia.org/wiki/Control_flow_graph">of execution flow</a> and <a href="https://en.wikipedia.org/wiki/Data_flow_diagram">data</a> <a href="https://en.wikipedia.org/wiki/Control_flow_graph">flow</a> graphs, or a combination of them (for example, a <a href="https://www.tu-braunschweig.de/Medien-DB/sec/pubs/2014-ieeesp.pdf">graph of code properties</a> ).  The lack of such approaches is also obvious - in any non-trivial code, the answer to this question alone is not sufficient for successful detection of vulnerability.  For example, for a fragment: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requestParam = Request.Params[<span class="hljs-string"><span class="hljs-string">"param"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filteredParam = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Empty; <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> symbol <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> requestParam) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (symbol &gt;= <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; symbol &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span>) { filteredParam += symbol; } } Response.Write(filteredParam);</code> </pre><br>  such an analyzer will deduce from the constructed model an affirmative answer about data reachability by `Request.Params [" param "]` execution point `Response.Write (filteredParam)` and the existence of XSS at this point.  At that time, as a matter of fact, this stream is effectively filtered and cannot be the carrier of the attack vector.  There are many ways to cover the special cases associated with preprocessing data streams, but they all ultimately boil down to a reasonable balance between the false positives of the first and second types. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/65c/724/71d/65c72471d8ed49a593da4c0f12e8549f.jpg" alt="Type 1 &amp; 2 errors"></div><br>  How can I minimize the occurrence of both types of errors?  To do this, it is necessary to take into account the conditions of reachability of both potentially vulnerable execution points and sets of values ‚Äã‚Äãof data streams arriving at such points.  Based on this information, it becomes possible to build a system of equations, the set of solutions of which will give all possible sets of input data necessary to come to a potentially vulnerable point of the program.  The intersection of this set with the set of all possible attack vectors will give the set of all sets of input data that bring the program into a vulnerable state.  It sounds great, but how to get a model that contains all the necessary information? <br><br><h1>  Abstract interpretation and symbolic calculations </h1><br>  Suppose we are faced with the task of determining the number with which sign defines the expression `-42 / 8 * 100500`.  The easiest way is to evaluate this expression and make sure that a negative number is obtained.  The calculation of an expression with the well-defined values ‚Äã‚Äãof all its arguments is called a concrete calculation.  But there is another way to solve this problem.  Let's imagine for a second that for some reason we cannot specifically calculate this expression.  For example, if the variable `-42 / 8 * 100500 * x` was added to it.  We define abstract arithmetic, in which the result of operations on numbers is determined solely by the sign rule, and the values ‚Äã‚Äãof their arguments are ignored: <br><br><pre> <code class="hljs erlang">(+a) = (+) (-a) = (-) (-) * (+) = (-) (-) / (+) = (-) ... (-) + (+) = (+-) ...</code> </pre><br>  Interpreting the original expression within the framework of this semantics, we get: `(-) / (+) * (+) * (+)` -&gt; `(-) * (+) * (+)` -&gt; `(-) * ( +) `-&gt;` (-) `.  This approach will give an unequivocal answer to the task before the addition or subtraction operations appear in the expression.  Let's add our arithmetic so that the values ‚Äã‚Äãof the arguments of operations are also taken into account: <br><br><pre> <code class="hljs swift">(-a) * (+b) = (-<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) (-a) / (+b) = (-<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>) ... (-a) + (+b) = a &lt;= b -&gt; (+) a &gt; b -&gt; (-) ...</code> </pre><br>  Interpreting the expression `-42 / 8 * 100500 + x` in the new semantics we get the result` x&gt; = -527625 -&gt; (+), x &lt;-527625 -&gt; (-) `. <br><br>  The approach described above is called <a href="https://en.wikipedia.org/wiki/Abstract_interpretation">abstract interpretation</a> and is formally defined as a stable approximation of the semantics of expressions, based on monotone functions over ordered sets.  In simpler language, it is the interpretation of expressions without their specific calculation in order to collect information within a given semantic field.  If we smoothly move from interpreting individual expressions to interpreting program code in any language, and as a semantic field we define the semantics of the language itself, supplemented by the rule to operate with all input data as unknown variables (symbolic values), then we get an approach called <a href="https://en.wikipedia.org/wiki/Symbolic_execution">symbolic the implementation</a> and underlying of the most promising areas of static code analysis. <br><br>  It is with the help of symbolic calculations that it becomes possible to build a contextual graph of symbolic calculation (alternative name: calculation flow graph) - a model that comprehensively describes the process of calculating the program under study.  This model was considered in the report <a href="http://www.slideshare.net/kochetkov.vladimir/ss-48743308/14">‚ÄúAutomatic generation of patches for source code‚Äù</a> , and its application for analyzing code security in the article <a href="https://habrahabr.ru/company/pt/blog/224547/">‚ÄúOn the analysis of source code and automatic generation of exploits‚Äù</a> .  It hardly makes sense to consider them again in the framework of this article.  It is only necessary to note that this model allows us to obtain reachability conditions for any point in the execution flow, as well as for the sets of values ‚Äã‚Äãof all arguments arriving in it.  That is - exactly what we need to solve our problem. <br><br><h1>  Search for vulnerabilities in the computation flow graph </h1><br>  Having formalized the criteria of vulnerability to one or another class of attacks in terms of the calculation flow graph, we will be able to implement code security analysis by resolving the properties of a particular model obtained as a result of abstract interpretation of the code under study.  For example, the criteria for vulnerability to attacks of any injection (SQLi, XSS, XPATHi, Path Traversal, etc.) can be formalized like this: <br><br><blockquote>  Let C be the computation flow graph of the code under study. <br><br>  Let pvf (t) be the reachable vertex of the control flow on C, which is a call to the function of direct or indirect interpretation of the text t corresponding to the formal grammar G. <br><br>  Let e ‚Äã‚Äãbe the input argument stream in C. <br><br>  Let De be the set of data streams on C generated by e. <br><br>  Then the application is vulnerable to injection attacks at the pvf (t) call point, if t belongs to De and the set of De values ‚Äã‚Äãincludes at least one pair of elements in which, as a result of their syntactic analysis according to the grammar G, they are not isomorphic to each other. friend trees <br></blockquote><br>  In a similar way, vulnerabilities to other classes of attacks are formalized.  However, it should be noted here that not all types of vulnerabilities can be formalized within the framework of a model that is derived only from the analyzed code.  In some cases, additional information may be required.  For example, to formalize vulnerabilities to attacks on business logic, it is necessary to have formalized application domain rules, to formalize vulnerabilities to attacks on access control ‚Äî a formalized policy of access control, etc. <br><br><h1>  Ideal spherical code security analyzer in vacuum </h1><br>  Let us now briefly digress from the harsh reality and dream a little bit about what functionality the core of the hypothetical Ideal Analyzer should have (let's call it ‚ÄúIA‚Äù)? <br><br>  First, it must incorporate the advantages of SAST and DAST, not including their disadvantages.  From this, in particular, it follows that IA should be able to work exclusively with the existing application code (source or binary), without requiring its completeness or application deployment in the runtime environment.  In other words, it should support the analysis of projects with missing external dependencies or any other factors hindering the assembly and deployment of the application.  At the same time, work with code fragments that have links to missing dependencies should be implemented to the fullest extent possible in each particular case.  On the other hand, IA should be able to effectively ‚Äúdodge‚Äù not only the theoretical limitations imposed by the turing computation model, but also scan in a reasonable time, consuming a reasonable amount of memory and adhering to the subexponential ‚Äúweight category‚Äù as far as possible. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secondly, the probability of occurrence of errors of the first kind should be minimized by constructing and solving systems of logical equations and generating a working attack vector at the output, allowing the user to confirm the existence of a vulnerability in a single action. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Third, IA must effectively deal with errors of the second kind, allowing the user to manually check all potentially vulnerable points of the flow of execution, the vulnerability of which IA itself could neither confirm nor deny.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The use of a model based on symbolic calculations allows all these requirements to be realized, which is called ‚Äúby-design‚Äù, except for the part that concerns theoretical limitations and the subexponent. </font><font style="vertical-align: inherit;">And here, as it is impossible by the way, we will have our plan - to use dynamic analysis where static has failed.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Partial calculations, inverse functions and delayed interpretation </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Imagine that IA contains a certain knowledge base describing the semantics of the input data conversion functions implemented in the standard library of the language or application environment, the most popular frameworks and CMS. For example, that the functions Base64Decode and Base64Encode are mutually inverse, or that each call to a StringBuilder.Append adds a new string to the one already stored in the intermediate battery variable of this class, etc. Possessing such knowledge, IA will be spared the need to ‚Äúfall through‚Äù into the library code, the analysis of which also falls under all computational limitations:</font></font><br><br><pre> <code class="hljs pgsql">//       cond2            <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Encoding</span></span>.UTF8.GetString(Convert.FromBase64String(cond2)) == "true") { var sb = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> StringBuilder(); sb.Append(Request.Params["param"]); //  sb.ToString       StringBuilder,       Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(sb.ToString()); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But what to do if the code contains a function call that is not described in the IA knowledge base? Let's imagine that at the disposal of IA there is a kind of virtual sandbox environment that allows you to run an arbitrary fragment of the analyzed code in a given context and get the result of its execution. Let's call this a "partial calculation." Then, before you honestly ‚Äúfall‚Äù into an unknown function and begin to interpret it abstractly, IA can try a trick called ‚Äúpartial fuzzing‚Äù. His general idea is to prepare the knowledge base for library transforming functions and combinations of their successive calls on previously known sets of test data. With such a database, you can perform an unknown function on the same data sets and compare the results with samples from the knowledge base.If the results of executing an unknown function coincide with the results of executing a known chain of library functions, then this will mean that IA is now known semantics of the unknown function and its interpretation is not necessary.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If for some of the known sets of values ‚Äã‚Äãof all data streams coming into this fragment, and the fragment itself does not contain dangerous operations, then IA can simply execute it on all possible data streams and use the results instead of abstract interpretation of this fragment of code. Moreover, this fragment can belong to any class of computational complexity and this does not affect the results of its implementation. Moreover, even if the sets of data stream values ‚Äã‚Äãarriving in the fragment are unknown in advance, the IA may postpone the interpretation of this fragment until the solution of the equation for the particular dangerous operation begins. At the decision stage, an additional restriction is imposed on the set of input data values ‚Äã‚Äãon the presence of vectors of various attacks in the input data.which may also suggest the set of values ‚Äã‚Äãof the input data coming in the pending fragment and, thereby, partially calculate it at this stage.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, at the decision stage, nothing prevents IA from taking the final reachability formula of a dangerous point and its arguments (which is easiest to build in the syntax and semantics of the same language on which the analyzed code is written) and ‚Äúprofazz‚Äù it with all known vectors for obtaining their subsets passing through all filtering functions of the formula:</font></font><br><br><pre> <code class="hljs pgsql">//   Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>,      ,           parm1     XSS Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(CustomFilterLibrary.CustomFilter.<span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>(parm1));</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The approaches described above allow you to cope with the analysis of a significant part of the turing-full code fragments, but they require significant engineering work, both in terms of filling the knowledge base and optimizing the emulation of the semantics of standard types, as well as in implementing the sandbox for partial code execution (no one wants The analysis process suddenly performed something like File.Delete (in a loop), as well as supporting the fuzzing of n-local unknown functions, integrating the concept of partial computation with an SMT solver, etc. </font><font style="vertical-align: inherit;">However, there are no significant restrictions on their implementation, in contrast to the rake of the classic SAST.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When the ugly duck-typing becomes a swan </font></font></h1><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e66/62b/eae/e6662beae7c6422691ead2ec61472de4.jpg" alt="Duck typing"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Imagine that we need to analyze the following code: </font></font><br><br><pre> <code class="hljs pgsql">var argument = "harmless value"; // UnknownType - ,     UnknownType.Property1 = parm1; UnknownType.Property2 = UnknownType.Property1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UnknownType.Property3 == "true") { argument = UnknownType.Property2; } Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(argument);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A person can easily see the achievable vulnerability to XSS here. But most of the existing static analyzers will safely miss it due to the fact that they do not know anything about the UnknownType type. However, all that is required from IA is to forget about static typing and go to duck. The semantics of the interpretation of such constructions should completely depend on the context of their use. Yes, the interpreter knows nothing about what the `UnknownType.Property1` is - a property, a field, or even a delegate (a reference to a method in C #). But since operations with it are carried out as with a variable variable of some type, nothing prevents the interpreter from processing them in this way. And if, for example, the construction of the `UnknownType.Property1 ()` is encountered further along the code, then nothing prevents to interpret the call of that method,reference to which Property1 was previously assigned. And so on, in the best traditions of duck champion breeders.</font></font><br><br><h1>  Summing up </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, there is a mass of marketing whistles, which one analyzer supposedly compares favorably with the other, from the point of view of the party that sells it. But, you see, there is no good in them if the core of the product is not able to provide the basic functionality for which it will be used. And in order to provide it, the analyzer is obliged to strive in its capabilities to the described IA. Otherwise, there can be no talk of any real security on the projects processed by him.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few years ago, one of our clients turned to us for an analysis of the security of the system developed by them. Among the input data, he provided a report on the analysis of the code of their project by a product, which at that time was the market leader in the SAST toolkit. The report contained about two thousand records, most of which ended up with positive-false positives for verification. But the worst was what was not in the report. As a result of manual code analysis, we discovered dozens of vulnerabilities missed during scanning. The use of such analyzers does more harm than good, both taking the time needed to parse all the false-positive results, and creating the illusion of security due to false-negative. This case, by the way,became one of the reasons for the development of our own analyzer.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúTalk is cheap. </font><font style="vertical-align: inherit;">Show me the code. ‚Äù</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It would be strange not to complete the article with a small example of code that allows you to check the degree of ideality of a particular analyzer in practice. </font><font style="vertical-align: inherit;">Voila - below is the code that includes all the base cases covered by the described approach to abstract interpretation, but not covered by more primitive approaches. </font><font style="vertical-align: inherit;">Each case is implemented as trivially as possible and with a minimum number of language instructions. </font><font style="vertical-align: inherit;">This is an example for C # / ASP.Net WebForms, but does not contain any specifics and can be easily translated into code in any other OOP-language and under any web framework.</font></font><br><br><pre> <code class="hljs pgsql">var parm1 = Request.Params["parm1"]; const string cond1 = "ZmFsc2U="; // "false"  base64- Action&lt;string&gt; pvo = Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>-negative // ,         ,      pvo(parm1); //  ,   ,     #region var argument = "harmless value"; UnknownType.Property1 = parm1; UnknownType.Property2 = UnknownType.Property1; UnknownType.Property3 = cond1; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (UnknownType.Property3 == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { argument = UnknownType.Property2; } // <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>-positive // ,   ,     Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(argument); #endregion // <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>-positive // ,      ,     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond1 == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(parm1); } // <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>-positive // ,      ,     Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(WebUtility.HtmlEncode(parm1)); // <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>-positive // ,      ,     // (CustomFilter.<span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>   `s.Replace("&lt;", string.Empty).Replace("&gt;", string.Empty)`) Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(CustomFilterLibrary.CustomFilter.<span class="hljs-keyword"><span class="hljs-keyword">Filter</span></span>(parm1)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Encoding</span></span>.UTF8.GetString(Convert.FromBase64String(cond1)) == "true") { // <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>-positive // ,      ,     Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(parm1); } var sum = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (var j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">15</span></span>; j++) { sum += i + j; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum != <span class="hljs-number"><span class="hljs-number">1725</span></span>) { // <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>-positive // ,     ,     Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(parm1); } var sb = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> StringBuilder(); sb.Append(cond1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sb.ToString() == "true") { // <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>-positive // ,      ,     Response.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(parm1); }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result of the analysis of this code should be a message about the only vulnerability to XSS attacks in the expression `pvo (parm1)`. </font><font style="vertical-align: inherit;">You can enter and compile with a scan-ready project </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But, as they say, ‚Äúit‚Äôs better to see once ...‚Äù and, first of all, we checked for compliance with the IA analyzer we are developing, by chance called </font></font><a href="http://ai.ptsecurity.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/files/bd1/173/6f7/bd11736f7f0447b795979ad4861907f3.png"></a> </div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Have you already checked yours? </font></font> ;) <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> As a bonus for reading to the end: </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We are launching a public alpha testing of the free utility Approof. </font><font style="vertical-align: inherit;">It does not include code analysis functionality and does not use all the above-described mastaphic hardcore, but includes functionality for detecting vulnerable external components in projects, configuration-sensitive data disclosures, as well as embedded web shells and malicious code:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3ff/e98/d0a/3ffe98d0a8e94273852ed6a03cc7ea56.png"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can download the utility on the </font></font><a href="http://approof.ptsecurity.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">official website</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Before using it, be sure to read the license agreement. </font><font style="vertical-align: inherit;">During the analysis, Approof collects non-confidential project statistics (CLOC, file types, frameworks, etc.) and, optionally, sends it to the PT server. </font><font style="vertical-align: inherit;">You can disable sending statistics or familiarize yourself with the raw json containing the collected data in the About section of the application.</font></font></div><p>Source: <a href="https://habr.com/ru/post/305000/">https://habr.com/ru/post/305000/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304934/index.html">Important aspects of the browser for developers. Part 2</a></li>
<li><a href="../304936/index.html">About tasty and healthy food ESP8266 from batteries</a></li>
<li><a href="../304982/index.html">Sparrowdo is a simple configuration management tool.</a></li>
<li><a href="../304988/index.html">Signals and slots in PHP. Same as in Qt. Almost</a></li>
<li><a href="../304998/index.html">We play mp3 in our program and what can prevent it</a></li>
<li><a href="../305002/index.html">CMYK closed-loop search algorithm on a two-dimensional matrix</a></li>
<li><a href="../305006/index.html">Wired: How blockchain threatens the financial market, and why companies on Wall Street develop this technology</a></li>
<li><a href="../305014/index.html">Review of Quanta servers: interesting solutions, rack-sized blade baskets, microserver hives and HPC farms</a></li>
<li><a href="../305016/index.html">Differences in the modeling of planned and actual operations</a></li>
<li><a href="../305018/index.html">Functors (chapter of the book "Category Theory for Programmers")</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>