<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Intel GPA and Android gaming performance improvement</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The competition in the mobile entertainment market is huge. Fans of games, when they come across ‚Äúbrakes‚Äù, do not stint on angry reviews: ‚ÄúHow is that...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Intel GPA and Android gaming performance improvement</h1><div class="post__text post__text-html js-mediator-article">  The competition in the mobile entertainment market is huge.  Fans of games, when they come across ‚Äúbrakes‚Äù, do not stint on angry reviews: ‚ÄúHow is that?  Hardly pulls on my new phone, where should everything fly?  In the furnace of the developers!  Let's get some quick games! ‚Äù  Sometimes gamers, of course, go too far, but there is no smoke without fire.  And if your new game got a portion of ‚Äúsweet words‚Äù, this is a serious reason to think about improving its performance.  And even better when FPS and other such things are on the agenda even before the game enters the market. <br><br>  This guide presents a step-by-step example of analyzing performance, finding bottlenecks and optimizing graphics output in an Android game that uses <a href="http://developer.android.com/guide/topics/graphics/opengl.html">OpenGL ES 3.0</a> .  <a href="">An example of a game</a> that we use in experiments is called ‚ÄúCity Racer‚Äù.  This is a city car racing simulator.  Performance analysis of the application is performed using the <a href="https://software.intel.com/en-us/gpa">Intel Graphics Performance Analyzers</a> toolkit (Intel GPA). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3c/a92/4db/a3ca924db3c96156a648c117edc27d4d.png"></div><br>  <i><font color="#999999">Game City Racer</font></i> <br><a name="habracut"></a><br>  The urban environment and the car are built from about 230,000 polygons (690000 peaks).  It applies the overlay of diffuse materials, illuminated by a single source of directional light without shadows.  The demonstration materials for this article contain the program code, project files and graphic resources that are necessary to build and run the application.  The optimizations considered here can be turned on and off, and the source and advanced versions of the game are presented in the code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  <font color="#0071c5">Preliminary Information</font> </h2><br>  At the core of this material is the <a href="https://software.intel.com/sites/products/vcsource/files/43436/Ivy_Bridge_Performance_Workshop.pdf">Intel Graphics Performance Workshop for the 3rd Generation Intel Core Processor (Ivy Bridge)</a> , which comes with the GPA.  We transferred the ideas and techniques of this guide to OpenGL ES 3.0. <br><br>  During the review of the material we will go through the successive steps to optimize the game.  At each step, the application is analyzed using GPA tools to find bottlenecks.  Then, in order to solve the problem found, we improve the application, after which the performance is measured again - to evaluate the effect of optimization.  We stick to the work plan here, which is used in the tutorial found in the <a href="https://software.intel.com/sites/default/files/managed/d4/27/4th-gen-core-graphics-dev-guide.pdf">Developer's Guide for Intel Processor Graphics</a> . <br><br>  To build the City Racer game example, <a href="https://developer.android.com/sdk/api_diff/20/changes.html">Android API 20</a> and <a href="https://developer.android.com/ndk/downloads/revision_history.html">Android NDK 10 are used</a> .  Performance analysis is performed using the <a href="https://c/Users/twang12/Syncplicity/Ready_publication/Intel%2520INDE%2520GPA%2520tool%2520suite">Intel GPA</a> toolkit. <br><br>  Intel GPA is compatible with most Android devices.  However, from those that are built on the x86 platform, you can get the most detailed information about the profiled metrics. <br><br>  Looking ahead, we want to note that during the optimization, the graphics performance of City Racer increased by 83%. <br><br><h2>  <font color="#0071c5">About City Racer</font> </h2><br>  The City Racer demonstration game is logically divided into two parts.  The first is responsible for the simulation process of auto racing, the second - for the withdrawal of graphics.  Simulation of the race includes the simulation of acceleration, braking, turning the car.  Here is a system built on the principles of artificial intelligence, responsible for following the route and avoiding collisions.  The code implementing this functionality is in the files track.cpp and vehicle.cpp, it is not optimized. <br><br>  The graphics output components, the second logical part of the game, include code for drawing car models and a game scene using OpenGL ES 3.0.  and our own self-developed CPUT engine.  The initial version of the code is a typical first attempt to create a working application.  Some of the architectural solutions used to write it limit performance. <br><br>  Model grids and textures are loaded from the Media / defaultScene.scene file.  Separate grids are marked according to whether they are part of a scene that is placed in advance, an object that is placed in the game world during the game, or a car, the output parameters of which are calculated during the simulation.  In the gaming space, you can use several types of cameras.  The main camera follows the car.  An additional camera allows the user to freely inspect the scene.  Performance analysis and code optimization are aimed at working with the camera that follows the car. <br><br>  For the purposes of this tutorial, City Racer, when it starts, is in pause mode.  This allows you to go through all the profiling steps using identical data sets.  You can remove the game from the pause, either by resetting the Pause flag in its interface, or by writing the g_Paused variable to false.  This variable can be found at the beginning of the CityRacer.cpp file. <br><br><h2>  <font color="#0071c5">Optimization potential</font> </h2><br>  City Racer is a functional, but non-optimized application prototype.  In the initial state, it is able to generate a picture that we need, but we are not satisfied with the performance of the output of City Racer graphics.  The game has a lot of technical techniques and architectural solutions that limit the speed of visualization.  They are similar to those found in a typical game under development.  The goal of the optimization phase when creating a game is to search for bottlenecks and eliminate them one by one by modifying the code and re-measuring performance after each change. <br><br>  Please note that in this tutorial, we‚Äôve covered a small set of improvements that City Racer can undergo.  In particular, they concern only the optimization of the source code of the game, and we do not change the resources, such as models and textures.  A story about optimizations affecting graphics or other game resources would make our story too cumbersome, so we are not doing this here.  However, with the help of Intel GPA, you can identify problems with game resources.  When developing and fine-tuning a real game, resource optimization is just as important as code optimization. <br><br>  The performance values ‚Äã‚Äãthat we give here are obtained on an Android device that has an Intel Atom (Bay Trail) processor.  If you repeat our tests, the results may vary, but the relative performance changes should be the same.  The game improvement procedures described should result in a comparable performance increase. <br><br>  The code, its source and improved versions, is in the CityRacer.cpp file.  The use of optimizations can be turned on and off in the program interface or by modifying the values ‚Äã‚Äãof some variables in this file. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/e2c/b03/f07e2cb0300c84129523ad13aed7cce8.png"></div><br>  <i><font color="#999999">Enable and disable optimizations in the game interface</font></i> <br><br>  The following code from CityRacer.cpp shows the variables responsible for enabling and disabling optimizations.  The state of the code corresponds to the state of the above fragment of the interface. <br><br><pre><code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> g_Paused = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> g_EnableFrustumCulling = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> g_EnableBarrierInstancing = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> g_EnableFastClear = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> g_DisableColorBufferClear = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> g_EnableSorting = <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre> <br>  In the manual, we will describe various optimization techniques.  Each variable allows you to switch between optimized and non-optimized code.  If you read the manual and simultaneously check what you learned on your device, you can gradually turn on the use of optimized code variants and monitor the performance changes. <br><br><h2>  <font color="#0071c5">Optimization</font> </h2><br>  The first step is to compile City Racer and install it on an Android device.  If your system has a properly configured Android development environment, then everything you need can be done using the buildandroid.bat file, which is located in the CityRacer / Game / Code / Android folder. <br><br>  After the game is installed on the device, launch Intel GPA Monitor, right-click on the icon in the system notification area and select System Analyzer. <br><br>  System Analyzer will display a list of platforms to which you can connect.  Select your Android x86 device and tap the Connect button. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/f6e/b02/d7cf6eb0209026752c106af049727088.png"></div><br>  <i><font color="#999999">Choosing a platform for performance analysis</font></i> <br><br>  When System Analyzer connects to the device, it displays a list of applications that can be profiled.  Select City Racer and wait for the game to launch. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f8b/2e6/e47/f8b2e6e473e204ae2e70eeb2d16dde21.png"></div><br>  <i><font color="#999999">Application List displayed by System Analyzer</font></i> <br><br>  When the program starts, click on the frame capture button to take a snapshot of the GPU frame for analysis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/d86/0be/841d860be18207f8149dfec865bc6bd9.png"></div><br>  <i><font color="#999999">Capture GPU frame for analysis</font></i> <br><br><h2>  <font color="#0071c5">Frame examination</font> </h2><br>  Open Frame Analyzer for OpenGL and select the frame you just captured City Racer.  This will allow to analyze the performance of the GPU in detail. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f44/247/c54/f44247c5451b78c86c511456d6f1f995.png"></div><br>  <i><font color="#999999">Run Frame Analyzer to test GPU performance</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e29/366/fd1/e29366fd121f7117d3ce09f40797d09d.png"></div><br>  <i><font color="#999999">OpenGL Challenge Timeline</font></i> <br><br>  On the timeline, which is located in the upper part of the screen, uniformly distributed ‚Äúergs‚Äù are shown - the units in which the work on image output is measured.  Usually they correspond to the OpenGL drawing commands.  In order to switch to a more traditional display of the time scale, select the GPU Duration parameter along the X and Y axes. With this setting, we can quickly understand which of the ergs occupy the most time of the video core.  This will allow you to figure out exactly what should be focused on optimization efforts.  If none of the ergs is selected, the panel on the right displays the total time needed by the GPU to output the frame.  In our case, this is 55 ms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fe/c2a/4f5/3fec2a4f5be1b2be71a3467890190f44.png"></div><br>  <i><font color="#999999">The time required for the GPU to output the frame</font></i> <br><br><h2>  <font color="#0071c5">Optimization number 1.</font>  <font color="#0071c5">Clipping on the pyramid of visibility</font> </h2><br>  Looking at the drawing commands calls, we can find out that the output of many elements is being executed, which, in fact, are not visible on the screen.  By changing, when viewing the frame analysis results, the data displayed on the Y axis on Post-Clip Primitives, we can see gaps that help us to understand which drawing calls are wasted because the objects they draw are completely hidden by others. . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/adf/45a/28a/adf45a28ae4c2ed617dadd41c7c15434.png"></div><br>  <i><font color="#999999">Analysis of the output of objects that are completely covered by other objects</font></i> <br><br>  Buildings in City Racer are grouped according to their spatial location.  Groups that are not visible, we can not display, without loading the GPU work associated with them.  If, in the game interface, you set the Frustum Culling flag, each call to the drawing command, before it is passed to the video core, passes the "visibility check" in the code that is executed on the central processor. <br><br>  Set the Frustum Culling flag, capture another frame for analysis using System Analyzer and take a look at it using Frame Analyzer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/615/5d5/56b/6155d556b0f628aa6f48b95e6602a9e0.png"></div><br>  <i><font color="#999999">Analysis of the frame obtained after optimization</font></i> <br><br>  Analyzing the frame, we can see that the number of drawing calls has decreased by 22% - from 740 to 576. The total time required for the GPU to output a frame has decreased by 18%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/13a/476/558/13a47655885c6413ed53ebd4b1733f1b.png"></div><br>  <i><font color="#999999">The number of calls for drawing commands after optimization of clipping on the pyramid of visibility</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/950/b62/e65/950b62e65a300812112eca0e86ae250d.png"></div><br>  <i><font color="#999999">Frame output time after optimization</font></i> <br><br><h2>  <font color="#0071c5">Optimization ‚Ññ2.</font>  <font color="#0071c5">Output of small objects</font> </h2><br>  Clipping along the visibility pyramid reduces the total number of ergs, however, during the frame analysis, you can observe a large number of small drawing operations (highlighted in yellow).  Together, these operations seriously burden the video core. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/5ef/28f/3415ef28f96902e77176e0f21a88bacb.png"></div><br>  <i><font color="#999999">Small drawing operations</font></i> <br><br>  Having figured out which specific objects correspond to small ergs, we found out that their main number falls on the output of concrete blocks, which the route is limited to. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b16/e91/7ad/b16e917add05095c70c7144157716832.png"></div><br>  <i><font color="#999999">Blocks that make up small drawing operations</font></i> <br><br>  You can eliminate most of the unnecessary load on the video core by combining disparate operations to remove blocks in one operation.  When the Barrier Instancing flag is set, the drawing of blocks present in the scene is performed as one operation.  This eliminates the need for the central processor to send the video core a command to draw each block separately. <br><br>  If, after turning on the Barrier Instancing flag, capture a frame using System Analyzer and analyze it in Frame Analyzer, you can notice a serious performance increase. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b19/be7/ebd/b19be7ebd9e8d9a109d83ec6c2afb586.png"></div><br>  <i><font color="#999999">Analysis after optimization of the output of small objects</font></i> <br><br>  After analyzing the frame, we see that the number of drawing calls has been reduced by 90%, namely, from 576 to 60. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0f/26b/645/d0f26b645d433e48e42d0d5b3b06dba6.png"></div><br>  <i><font color="#999999">Drawing commands before optimization</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/634/401/35063440189ac2f0fb8c1df602abcf4f.png"></div><br>  <i><font color="#999999">Drawing commands calls after optimization</font></i> <br><br>  Now the total video core operation time required for frame output has been reduced by 71%, to 13 ms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/bae/ac7/0babaeac7ea9def2d0dc71961e8f482c.png"></div><br>  <i><font color="#999999">Frame output time after optimization</font></i> <br><br><h2>  <font color="#0071c5">Optimization number 3.</font>  <font color="#0071c5">Sort objects from close to far</font> </h2><br>  The term ‚Äúoverdraw‚Äù refers to the repeated drawing of the same pixels of the resulting image.  Pixel redrawing can affect the pixel fill rate and increase the frame output time.  After examining the Samples Written metric, we can see that each pixel of the image in each frame is redrawn, on average, 1.8 times (Resolution / Samples Written). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/148/027/388/148027388e414df190e468018e7c27c8.png"></div><br>  <i><font color="#999999">Samples Written before optimization</font></i> <br><br>  Sorting drawing calls from close to distant objects is a fairly simple way to reduce the redraw effect.  With this approach, the video core pipeline will not redraw the pixels displayed in the previous step. <br><br>  Set the flag Sort Front to Back, capture a frame using System Analyzer and analyze it using Frame Analyzer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b7/ebf/5a0/8b7ebf5a09d4b466e6e2f282bf2c400d.png"></div><br>  <i><font color="#999999">Analysis of the results of the application of sorting call drawing commands</font></i> <br><br>  As a result, the Samples Written metric has decreased by 6%, and the operating time of the GPU has decreased by 8%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/197/252/5f4/1972525f4abbd08da860d21f98a542c5.png"></div><br>  <i><font color="#999999">Samples Written after optimization</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a4/f98/e3d/0a4f98e3d0c4ade8d7242dbd3f3e6fc6.png"></div><br>  <i><font color="#999999">Frame output time after optimization</font></i> <br><br><h2>  <font color="#0071c5">Optimization ‚Ññ4.</font>  <font color="#0071c5">Quick clean</font> </h2><br>  Studying the timeline, we noticed that the very first erg requires maximum GPU time for one operation.  Having selected it, we see that this is not a call to the draw command, but a call to the glClear screen cleaning command. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/344/7d8/a09/3447d8a09d334ae65ae629467e75b764.png"></div><br>  <i><font color="#999999">First erg</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2c9/ca3/52a/2c9ca352ab8c15386505fedd7aa1bc61.png"></div><br>  <i><font color="#999999">Action performed in the first erg</font></i> <br><br>  The video core from Intel has a built-in ability to perform the so-called "quick cleaning".  It takes a small portion of the time required for standard cleaning.  Quick cleanup can be performed by using black or white when calling glClearColor, which are set, respectively, as (0, 0, 0, 0) or (1, 1, 1, 1). <br><br>  Set the Fast Clear flag and perform the traditional procedure for capturing a frame using System Analyzer and its analysis using Frame Analyzer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/41c/003/a27/41c003a27be8a399ab70548de18a3bd3.png"></div><br>  <i><font color="#999999">Frame analysis after using fast cleanup</font></i> <br><br>  After analyzing the frame, we see that the time of the GPU required to perform the cleaning operation has decreased by 87%.  Namely, it takes about 1.2 ms for normal cleaning, and only 0.2 for fast cleaning. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/645/9c4/da3/6459c4da35cb614e5db33985a45e534c.png"></div><br>  <i><font color="#999999">GPU operating time required for routine cleaning</font></i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/555/7cc/4ed/5557cc4ed2fbf6b15e1fec0e7fa78d19.png"></div><br>  <i><font color="#999999">GPU operation time required for fast cleanup</font></i> <br><br>  As a result, the total frame output time was reduced by 24% - to 9.2 ms. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/060/7b4/540/0607b45408ae80bcf31fe5cc9a81cd24.png"></div><br>  <i><font color="#999999">GPU total running time</font></i> <br><br><h2>  <font color="#0071c5">findings</font> </h2><br>  We took a typical mobile game that is in early development.  The game was analyzed using Intel GPA and made changes to the code, designed to increase performance.  We summarize the results of the various stages of optimization in the table. <br><br><table><tbody><tr><td>  <b>Optimization</b> <br></td><td>  <b>Before</b> <br></td><td>  <b>After</b> <br></td><td>  <b>Improvement, in%</b> <br></td></tr><tr><td>  Clipping on the pyramid of visibility <br></td><td>  55.2 ms <br></td><td>  45.0 ms <br></td><td>  18% <br></td></tr><tr><td>  Object Output Optimization <br></td><td>  45.0 ms <br></td><td>  13.2 ms <br></td><td>  71% <br></td></tr><tr><td>  Sort objects <br></td><td>  13.2 ms <br></td><td>  12.1 ms <br></td><td>  eight% <br></td></tr><tr><td>  Quick clean <br></td><td>  12.1 ms <br></td><td>  9,2 ms <br></td><td>  24% <br></td></tr><tr><td>  Overall GPU optimization result <br></td><td>  55.2 ms <br></td><td>  9,2 ms <br></td><td>  83% <br></td></tr></tbody></table><br>  When evaluating any performance test results, you should consider that test software and workloads can be optimized, for example, only for Intel processors.  Test applications, such as SYSmark and MobileMark, calculate performance metrics based on measurements taken on specific computing systems.  Anything can affect the results: the components of these systems, the installed software, and the test suite itself, and their sequence as well. <br><br>  Any change to each of these factors may lead to a change in the test results.  Therefore, taking on the basis of information from test reports any decisions, for example, on the purchase of equipment, you should collect as much information from various sources as possible.  It is necessary to take into account that, for example, tests of the processor ‚ÄúA‚Äù, working in tandem with the operational memory ‚ÄúB‚Äù, may differ from the tests of the same processor in the system in which the memory ‚ÄúC‚Äù is installed.  To learn more about system performance, look <a href="http:/www.intel.com/performance">here</a> . <br><br>  If we sum up all the optimizations applied to City Racer, it turns out that the frame rate has increased by 300% - from 11 frames per second - to 44. Looking at this result, it is worth remembering that we started with a very non-optimal application from the beginning.  Therefore, if we use the same chain of improvements that we have brought here in a real project, the performance gain may not be as significant. <br><br>  Mobile game, of course, is not only performance.  But no matter how ingenious the idea, no matter how well the game balance is calculated, no matter how incredible colors the picture shines, a low FPS can kill anything. <br><br>  We optimized the City Racer training game in this tutorial in order to give you the best weapon to combat the "brakes": recommendations from the Developer's Guide for Intel Processor Graphics and Intel GPA.  We wish you five star reviews of your games. </div><p>Source: <a href="https://habr.com/ru/post/273233/">https://habr.com/ru/post/273233/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273219/index.html">How we made ABBYY FineReader, or a story that happened 20 years ago</a></li>
<li><a href="../273221/index.html">Website recognizes user annoyance by cursor movement.</a></li>
<li><a href="../273223/index.html">Localization of products or another post with the title "Toggle to start"</a></li>
<li><a href="../273225/index.html">Responsibility of the vendor. Who is responsible for the accident?</a></li>
<li><a href="../273231/index.html">Fast algorithm for graph isomorphism problem published</a></li>
<li><a href="../273237/index.html">Robot seller. Automating your sales team with SaaS</a></li>
<li><a href="../273241/index.html">We study the graph-oriented DBMS Neo4j on the example of the lexical database Wordnet</a></li>
<li><a href="../273243/index.html">7 errors of the ETL developer</a></li>
<li><a href="../273245/index.html">Announcement of the JPoint 2016 Java Conference</a></li>
<li><a href="../273247/index.html">We are testing the Russian E-Class server platform from T-Platforms</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>