<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Understand Implicits in Scala</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, I have had several conversations with friends from the Java world about their experiences using Scala. Most used Scala, as improved Java and...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Understand Implicits in Scala</h1><div class="post__text post__text-html js-mediator-article"><img src="https://andr83.io/wp-content/uploads/2018/04/magic_hat.png" alt="image"><br><br>  Recently, I have had several conversations with friends from the Java world about their experiences using Scala.  Most used Scala, as improved Java and, as a result, were disappointed.  The main criticism was directed but the fact that Scala is too powerful language with a high level of freedom, where the same can be implemented in various ways.  Well, the cherry on the cake of discontent are, of course, implicits.  I agree that implicits are one of the most controversial features of the language, especially for beginners.  The name itself is "implicit", as if hinting.  In inexperienced hands, implicits can cause poor application design and a lot of errors.  I think everyone working with Scala has at least once encountered errors in resolving first-time dependencies and the first thoughts were what to do?  where to look?  how to solve a problem?  As a result, you had to google or even read the library documentation, if there is one, of course.  Usually the solution is to import the necessary dependencies and the problem is forgotten until the next time. <br><a name="habracut"></a><br>  In this post I would like to talk about some common practices of using implications and to help them make them more ‚Äúexplicit‚Äù and understandable.  The most common options for their use: <br><br><ul><li>  Implicit parameters </li><li>  Implicit conversions </li><li>  Implicit classes (implicit classes - "Pimp My Library" pattern) </li><li>  Type Classes </li></ul><br>  There are many articles, documentation and reports on this topic.  However, I would like to dwell on their practical application on the example of creating the Scala-friendly API for the wonderful Java library. <del>  Typesafe </del>  <a href="https://github.com/lightbend/config" rel="noopener">Lightbend Config</a> .  First you need to answer the question, but what, in fact, is wrong with the native API?  Let's take a look at an example from the documentation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> com.typesafe.config.<span class="hljs-type"><span class="hljs-type">ConfigFactory</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> conf = <span class="hljs-type"><span class="hljs-type">ConfigFactory</span></span>.load(); <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo = config.getString(<span class="hljs-string"><span class="hljs-string">"simple-lib.foo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bar = config.getInt(<span class="hljs-string"><span class="hljs-string">"simple-lib.bar"</span></span>)</code> </pre> <br>  I see at least two problems here: <br><br><ol><li>  Error processing.  For example, if the <code>getInt</code> method <code>getInt</code> to return the value of the desired type, an exception will be thrown.  And we want to write "clean" code, with no exceptions. </li><li>  Extensibility  This API supports some Java types, but what if we want to extend type support? </li></ol><br>  Let's start with the second problem.  The standard Java solution is inheritance.  We can extend the functionality of the base class by adding new methods.  This is usually not a problem if you own the code, but what if it is a third-party library?  The ‚Äúnaive‚Äù solution in Scala will be through the use of implicit classes or the ‚ÄúPimp My Library‚Äù pattern. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RichConfig</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">val config: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Config</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyVal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocalDate</span></span></span></span>(path: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">LocalDate</span></span> = <span class="hljs-type"><span class="hljs-type">LocalDate</span></span>.parse(config.getString(path), <span class="hljs-type"><span class="hljs-type">DateTimeFormatter</span></span>.<span class="hljs-type"><span class="hljs-type">ISO_DATE</span></span>) }</code> </pre><br>  Now we can use the <code>getLocalDate</code> method as if it were defined in the source class.  Not bad.  But we solved the problem only locally and we must support all new functionality in the same <code>RichConfig</code> class or potentially have an ‚ÄúAmbiguous implicit values‚Äù error if the same methods are defined in different implicit classes. <br><br>  Is there any way to improve this?  Here, let's remember that, usually in Java, inheritance is used to implement polymorphism.  In fact, polymorphism can be of different types: <br><br><ol><li>  Ad hoc polymorphism. </li><li>  Parametric polymorphism. </li><li>  Subtype polymorphism. </li></ol><br>  Inheritance is used to implement polymorphism of subtypes.  We are also interested in ad hoc polymorphism.  It means that we will use a different implementation depending on the type of the parameter.  In Java, this is implemented using method overloading.  In Scala, it can be optionally implemented using class classes.  This concept came from Haskel, where it is embedded in the language, and in Scala it is a pattern that requires implicit'ov for implementation.  In brief, the type class is a contract, for example, <code>Foo[T]</code> trait, parameterized by type <code>T</code> , which is used in resolving implicit dependencies, and the desired implementation of the contract is chosen by type.  It sounds confusing, but in fact it is simple. <br><br>  Let's look at an example.  For our case, we define a contract to read the value from the config: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(config: <span class="hljs-type"><span class="hljs-type">Config</span></span>, path: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">Throwable</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] }</code> </pre><br>  As we can see, the treater <code>Reader</code> parameterized with type <code>A</code>  To solve the first problem, we return <code>Either</code> .  No more exceptions.  To simplify the code, we can write a type alias. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>(config: <span class="hljs-type"><span class="hljs-type">Config</span></span>, path: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Reader</span></span>.<span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Reader</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">Throwable</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](read: (<span class="hljs-type"><span class="hljs-type">Config</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](config: <span class="hljs-type"><span class="hljs-type">Config</span></span>, path: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = <span class="hljs-type"><span class="hljs-type">Try</span></span>(read(config, path)).toEither } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> intReader = <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>]((config: <span class="hljs-type"><span class="hljs-type">Config</span></span>, path: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; config.getInt(path)) <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> stringReader = <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]((config: <span class="hljs-type"><span class="hljs-type">Config</span></span>, path: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; config.getString(path)) <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDateReader = <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">LocalDate</span></span>]((config: <span class="hljs-type"><span class="hljs-type">Config</span></span>, path: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">LocalDate</span></span>.parse(config.getString(path), <span class="hljs-type"><span class="hljs-type">DateTimeFormatter</span></span>.<span class="hljs-type"><span class="hljs-type">ISO_DATE</span></span>);) }</code> </pre><br>  We defined the type reader Reader and added several implementations for the types <code>Int</code> , <code>String</code> , <code>LocalDate</code> .  Now we need to teach <code>Config</code> to work with our taip class.  And here the ‚ÄúPimp My Library‚Äù pattern and implicit arguments come in handy: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigSyntax</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">config: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Config</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyVal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>](path: <span class="hljs-type"><span class="hljs-type">String</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> reader: <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]): <span class="hljs-type"><span class="hljs-type">Reader</span></span>.<span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = reader.read(config, path) }</code> </pre><br>  We can rewrite it more briefly using context bounds: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConfigSyntax</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">config: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Config</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AnyVal</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">as</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span> : <span class="hljs-type"><span class="hljs-type">Reader</span></span>](path: <span class="hljs-type"><span class="hljs-type">String</span></span>): <span class="hljs-type"><span class="hljs-type">Reader</span></span>.<span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>] = implicitly[<span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">A</span></span>]].read(config, path) }</code> </pre><br>  And now, an example of use: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> foo = config.as[<span class="hljs-type"><span class="hljs-type">String</span></span>](<span class="hljs-string"><span class="hljs-string">"simple-lib.foo"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> bar = config.as[<span class="hljs-type"><span class="hljs-type">Int</span></span>](<span class="hljs-string"><span class="hljs-string">"simple-lib.bar"</span></span>)</code> </pre><br>  Typpe classes are a very powerful mechanism that allows you to write easily extensible code.  If support of new types is required, then you can simply write an implementation of the necessary type of class and place it in context.  Also, using <a href="https://www.scala-lang.org/files/archive/spec/2.12/06-expressions.html" rel="noopener">priority</a> in resolving implicit dependencies, you can override the standard implementation.  For example, you can define another version of the <code>LocalDate</code> reader: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> localDateReader2 = <span class="hljs-type"><span class="hljs-type">Reader</span></span>[<span class="hljs-type"><span class="hljs-type">LocalDate</span></span>]((config: <span class="hljs-type"><span class="hljs-type">Config</span></span>, path: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">Instant</span></span> .ofEpochMilli(config.getLong(path)) .atZone(<span class="hljs-type"><span class="hljs-type">ZoneId</span></span>.systemDefault()) .toLocalDate() )</code> </pre><br>  As we can see, implicits, when used properly, allow writing clean and extensible code.  They allow you to extend the functionality of third-party libraries, without changing the source code.  They allow you to write generalized code and use ad hoc polymorphism using type classes.  There is no need to worry about the complex hierarchy of classes, you can simply divide the functionality into parts and implement them separately.  The principle of divide and conquer in action. <br><br>  <a href="https://github.com/andr83/scalaconfig" rel="noopener">Github</a> project with examples. </div><p>Source: <a href="https://habr.com/ru/post/354028/">https://habr.com/ru/post/354028/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354016/index.html">–ï–ì–ê–ò–° 3.0: the differences in the implementation of the metering in wholesale and retail</a></li>
<li><a href="../354018/index.html">Google blocked by Roskomnadzor</a></li>
<li><a href="../354020/index.html">Solving the riddle of round numbers on the 2018 election chart</a></li>
<li><a href="../354024/index.html">The digest of interesting materials for the mobile developer # 250 (April 16 - April 22)</a></li>
<li><a href="../354026/index.html">Review of OpenDay JetBrains mitap</a></li>
<li><a href="../354030/index.html">Mobile application in Python with kivy / buildozer. Lecture in Yandex</a></li>
<li><a href="../354032/index.html">Fuzzy search in relational databases</a></li>
<li><a href="../354034/index.html">Reindexer site search is easy. Or how to make an "instant search" throughout the Habrahabr</a></li>
<li><a href="../354036/index.html">20 Eloquent ORM tricks</a></li>
<li><a href="../354038/index.html">Top VSCode Extensions That Speed ‚Äã‚ÄãUp Your JavaScript Development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>