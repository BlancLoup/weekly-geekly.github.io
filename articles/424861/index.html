<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The snake in the mailbox and what's with F #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What is it all about? 


 It's all about the snake. Everybody perfectly remembers what a snake is: a snake moves on a rectangular field. Finds food - ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The snake in the mailbox and what's with F #</h1><div class="post__text post__text-html js-mediator-article"><h4 id="o-chem-eto-vse">  What is it all about? </h4><br><p>  It's all about the snake.  Everybody perfectly remembers what a snake is: a snake moves on a rectangular field.  Finds food - grows in length, finds itself or the field border - dies.  And the user can only send commands: left, right, up, down. <br>  I decided to add a little action here and make the snake run away from the pakmans.  And all this on the actors! </p><br><p> Therefore, today, using the snake example, I will talk about how to build a model of actors using the <code>MailboxProcessor</code> from the standard library, what points to pay attention to, and what pitfalls you can expect. </p><br><p>  The code written here is not perfect, it can violate some principles and can be written better.  But if you are new and want to deal with mailboxes - I hope this article will help you. <br>  If you know about mailboxes without me, you might be bored here. </p><br><h4 id="pochemu-aktory">  Why actors? </h4><br><p>  For the sake of practice.  I read about the model of actors, watched the video, I liked everything, but did not try it myself.  Now I tried. <br>  In spite of the fact that in fact I chose technology for the sake of technology, the concept very successfully laid down this task. </p><br><h4 id="pochemu-mailboxprocessor-a-ne-naprimer-akkanet">  Why MailboxProcessor, and not, for example, Akka.net? </h4><br><p>  For my task, <code>MailboxProcessor</code> is from the orbital station on sparrows, <code>MailboxProcessor</code> much simpler, and it is included in the standard library, so no packages need to be connected. </p><a name="habracut"></a><br><h4 id="o-meylboks-processorah-i-soputsvuyuschem-boylerpleyte">  About mailbox processors and related boilerplate </h4><br><p>  The bottom line is simple.  The mailbox inside has a message loop and some state.  Your message loop will update this state according to the new incoming message. </p><br><pre> <code class="hljs kotlin">let actor = MailboxProcessor.Start(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> inbox -&gt; // ,    //   . inbox --    MailboxProcessor let rec messageLoop oldState = async { //   let! msg = inbox.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Receive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment">//    let newState = updateState oldState msg //      return! messageLoop newState } //       .    --     messageLoop (0,0) )</span></span></code> </pre> <br><p>  Note that <code>messageLoop</code> recursive, and at the end it must be called again, otherwise only one message will be processed, after which this actor will "die".  Also, <code>messageLoop</code> asynchronous, and each subsequent iteration is performed when a new message is received: <code>let! msg = inbox.Receive()</code>  <code>let! msg = inbox.Receive()</code> . <br>  Thus, the entire logical load goes to the <code>updateState</code> function, which means that to create a mailbox of the processor, we can make a constructor function that accepts the state update function and the zero state: </p><br><pre> <code class="hljs haskell">//   applyMessage       //      (fun inbox -&gt; ...) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> buildActor applyMessage zeroState = <span class="hljs-type"><span class="hljs-type">MailboxProcessor</span></span>.<span class="hljs-type"><span class="hljs-type">Start</span></span>(fun inbox -&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rec</span></span> loop state = async{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span>! msg = inbox.<span class="hljs-type"><span class="hljs-type">Receive</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newState = applyMessage state msg return! loop newState } loop zeroState )</code> </pre><br><p>  Cool!  Now we do not need to constantly make sure not to forget the <code>return! loop newState</code>  <code>return! loop newState</code> .  As is known, the actor keeps the state, but now it is not at all clear how to get this state from the outside.  The mailbox processor has a <code>PostAndReply</code> method that accepts the <code>AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg</code> function <code>AsyncReplyChannel&lt;'Reply&gt; -&gt; 'Msg</code> .  At first it put me in a stupor - it is completely incomprehensible where this function comes from.  But in fact, everything turned out to be simpler: all messages should be wrapped in a DU wrapper, since we now have 2 operations on our actor: send the message itself and ask for the current state.  Here's what it looks like: </p><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ Mail&lt;_,_&gt;   ,  Post &amp; Get --  . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ F#       , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   compare &amp; equals . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         --   . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   [&lt;Struct&gt;] .       type Mail&lt;'msg, 'state&gt; = | Post of 'msg | Get of AsyncReplyChannel&lt;'state&gt;</span></span></code> </pre> <br><p>  Our constructor function now looks like this: </p><br><pre> <code class="hljs erlang-repl">let buildActor applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec loop state = async{ let! msg = inbox.Receive() //    ,     // .    -- ,     //     . //     --      //    .      ! match msg with | Post msg -&gt; let newState = applyMessage state msg return! loop newState | Get channel -&gt; channel.Reply state return! loop state } loop zeroState )</code> </pre><br><p>  Now, to work with mailbox, we need to wrap all our messages in this <code>Mail.Post</code> .  In order not to write it every time, it is better to wrap it in a small apish: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span> Mailbox = let buildAgent applyMessage zeroState = MailboxProcessor.Start(fun inbox -&gt; let rec <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state = async{ let! msg = inbox.Receive() match msg with | Post msg -&gt; let newState = applyMessage state msg <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> newState | Get channel -&gt; channel.Reply state <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>! <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> state } <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> zeroState ) let post (agent: MailboxProcessor&lt;_&gt;) msg = Post msg |&gt; agent.Post let getState (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndReply Get let getStateAsync (agent: MailboxProcessor&lt;_&gt;) = agent.PostAndAsyncReply Get <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   Single Case Discriminated Union. <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> MailboxProcessor   API.      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  -  ,  ,      <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   .       ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>        . type MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt; = MailAgent <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> address:string * mailbox:MailboxProcessor&lt;Mail&lt;<span class="hljs-string"><span class="hljs-string">'msg, '</span></span>state&gt;&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     API with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>            let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.post <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> msg member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetState() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getState <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetStateAsync() = let (MailAgent (address,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Mailbox.getStateAsync <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Address = let (MailAgent (address, _)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> address member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = let (MailAgent (_, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> (this:&gt;IDisposable).Dispose() interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose()</code> </pre> <br><p>  I will tell you about the <code>address:string</code> bit later, but for now our boilerplate is ready. </p><br><h4 id="sobstvenno-zmeyka">  Actually, the snake </h4><br><p>  In the snake there is a snake, a user with his commands, a field and a regular transition to the next frame. <br>  All of this together and you need to spread it over our actors. <br>  I had the original layout like this: </p><br><ul><li>  Actor with a timer.  Accepts messages start / stop / pause.  Once in n milliseconds, flush the message to the <code>Flush</code> actor.  As a state stores <code>System.Timers.Timer</code> </li><li>  Actor commands.  Receives messages from the user <code>Move Up/Down/Left/Right</code> , <code>AddPerk Speed/Attack</code> (yes, my snake can crawl and attack the villains quickly) and <code>Flush</code> from the timer.  As a state, it stores a list of commands, and when it flashes, this list resets. </li><li>  Actor snake.  Stores the state of the snake - perks, length, direction, bends and coordinates. <br>  Accepts the list of messages from the command actor, the <code>Tick</code> message (to move the snake 1 cell forward), and the <code>GrowUp</code> message from the field actor when it finds food. </li><li>  Actor of the field.  It stores a map of cells, accepts the state of a snake in a message and pulls the coordinates onto the existing picture.  It also sends the <code>GrowUp</code> snake actor and the <code>Stop</code> command to the timer if the game is over. </li></ul><br><p>  As you can see, even with such a small number of entities, the message map already turns out to be non-trivial.  And already at this stage difficulties arose: the fact is that by default F # does not allow cyclic dependencies.  In the current line of code, you can only use the code written above, and the same applies to files in the project.  This is not a bug, but a feature, and I love it very much, because it helps to keep the code clean, but what to do when circular references are needed by design?  Of course, you can use <code>rec namespace</code> - and then within one file you can refer to everything in this file, which I used. <br>  The code was expectedly corrupted, but then it seemed the only option.  And it all worked. </p><br><h4 id="problema-vneshnego-mira">  The problem of the outside world </h4><br><p>  Everything worked as long as the whole system of actors was isolated from the outside world, and I just debugged and displayed lines in the console.  When it came time to implement the dependency as a function <code>updateUI</code> , which for each tick should redraw, I could not solve this problem in the current implementation.  Neither ugly nor beautiful - no way.  And then I remembered about Accu - there you can generate actors right along the way, and I have all my actors described at the compilation stage. <br>  The output is obvious - use akku!  No, of course, the acca is still overkill, but I decided to lick out certain points from there - namely, to make a system of actors into which you can dynamically add new actors and query existing actors. <br>  Since the actors are now added and removed in runtime, but are obtained at the address, rather than a direct link, you need to provide a script when the address looks nowhere and the actor is not there.  Following the example of the same account, I added a box for dead letters, and I designed it through my favorite DUs: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Agent&lt;_,_&gt; --  ,   ,     <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     ,      . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      ,    --    Box (mailagent), <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   ,   , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       Deadbox.      MailAgent,  . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>           . <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    --    . type Agent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; = | Box <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message,'</span></span>state&gt; | DeadBox <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> string * MailAgent&lt;string * obj, Map&lt;string,obj list&gt;&gt; with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Post msg = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box box -&gt; box.Post msg | DeadBox (address, deadbox) -&gt; (address, box msg) |&gt; deadbox.Post interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = match <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> with | Box agent -&gt; agent.Dispose() | DeadBox (_,agent) -&gt; agent.Dispose()</code> </pre> <br><p>  And the system itself looks like this: </p><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    .     --    . type MailboxNetwork() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> = <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      .   ! [&lt;DefaultValue&gt;] val mutable agentRegister: ConcurrentDictionary&lt;string, obj&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister &lt;- ConcurrentDictionary&lt;string, obj&gt;() <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      , <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    Map --     let deadLettersFn deadLetters (address:string, msg:obj) = printfn <span class="hljs-string"><span class="hljs-string">"Deadletter: %s-%A"</span></span> address msg match Map.tryFind address deadLetters with <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   | None -&gt; Map.add address [msg] deadLetters <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   --   | Some letters -&gt; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --      Map.remove address deadLetters |&gt; Map.add address (msg::letters) let deadLettersAgent() = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"deadLetters"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Map.empty |&gt; Mailbox.buildAgent deadLettersFn)</span></span></span><span class="hljs-function"> |&gt; MailAgent member this.DeadLetters = deadLettersAgent</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> // -     ,      member this.Box&lt;'message,'state&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address)</span></span></span><span class="hljs-function"> = match this.agentRegister.TryGetValue address with | </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params">, agent)</span></span></span><span class="hljs-function"> when </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(agent :? MailAgent&lt;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'message,'</span></span></span></span><span class="hljs-function"><span class="hljs-params">state&gt;)</span></span></span><span class="hljs-function"> -&gt;</span></span> <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,       ,   let agent = agent :?&gt; MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'message, '</span></span>state&gt; Box agent | _ -&gt; DeadBox (address, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DeadLetters) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --    member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox address = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryRemove(address) |&gt; ignore member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RespawnBox (agent: MailAgent&lt;<span class="hljs-string"><span class="hljs-string">'a,'</span></span>b&gt;) = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.KillBox agent.Address <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.TryAdd (agent.Address, agent) |&gt; ignore interface IDisposable with member <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dispose() = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> agent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.agentRegister.Values <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> match agent with | :? IDisposable <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> agent -&gt; agent.Dispose() | _ -&gt; ()</code> </pre> <br><p>  This is where the <code>address:string</code> about which I wrote above came in handy for us.  And again, everything worked, external dependence was now easy to throw where necessary.  The constructor functions of the actors now accepted as argument the system of actors and reached from there the necessary addressees: </p><br><pre> <code class="hljs haskell"> //    - (  )   - <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) //    message loop           <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> []</code> </pre><br><h4 id="medlenno">  Slow </h4><br><p>  For obvious reasons, I set a low game speed during debugging: the delay between ticks was more than 500 milliseconds.  If you reduce the delay to 200, the messages started to arrive late, and the commands from the user worked with a delay, which spoiled the whole game.  An additional fly in the ointment was the fact that the stop command received the timer several times in case of loss.  For the user, this did not manifest at all, but nevertheless, there was some kind of bug. <br>  The unpleasant truth was that actors are, of course, conveniently cool, but a direct method call is much faster.  Therefore, despite the fact that the snake itself was conveniently stored in a separate actor from the point of view of organizing the code, this idea had to be abandoned for the sake of speed, because the message exchange was too intense for 1 tact of the game: </p><br><ol><li>  The user sends an arbitrary number of commands directly to the command actor. </li><li>  The timer sends a tick to the actor and, in an early implementation, also to the actor of the snake, so that it moves the snake to the next cell. </li><li>  Actor commands sends a list of commands for the snake, when the corresponding message comes from the timer. </li><li>  The actor of the snake, updating its state according to the 2 upper messages, sends the state to the field actor. </li><li>  The field actor redraws everything.  If the snake has found food, then it sends a <code>GrowUp</code> message to the snake actor, after which it sends a new state back to the field actor. </li></ol><br><p>  And for all this there is 1 clock cycle, which is not enough, taking into account synchronization in the depths of the <code>MailboxProcessor</code> .  Moreover, in the current implementation, the timer sends the following message every n milliseconds regardless of anything, so that if we didn‚Äôt fit in time, the messages start to accumulate, and the situation worsens.  It would be much better to ‚Äústretch‚Äù this particular tact, process everything that has accumulated, and go on. </p><br><h4 id="finalnaya-versiya">  Final version </h4><br><p>  Obviously, the message scheme should be simplified, while it is very desirable to leave the code as simple and accessible as possible - let‚Äôs say, I don‚Äôt want to push everything in 1 god actor, and then the actors don‚Äôt make much of it. <br>  Therefore, looking at my list of actors, I realized that the first thing to do is sacrifice a snake actor.  A timer is needed, a buffer of user commands is also needed to accumulate them in real time, but to pour out only once per clock, and there is no objective need to keep a snake in a separate actor, this was done simply for convenience.  In addition, having been with the field actor it will be possible to process the <code>GrowUp</code> script without delay.  <code>Tick</code> message for a snake doesn‚Äôt make much sense either, because when we receive a message from an actor in commands, this already means that a new beat has happened.  Adding to this the stretching of the clock in case of a delay, we have the following changes: </p><br><ol><li>  Remove <code>Tick</code> &amp; <code>GrowUp</code> posts. </li><li>  The snake actor is merging into the field actor - he will now keep a "tapl" of these states. </li><li>  We remove <code>System.Timers.Timer</code> from the timer actor.  Instead, the scheme of work will be the following: receiving the <code>Start</code> command, it sends <code>Flush</code> command actor.  He sends a list of commands to the actor of the field + snakes, the last actor handles all this and sends the message <code>Next</code> to the timer, thus requesting a new tick from it.  The timer, on receiving <code>Next</code> waits for <code>Thread.Sleep(delay)</code> and starts the whole circle from the beginning.  It's simple. </li></ol><br><p>  Summarize. </p><br><ul><li>  In the previous implementation, 500 ms were the minimum allowable delay.  In the current delay, you can remove it altogether - the actor of the field will request a new time when it is ready.  The accumulation of unprocessed messages from previous clocks is now impossible. </li><li>  The messaging map is greatly simplified - instead of a complex graph, we have the simplest cycle. </li><li>  This simplification solved that bug, when the timer received <code>Stop</code> several times in case of loss. </li><li>  The list of messages has decreased.  Less code - less evil! </li></ul><br><p>  It looks like this: </p><br><pre> <code class="hljs haskell"> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] commandAddress = <span class="hljs-string"><span class="hljs-string">"command"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] timerAddress = <span class="hljs-string"><span class="hljs-string">"timer"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [&lt;<span class="hljs-type"><span class="hljs-type">Literal</span></span>&gt;] gameAddress = <span class="hljs-string"><span class="hljs-string">"game"</span></span> // -     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">CommandMessage</span></span>, <span class="hljs-type"><span class="hljs-type">Command</span></span> list&gt;(commandAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">TimerCommand</span></span>, <span class="hljs-type"><span class="hljs-type">TimerState</span></span>&gt;(timerAddress) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) = mailboxNetwork.<span class="hljs-type"><span class="hljs-type">Box</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Command</span></span> list, <span class="hljs-type"><span class="hljs-type">GameState</span></span>&gt;(gameAddress) // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) updateUi gameState cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgent = timerAgent mailboxNetwork //    match gameState.gameFrame with //     | <span class="hljs-type"><span class="hljs-type">Frame</span></span> field -&gt; //       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameState = <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Next</span></span> //    updateUi gameState //     gameState // ! | <span class="hljs-type"><span class="hljs-type">End</span></span> (<span class="hljs-type"><span class="hljs-type">Win</span></span> _) -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> <span class="hljs-type"><span class="hljs-type">Game</span></span>.updateGameState gameState cmd //        | _ -&gt; timerAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Stop</span></span> //     gameState // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) commands msg = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameAgent = gameAgent mailboxNetwork match msg with | <span class="hljs-type"><span class="hljs-type">Cmd</span></span> cmd -&gt; cmd::commands //       | <span class="hljs-type"><span class="hljs-type">Flush</span></span> -&gt; commands |&gt; gameAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> //     [] // message loop   <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> timerAgentFn (mailboxNetwork: <span class="hljs-type"><span class="hljs-type">MailboxNetwork</span></span>) (state: <span class="hljs-type"><span class="hljs-type">TimerState</span></span>) cmd = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> commandAgent = commandAgent mailboxNetwork match cmd with | <span class="hljs-type"><span class="hljs-type">Start</span></span> -&gt; commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; {state with active = true} | <span class="hljs-type"><span class="hljs-type">Next</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //    ,     <span class="hljs-type"><span class="hljs-type">Threading</span></span>.<span class="hljs-type"><span class="hljs-type">Thread</span></span>.<span class="hljs-type"><span class="hljs-type">Sleep</span></span>(state.delay) commandAgent.<span class="hljs-type"><span class="hljs-type">Post</span></span> <span class="hljs-type"><span class="hljs-type">Flush</span></span>; state | <span class="hljs-type"><span class="hljs-type">Stop</span></span> -&gt; printfn <span class="hljs-string"><span class="hljs-string">"Stop received"</span></span>; { state with active = false } | <span class="hljs-type"><span class="hljs-type">PauseOrResume</span></span> -&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> not state.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> //     <span class="hljs-comment"><span class="hljs-comment">--   commandAgent.Post Flush { state with active = not state.active } | SetDelay delay -&gt; Threading.Thread.Sleep(delay) if state.active then commandAgent.Post Flush {state with delay = delay}</span></span></code> </pre> <br><h4 id="ssylki">  Links </h4><br><ul><li>  <a href="https://fsharpforfunandprofit.com/posts/concurrency-actor-model/">Introduction to Mailboxes</a> </li><li>  <a href="">Mailbox sources for the most inquisitive</a> </li><li>  <a href="https://github.com/kagetoki/PostOffice">Sources for the actor model</a> </li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/424861/">https://habr.com/ru/post/424861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../424851/index.html">What is wrong with hiring in IT?</a></li>
<li><a href="../424853/index.html">The story of one controller view that wanted to show off beautifully</a></li>
<li><a href="../424855/index.html">Machine Learning: Room Elephant Fight</a></li>
<li><a href="../424857/index.html">CloudFlare has implemented support for Encrypted SNI</a></li>
<li><a href="../424859/index.html">Simplest Arduino Game with Display 1602 - Part # 1</a></li>
<li><a href="../424865/index.html">Found elementary design particles</a></li>
<li><a href="../424867/index.html">Developing a hexapod from scratch (part 1) - designing</a></li>
<li><a href="../424869/index.html">As a new feature iOS 12 reminded me that it was time to be treated</a></li>
<li><a href="../424871/index.html">Ilon Musk and Tesla settle legal disputes with the US Securities and Exchange Commission</a></li>
<li><a href="../424873/index.html">Pitfalls of HttpClient in .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>