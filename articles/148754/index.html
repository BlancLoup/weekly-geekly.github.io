<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Android streaming video</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post I want to talk about some of the pitfalls that can be encountered when working with streaming video in Android applications. Specifically...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Android streaming video</h1><div class="post__text post__text-html js-mediator-article">  In this post I want to talk about some of the pitfalls that can be encountered when working with streaming video in <i>Android</i> applications.  Specifically, it will be about video conversion and video delivery / playback protocols. <br>  Immediately, I‚Äôll make a reservation that I am not an expert in this field, but just want to share my recently gained experience. <br><br><br><a name="habracut"></a><br>  Imagine that you are faced with the task of implementing an <i>Android</i> application capable of playing many files uploaded by users to your server.  Write your youtube, with blackjack and codecs.  To do this, you will have to solve at least two tasks: video conversion to a format supported on <i>Android</i> , video playback from a remote source.  Consider both of these tasks in more detail. <br><br><br><h2>  Video conversion </h2><br>  And so, before you play some video on our <i>Android</i> device, you need to transcode this video into a supported format.  The Android documentation clearly identifies a <a href="http://developer.android.com/guide/appendix/media-formats.html">list of</a> these formats. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In order to transcode files uploaded by users to your service, or to record stream from a TV tuner, you will need the help of a special utility <a href="http://ffmpeg.org/">ffmpeg</a> , which is the de facto standard in the industry.  Detailed instructions for its installation can be found on the <a href="https://ffmpeg.org/trac/ffmpeg/wiki/UbuntuCompilationGuide">site of the same name project</a> . <br><br><br>  The most common (in my opinion) video storage method is the <i>MP4</i> container using the <i>H.264 AVC codec</i> .  We will, in fact, consider them. <br><br><br>  First of all, note that <i>Android</i> does not support all the features of the <i>H.264</i> codec, but only a specific set ‚Äî a profile called <a href="http://en.wikipedia.org/wiki/H.264/MPEG-4_AVC">Baseline Profile</a> (BP).  For example, <i>BP</i> does not include such useful <i>H.264</i> features as <a href="http://en.wikipedia.org/wiki/CABAC">CABAC</a> or <a href="http://en.wikipedia.org/wiki/Video_compression_picture_types">B-Frames</a> . <br><br><br>  For us, this means that if we use these features when encoding a video, then <i>Android</i> will not have to lose this video.  Although it may, if your phone is powerful enough and the vendor has taken care of installing and supporting additional codecs.  For example, the video in the <i>Main Profile</i> is played without any problems on the <i>Samsung Galaxy SII</i> .  On the phones of the usual class (for example, <i>Samsung Galaxy Ace</i> ) we will receive a message about the impossibility of playing the video and an error with the codec of the wrong codec in <i>logcat</i> . <br><br><br>  But let's move from theory to practice.  In order to compress the video, you must run the following command: <br><br><blockquote>  ffmpeg -i in.3gp -f mp4 <br>  -vcodec libx264 -vprofile baseline -b: v 1500K <br>  -acodec libfaac -b: a 128k -ar 44100 -ac 2 <br>  -y out.mp4 <br></blockquote><br><br>  Let us consider in more detail each of the parameters: <br><ul><li>  <i>-i src</i> input (recoded) file; </li><li>  <i>-f mp4</i> video <i>container</i> used; </li><li>  <i>-vcodec libx264</i> video codec used; </li><li>  <i>-vprofile baseline</i> profile used; </li><li>  <i>-b: v 1500K</i> bitrate; </li><li>  <i>-acodec libfaac</i> used audio codec; </li><li>  <i>-b: a 128k</i> audio bitrate; </li><li>  <i>-ar 44100</i> sound frequency; </li><li>  <i>-ac 2</i> number of audio streams; </li><li>  <i>-y</i> flag for overwriting the output file; </li></ul><br><br>  It is also worth noting that you can do without specifying the profile, and explicitly enable / disable the necessary options for the <i>H.264</i> codec through the <i>-x264opts</i> parameter, so that they would satisfy the conditions of <i>BP</i> .  But this is a lesson for lovers. <br><br><br><br><h2>  Video distribution </h2><br>  The easiest way to play video from a remote server is to download it to temporary storage and play it locally.  However, I think everyone understands that in view of the size of modern video recordings - this is not an option. <br><br><br>  How to be?  The Android platform offers us native support for the following technologies / protocols: <br><ul><li>  HTTP / HTTPS progressive streaming; </li><li>  HTTP / HTTPS live streaming; </li><li>  RTSP (RTP, SDP); </li></ul><br><br>  Consider them in order. <br><br><br><h3>  Progressive streaming </h3><br>  The easiest way to distribute video using a conventional web server, which essentially amounts to downloading a previously prepared file using the <i>HTTP (S)</i> protocol.  The whole point in this case is that the file does not start playing at the end of the download, but as soon as enough data is downloaded (some buffer is filled). <br><br><br>  Here it is worth clarifying that when using the <i>MP4</i> container, it is necessary to form a file so that metadata about the video stream ( <i>moov atoms</i> ) is located at the beginning of the file (after the <i>ftyp</i> atom), before the video data ( <i>mdat atoms</i> ).  This can be done by processing the file with the <i>qt-faststart</i> utility: <br><br><blockquote>  qt-faststart output.mp4 result.mp4 <br></blockquote><br><br>  The main problem of <i>progressive streaming</i> is the impossibility of rewinding video to a non-downloaded moment, the presence of a sufficient amount of free space on the device and the need to support a large number of "fat" clients downloading videos on a web server. <br><br><br>  Reproduction using this technology is supported by the Android platform natively.  You can easily play a remote file using the standard <i>MediaPlayer</i> class (apart from the communication channel, power of the device and availability of free space). <br><br><br><h3>  Pseudo streaming </h3><br>  This technology is a logical extension of <i>progressive streaming</i> 'a and allows you to solve one of its main problems - rewinding to a fragment that has not yet been downloaded.  Applicable for <i>MP4</i> / <i>FLV</i> containers with <i>H.264</i> / <i>AAC</i> codec. <br><br><br>  The only difference from <i>progressive streaming</i> 'a in this case is the fact that you need a special web server that, given the timestamp in the GET request, will give you the fragment of the video file you need.  An example of such a web server can naturally serve as an Orthodox <i>NGINX</i> with its <a href="http_mp4_module.html">ngx_http_mp4_module</a> . <br><br><br>  I could not find any official information regarding the support of this standard in <i>Android</i> .  However, empirically, it was found that it is present on at least <i>HTC Desire</i> and <i>Samsung Galaxy SII</i> devices.  However, I want to note that even if there is no native support on your device, you can always use third-party players like <i>MX Player</i> , who independently implement the logic of downloading and playing video fragments with the required timestamp, which allows you to organize rewind. <br><br><br><h3>  Live streaming </h3><br>  Quite a non-standard <a href="http://en.wikipedia.org/wiki/HTTP_Live_Streaming">data</a> transfer protocol from <i>Apple</i> .  Its essence boils down to the fact that the file being distributed is ‚Äúsawn‚Äù into many small parts, joined by a special M3U8 format <i>playlist</i> .  Data transfer occurs via the <i>HTTP (S)</i> protocol. <br><br><br>  There are no problems with rewind and free space on the device in this case.  Moreover, under certain conditions, you have the opportunity to choose the quality of the video being played. <br><br><br>  However, there are problems.  To ‚Äúcut‚Äù a file and create a playlist will require processor resources, time and space on the server.  To broadcast a file to the network, as in the previous examples, you will need an HTTP server (without any additional modules). <br><br>  You can use <a href="http://wiki.videolan.org/Documentation:Streaming_HowTo/Streaming_for_the_iPhone">VLC to</a> cut a video file: <br><br><blockquote>  vlc -I dummy /path/to/pornofilm.mpg vlc: // quit --sout '#transcode {width = 320, height = 240, fps = 25, vcodec = h264, vb = 256, venc = x264 {aud, profile = baseline, level = 30, keyint = 30, ref = 1}, acodec = mp3, ab = 96}: std {access = livehttp {seglen = 10, delsegs = false, numsegs = 0, index = / path / to /web/server/root/pornofilm.m3u8,index-url=http://localhost/pornofilm/stream-########.ts }mmux{useuse- /path/to/web/server/root/pornofilm/stream-#######.ts} ' <br></blockquote><br><br>  You can play this file at the URL <i><a href="">localhost / pornofilm.m3u8</a></i> . <br><br><br>  Support for <i>HTTP Live Streaming</i> at the native level in Android has been present since version 3.0.  With the help of third-party players ( <i>DicePlayer</i> , <i>MX Player</i> ), judging by the wiki, you can achieve support from version 2.2. <br><br><br><h3>  Real Time Streaming Protocol (RTSP) </h3><br>  <a href="http://en.wikipedia.org/wiki/RTSP">A</a> state-level application <a href="http://en.wikipedia.org/wiki/RTSP">protocol</a> designed specifically for video transmission.  The command format is very similar to <i>HTTP</i> .  The teams themselves resemble buttons on a conventional cassette recorder: PLAY, PAUSE, RECORD, etc. <br><br><br>  Unlike <i>HTTP Live Streaming,</i> <i>RTSP</i> does not require splitting files into smaller parts and creating playlists.  The necessary parts of the file will be generated and given to the client on the fly.  <a href="http://www.videolan.org/doc/streaming-howto/en/ch05.html">VLC</a> can be used as an <i>RTSP</i> server. <br><br><br>  It is worth noting that the <i>RTSP</i> protocol itself does not determine the method of data transmission, but delegates this to other protocols.  For example, <a href="http://en.wikipedia.org/wiki/Real-time_Transport_Protocol">RTP</a> .  To stream a file using the <i>RTP</i> protocol, you will need to run <i>VLC</i> with the following parameters: <br><br><blockquote>  vlc -vvv /path/to/pornofilm.mp4 --sout '#rtp {dst = localhost, port = 1234, sdp = rtsp: // localhost: 8080 / pornofilm.sdp}' <br></blockquote><br><br>  However, it would be foolish to raise for each file its own process with a separate port, regardless of the presence of users who want to view it. <br><br><br>  So back to the <i>RTSP</i> protocol and video playback on demand (Vidoe On Demand).  In order to use <i>VLC</i> as an <i>RTSP</i> server to play VOD, you must first run <i>VLC</i> , specifying the attributes of the <i>RTSP</i> server and the <i>Telnet</i> interface: <br><br><blockquote>  vlc -vvv -I telnet --telnet-password 123 --rtsp-host 127.0.0.1 --rtsp-port 5554 <br></blockquote><br><br>  After that, as the server is started, you need to configure it.  It is most convenient to do this with the help of <i>telnet</i> 'a, since such an approach makes it possible to adjust on the fly: <br><br><blockquote>  new porno vod enabled <br><br>  setup porno input /path/to/pornofilm.mpg <br></blockquote><br><br>  To play a video (including on the Android platform), you need to request it at the URL <i>rtsp: // localhost: 5554 / pornofilm</i> . <br><br><br>  Among the shortcomings, we can note the fact that <i>HTTP</i> is often open on all firewalls and proxies ... with <i>RTSP</i> in the case of Deny, Allow policies, everything is different. <br><br>  In addition, when using the <i>RTSP</i> server, to add / delete files on the server, you will have to update its configuration (list of vods).  Yes, there is <i>telnet</i> for this, but it is still more difficult than just uploading or deleting files from web server directories. <br><br><br>  Reproduction using this technology is supported by the Android platform natively.  For example, using the same standard class <i>MediaPlayer</i> . <br><br><br><h3>  Multicast </h3><br>  Many people believe that <i>multicast</i> does not work in Android.  This is not quite true. <br><br><br>  Firstly, in most cases it is simply disabled by default so as not to load the device resources with unnecessary work.  You can simply <a href="http://developer.android.com/reference/android/net/wifi/WifiManager.MulticastLock.html">turn</a> it <a href="http://developer.android.com/reference/android/net/wifi/WifiManager.MulticastLock.html">on</a> . <br><br><br>  Secondly, yes - on a rather impressive number of devices it is disabled in everything or it does not work correctly.  On the Internet, so you can <a href="http://google.com/search%3Fq%3Dandroid%2Bmulticast%2Berror">find a</a> lot of tears and even some solutions. <br><br><br>  However, as practice shows, everything can be played on <i>multicast</i> video on <i>Android</i> .  In my case, the recently released <a href="https://play.google.com/store/apps/details%3Fid%3Dorg.videolan.vlc.betav7neon">VLC Beta</a> for <i>Android</i> successfully coped with this task. <br><br><br>  In addition, using <i>VLC</i> server you can always reduce the playback of <i>multicast</i> 'a to <i>HLS</i> : <br><br><blockquote>  vlc -I dummy udp: //@192.168.20.1: 1234 vlc: // quit --sout '#transcode {width = 320, height = 240, fps = 25, vcodec = h264, vb = 256, venc = x264 { aud, profile = baseline, level = 30, keyint = 30, ref = 1}, acodec = mp3, ab = 96}: std {access = livehttp {seglen = 10, delsegs = false, numsegs = 0, index = / path /to/web/server/root/multicast-porno.m3u8,index-url=http://localhost/multicast-porno/stream-#######.ts (mu) -frames}, dst = / path / to / web / server / root / multicast-porno / stream - ########. ts} ' <br></blockquote><br>  or rtsp: <br><blockquote>  new multicast-porno vod enabled <br><br>  setup multicast-porno input udp: //@192.168.20.1: 1234 <br></blockquote><br><br>  You can try your luck with playing multicast on your device by giving the player a URL like <i>udp: //@192.168.20.1: 1234</i> . <br><br><br><h2>  What to choose </h2><br>  If everything is clear with the video format ( <i>H.264 BP</i> / <i>MP4</i> ), then the question is open with the distribution method.  Each of them has its advantages and disadvantages. <br><br><br>  First of all, I would remove the usual <i>progressive streaming</i> from consideration.  Yes, it works always and everywhere, but the lack of rewinding and downloading the entire file is too much. <br><br><br>  The next candidate for crash is <i>live streaming</i> .  Its main disadvantage is native support in <i>Android</i> since version 3.0.  And ignoring more than <a href="http://developer.android.com/about/dashboards/index.html">80% of users</a> with version 2.x is not an option.  Although here you can look at a third-party player, or do your own implementation (I, alas, did not find any free practices to support <i>HLS</i> ). <br><br><br>  And the last one I would have struck off the RTSP.  Yes, this is a protocol designed specifically for video.  Yes, its use is ideologically correct.  But there are two points.  Firstly - you need to constantly update the server configuration.  Secondly, <i>HTTP is</i> open always and everywhere, which is not the case with <i>RTSP</i> / <i>RTP</i> . <br><br><br>  Personally, I would stop at <i>pseudo streaming</i> .  It allows you to rewind and not download the entire file completely.  All we have to do is tweak the web server a bit. <br></div><p>Source: <a href="https://habr.com/ru/post/148754/">https://habr.com/ru/post/148754/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../148745/index.html">How much is SDN?</a></li>
<li><a href="../148746/index.html">Android docking station Philips Fidelio or phone audio system</a></li>
<li><a href="../148749/index.html">Marissa Mayer started by making Yahoo free</a></li>
<li><a href="../148750/index.html">10 of the most original and useful gadgets according to OViVO</a></li>
<li><a href="../148753/index.html">The service "Hello" from Beeline or algorithm invisible debiting money from your account</a></li>
<li><a href="../148755/index.html">Blackberry10 development: all videos from Blackberry 10 Jam Moscow!</a></li>
<li><a href="../148756/index.html">How the Mediawiki parser works</a></li>
<li><a href="../148757/index.html">ReSharper 7 supports Visual Studio 2012 and simplifies the development of Metro applications.</a></li>
<li><a href="../148758/index.html">Display of dependent data, for example, using two drop-down lists, using knockout</a></li>
<li><a href="../148759/index.html">Satellite monitoring. Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>